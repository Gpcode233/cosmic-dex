"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ox";
exports.ids = ["vendor-chunks/ox"];
exports.modules = {

/***/ "(ssr)/../../node_modules/ox/_cjs/core/AbiConstructor.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/AbiConstructor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decode = decode;\nexports.encode = encode;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/cjs/exports/index.js\");\nconst AbiItem = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/../../node_modules/ox/_cjs/core/AbiItem.js\");\nconst AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/../../node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nfunction decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return AbiParameters.decode(abiConstructor.inputs, data);\n}\nfunction encode(abiConstructor, options) {\n    const { bytecode, args } = options;\n    return Hex.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? AbiParameters.encode(abiConstructor.inputs, args)\n        : '0x');\n}\nfunction format(abiConstructor) {\n    return abitype.formatAbiItem(abiConstructor);\n}\nfunction from(abiConstructor) {\n    return AbiItem.from(abiConstructor);\n}\nfunction fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new AbiItem.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BYmlDb25zdHJ1Y3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osZUFBZTtBQUNmLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFvQjtBQUNsRCxZQUFZLG1CQUFPLENBQUMsOERBQVU7QUFDOUI7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMscUJBQXFCO0FBQy9EO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcQWJpQ29uc3RydWN0b3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZSA9IGRlY29kZTtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5mcm9tQWJpID0gZnJvbUFiaTtcbmNvbnN0IGFiaXR5cGUgPSByZXF1aXJlKFwiYWJpdHlwZVwiKTtcbmNvbnN0IEFiaUl0ZW0gPSByZXF1aXJlKFwiLi9BYmlJdGVtLmpzXCIpO1xuY29uc3QgQWJpUGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuL0FiaVBhcmFtZXRlcnMuanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5mdW5jdGlvbiBkZWNvZGUoYWJpQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJ5dGVjb2RlIH0gPSBvcHRpb25zO1xuICAgIGlmIChhYmlDb25zdHJ1Y3Rvci5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zLmRhdGEucmVwbGFjZShieXRlY29kZSwgJzB4Jyk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZGVjb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgZGF0YSk7XG59XG5mdW5jdGlvbiBlbmNvZGUoYWJpQ29uc3RydWN0b3IsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJ5dGVjb2RlLCBhcmdzIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIZXguY29uY2F0KGJ5dGVjb2RlLCBhYmlDb25zdHJ1Y3Rvci5pbnB1dHM/Lmxlbmd0aCAmJiBhcmdzPy5sZW5ndGhcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlDb25zdHJ1Y3Rvci5pbnB1dHMsIGFyZ3MpXG4gICAgICAgIDogJzB4Jyk7XG59XG5mdW5jdGlvbiBmb3JtYXQoYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUNvbnN0cnVjdG9yKTtcbn1cbmZ1bmN0aW9uIGZyb20oYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUNvbnN0cnVjdG9yKTtcbn1cbmZ1bmN0aW9uIGZyb21BYmkoYWJpKSB7XG4gICAgY29uc3QgaXRlbSA9IGFiaS5maW5kKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicpO1xuICAgIGlmICghaXRlbSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWU6ICdjb25zdHJ1Y3RvcicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlDb25zdHJ1Y3Rvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/AbiFunction.js":
/*!******************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/AbiFunction.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeData = decodeData;\nexports.decodeResult = decodeResult;\nexports.encodeData = encodeData;\nexports.encodeResult = encodeResult;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nexports.getSelector = getSelector;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/cjs/exports/index.js\");\nconst AbiItem = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/../../node_modules/ox/_cjs/core/AbiItem.js\");\nconst AbiParameters = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/../../node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nfunction decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (Hex.size(data) < 4)\n        throw new AbiItem.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (Hex.size(data) <= 4)\n        return undefined;\n    return AbiParameters.decode(item.inputs, Hex.slice(data, 4));\n}\nfunction decodeResult(abiFunction, data, options = {}) {\n    const values = AbiParameters.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\nfunction encodeData(abiFunction, ...args) {\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args: args[0],\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0\n        ? AbiParameters.encode(item.inputs, args[0])\n        : undefined;\n    return data ? Hex.concat(selector, data) : selector;\n}\nfunction encodeResult(abiFunction, output, options = {}) {\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return AbiParameters.encode(abiFunction.outputs, values);\n}\nfunction format(abiFunction) {\n    return abitype.formatAbiItem(abiFunction);\n}\nfunction from(abiFunction, options = {}) {\n    return AbiItem.from(abiFunction, options);\n}\nfunction fromAbi(abi, name, options) {\n    const item = AbiItem.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new AbiItem.NotFoundError({ name, type: 'function' });\n    return item;\n}\nfunction getSelector(abiItem) {\n    return AbiItem.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BYmlGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0I7QUFDbEIsb0JBQW9CO0FBQ3BCLGtCQUFrQjtBQUNsQixvQkFBb0I7QUFDcEIsY0FBYztBQUNkLFlBQVk7QUFDWixlQUFlO0FBQ2YsbUJBQW1CO0FBQ25CLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3RDLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFvQjtBQUNsRCxZQUFZLG1CQUFPLENBQUMsOERBQVU7QUFDOUI7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQSxxREFBcUQsTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHdCQUF3QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXEFiaUZ1bmN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVEYXRhID0gZGVjb2RlRGF0YTtcbmV4cG9ydHMuZGVjb2RlUmVzdWx0ID0gZGVjb2RlUmVzdWx0O1xuZXhwb3J0cy5lbmNvZGVEYXRhID0gZW5jb2RlRGF0YTtcbmV4cG9ydHMuZW5jb2RlUmVzdWx0ID0gZW5jb2RlUmVzdWx0O1xuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5mcm9tQWJpID0gZnJvbUFiaTtcbmV4cG9ydHMuZ2V0U2VsZWN0b3IgPSBnZXRTZWxlY3RvcjtcbmNvbnN0IGFiaXR5cGUgPSByZXF1aXJlKFwiYWJpdHlwZVwiKTtcbmNvbnN0IEFiaUl0ZW0gPSByZXF1aXJlKFwiLi9BYmlJdGVtLmpzXCIpO1xuY29uc3QgQWJpUGFyYW1ldGVycyA9IHJlcXVpcmUoXCIuL0FiaVBhcmFtZXRlcnMuanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5mdW5jdGlvbiBkZWNvZGVEYXRhKGFiaUZ1bmN0aW9uLCBkYXRhKSB7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8IDQpXG4gICAgICAgIHRocm93IG5ldyBBYmlJdGVtLkludmFsaWRTZWxlY3RvclNpemVFcnJvcih7IGRhdGEgfSk7XG4gICAgaWYgKGFiaUZ1bmN0aW9uLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgaXRlbSA9IG92ZXJsb2Fkc1xuICAgICAgICA/IGZyb21BYmkoW2FiaUZ1bmN0aW9uLCAuLi5vdmVybG9hZHNdLCBkYXRhKVxuICAgICAgICA6IGFiaUZ1bmN0aW9uO1xuICAgIGlmIChIZXguc2l6ZShkYXRhKSA8PSA0KVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmRlY29kZShpdGVtLmlucHV0cywgSGV4LnNsaWNlKGRhdGEsIDQpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVJlc3VsdChhYmlGdW5jdGlvbiwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdmFsdWVzID0gQWJpUGFyYW1ldGVycy5kZWNvZGUoYWJpRnVuY3Rpb24ub3V0cHV0cywgZGF0YSwgb3B0aW9ucyk7XG4gICAgaWYgKHZhbHVlcyAmJiBPYmplY3Qua2V5cyh2YWx1ZXMpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh2YWx1ZXMpWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gZW5jb2RlRGF0YShhYmlGdW5jdGlvbiwgLi4uYXJncykge1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBpdGVtID0gb3ZlcmxvYWRzXG4gICAgICAgID8gZnJvbUFiaShbYWJpRnVuY3Rpb24sIC4uLm92ZXJsb2Fkc10sIGFiaUZ1bmN0aW9uLm5hbWUsIHtcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NbMF0sXG4gICAgICAgIH0pXG4gICAgICAgIDogYWJpRnVuY3Rpb247XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihpdGVtKTtcbiAgICBjb25zdCBkYXRhID0gYXJncy5sZW5ndGggPiAwXG4gICAgICAgID8gQWJpUGFyYW1ldGVycy5lbmNvZGUoaXRlbS5pbnB1dHMsIGFyZ3NbMF0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBkYXRhID8gSGV4LmNvbmNhdChzZWxlY3RvciwgZGF0YSkgOiBzZWxlY3Rvcjtcbn1cbmZ1bmN0aW9uIGVuY29kZVJlc3VsdChhYmlGdW5jdGlvbiwgb3V0cHV0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAoYWJpRnVuY3Rpb24ub3V0cHV0cy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW291dHB1dF07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dCkpXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICBpZiAoYXMgPT09ICdPYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUZ1bmN0aW9uLm91dHB1dHMsIHZhbHVlcyk7XG59XG5mdW5jdGlvbiBmb3JtYXQoYWJpRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUZ1bmN0aW9uKTtcbn1cbmZ1bmN0aW9uIGZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBBYmlJdGVtLmZyb20oYWJpRnVuY3Rpb24sIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucyk7XG4gICAgaWYgKGl0ZW0udHlwZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEFiaUl0ZW0uTm90Rm91bmRFcnJvcih7IG5hbWUsIHR5cGU6ICdmdW5jdGlvbicgfSk7XG4gICAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/AbiItem.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/AbiItem.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidSelectorSizeError = exports.NotFoundError = exports.AmbiguityError = void 0;\nexports.format = format;\nexports.from = from;\nexports.fromAbi = fromAbi;\nexports.getSelector = getSelector;\nexports.getSignature = getSignature;\nexports.getSignatureHash = getSignatureHash;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/cjs/exports/index.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hash = __webpack_require__(/*! ./Hash.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hash.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst internal = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/abiItem.js\");\nfunction format(abiItem) {\n    return abitype.formatAbiItem(abiItem);\n}\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = Hex.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === Hex.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return internal.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = internal.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\nfunction getSelector(abiItem) {\n    return Hex.slice(getSignatureHash(abiItem), 0, 4);\n}\nfunction getSignature(abiItem) {\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype.formatAbiItem(abiItem);\n    })();\n    return internal.normalizeSignature(signature);\n}\nfunction getSignatureHash(abiItem) {\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return Hash.keccak256(Hex.fromString(getSignature(abiItem)));\n}\nclass AmbiguityError extends Errors.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                `\\`${x.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${internal.normalizeSignature(abitype.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\nexports.AmbiguityError = AmbiguityError;\nclass NotFoundError extends Errors.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\nexports.NotFoundError = NotFoundError;\nclass InvalidSelectorSizeError extends Errors.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${Hex.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\nexports.InvalidSelectorSizeError = InvalidSelectorSizeError;\n//# sourceMappingURL=AbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BYmlJdGVtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdDQUFnQyxHQUFHLHFCQUFxQixHQUFHLHNCQUFzQjtBQUNqRixjQUFjO0FBQ2QsWUFBWTtBQUNaLGVBQWU7QUFDZixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQywyRUFBUztBQUNqQyxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLGdFQUFXO0FBQ2hDLFlBQVksbUJBQU8sQ0FBQyw4REFBVTtBQUM5QixpQkFBaUIsbUJBQU8sQ0FBQyx3RkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQixJQUFJO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDLFVBQVU7QUFDViw0Q0FBNEMsZUFBZTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0NBQXNDLElBQUk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQyxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0Esd0JBQXdCLGtDQUFrQyxJQUFJO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTyxVQUFVLDhEQUE4RDtBQUNwRyxxQkFBcUIsT0FBTyxVQUFVLDhEQUE4RDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxrQkFBa0IsNEJBQTRCO0FBQzlDO0FBQ0E7QUFDQSxzQ0FBc0MsS0FBSztBQUMzQztBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0EsU0FBUztBQUNULHFCQUFxQixLQUFLLEVBQUUsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QixzRUFBc0UsZ0JBQWdCLFVBQVUsS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXEFiaUl0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTZWxlY3RvclNpemVFcnJvciA9IGV4cG9ydHMuTm90Rm91bmRFcnJvciA9IGV4cG9ydHMuQW1iaWd1aXR5RXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmZvcm1hdCA9IGZvcm1hdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21BYmkgPSBmcm9tQWJpO1xuZXhwb3J0cy5nZXRTZWxlY3RvciA9IGdldFNlbGVjdG9yO1xuZXhwb3J0cy5nZXRTaWduYXR1cmUgPSBnZXRTaWduYXR1cmU7XG5leHBvcnRzLmdldFNpZ25hdHVyZUhhc2ggPSBnZXRTaWduYXR1cmVIYXNoO1xuY29uc3QgYWJpdHlwZSA9IHJlcXVpcmUoXCJhYml0eXBlXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vRXJyb3JzLmpzXCIpO1xuY29uc3QgSGFzaCA9IHJlcXVpcmUoXCIuL0hhc2guanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5jb25zdCBpbnRlcm5hbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2FiaUl0ZW0uanNcIik7XG5mdW5jdGlvbiBmb3JtYXQoYWJpSXRlbSkge1xuICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG59XG5mdW5jdGlvbiBmcm9tKGFiaUl0ZW0sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlcGFyZSA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgaXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFiaUl0ZW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlJdGVtKGFiaUl0ZW0pO1xuICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICB9KSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGl0ZW0pIH0gOiB7fSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhcmdzID0gW10sIHByZXBhcmUgPSB0cnVlIH0gPSAob3B0aW9ucyA/P1xuICAgICAgICB7fSk7XG4gICAgY29uc3QgaXNTZWxlY3RvciA9IEhleC52YWxpZGF0ZShuYW1lLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgYWJpSXRlbXMgPSBhYmkuZmlsdGVyKChhYmlJdGVtKSA9PiB7XG4gICAgICAgIGlmIChpc1NlbGVjdG9yKSB7XG4gICAgICAgICAgICBpZiAoYWJpSXRlbS50eXBlID09PSAnZnVuY3Rpb24nIHx8IGFiaUl0ZW0udHlwZSA9PT0gJ2Vycm9yJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2VsZWN0b3IoYWJpSXRlbSkgPT09IEhleC5zbGljZShuYW1lLCAwLCA0KTtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdldmVudCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgPT09IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICduYW1lJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgaWYgKGFiaUl0ZW1zLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmFiaUl0ZW1zWzBdLFxuICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbXNbMF0pIH0gOiB7fSksXG4gICAgICAgIH07XG4gICAgbGV0IG1hdGNoZWRBYmlJdGVtID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgYWJpSXRlbSBvZiBhYmlJdGVtcykge1xuICAgICAgICBpZiAoISgnaW5wdXRzJyBpbiBhYmlJdGVtKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIWFyZ3MgfHwgYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMgfHwgYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgIC4uLihwcmVwYXJlID8geyBoYXNoOiBnZXRTaWduYXR1cmVIYXNoKGFiaUl0ZW0pIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWJpSXRlbS5pbnB1dHMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGFiaUl0ZW0uaW5wdXRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoICE9PSBhcmdzLmxlbmd0aClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBtYXRjaGVkID0gYXJncy5ldmVyeSgoYXJnLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWJpUGFyYW1ldGVyID0gJ2lucHV0cycgaW4gYWJpSXRlbSAmJiBhYmlJdGVtLmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIWFiaVBhcmFtZXRlcilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJuYWwuaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSAmJlxuICAgICAgICAgICAgICAgICdpbnB1dHMnIGluIG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW1iaWd1b3VzVHlwZXMgPSBpbnRlcm5hbC5nZXRBbWJpZ3VvdXNUeXBlcyhhYmlJdGVtLmlucHV0cywgbWF0Y2hlZEFiaUl0ZW0uaW5wdXRzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoYW1iaWd1b3VzVHlwZXMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMF0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW06IG1hdGNoZWRBYmlJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYW1iaWd1b3VzVHlwZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hlZEFiaUl0ZW0gPSBhYmlJdGVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFiaUl0ZW0gPSAoKCkgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZEFiaUl0ZW0pXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZEFiaUl0ZW07XG4gICAgICAgIGNvbnN0IFthYmlJdGVtLCAuLi5vdmVybG9hZHNdID0gYWJpSXRlbXM7XG4gICAgICAgIHJldHVybiB7IC4uLmFiaUl0ZW0sIG92ZXJsb2FkcyB9O1xuICAgIH0pKCk7XG4gICAgaWYgKCFhYmlJdGVtKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRFcnJvcih7IG5hbWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U2VsZWN0b3IoYWJpSXRlbSkge1xuICAgIHJldHVybiBIZXguc2xpY2UoZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSwgMCwgNCk7XG59XG5mdW5jdGlvbiBnZXRTaWduYXR1cmUoYWJpSXRlbSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgYWJpSXRlbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYWJpSXRlbTtcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlJdGVtKTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbn1cbmZ1bmN0aW9uIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkge1xuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gJ3N0cmluZycgJiYgJ2hhc2gnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5oYXNoKVxuICAgICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcbn1cbmNsYXNzIEFtYmlndWl0eUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeCwgeSkge1xuICAgICAgICBzdXBlcignRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLicsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBcXGAke3gudHlwZX1cXGAgaW4gXFxgJHtpbnRlcm5hbC5ub3JtYWxpemVTaWduYXR1cmUoYWJpdHlwZS5mb3JtYXRBYmlJdGVtKHguYWJpSXRlbSkpfVxcYCwgYW5kYCxcbiAgICAgICAgICAgICAgICBgXFxgJHt5LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh5LmFiaUl0ZW0pKX1cXGBgLFxuICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICdUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuJyxcbiAgICAgICAgICAgICAgICAnUmVtb3ZlIG9uZSBvZiB0aGUgYW1iaWd1b3VzIGl0ZW1zIGluIHRoZSBBQkkuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5BbWJpZ3VpdHlFcnJvciA9IEFtYmlndWl0eUVycm9yO1xuY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSwgZGF0YSwgdHlwZSA9ICdpdGVtJywgfSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAobmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYCB3aXRoIG5hbWUgXCIke25hbWV9XCJgO1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBkYXRhIFwiJHtkYXRhfVwiYDtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSkoKTtcbiAgICAgICAgc3VwZXIoYEFCSSAke3R5cGV9JHtzZWxlY3Rvcn0gbm90IGZvdW5kLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5Ob3RGb3VuZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5vdEZvdW5kRXJyb3IgPSBOb3RGb3VuZEVycm9yO1xuY2xhc3MgSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBkYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoYFNlbGVjdG9yIHNpemUgaXMgaW52YWxpZC4gRXhwZWN0ZWQgNCBieXRlcy4gUmVjZWl2ZWQgJHtIZXguc2l6ZShkYXRhKX0gYnl0ZXMgKFwiJHtkYXRhfVwiKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRTZWxlY3RvclNpemVFcnJvciA9IEludmFsaWRTZWxlY3RvclNpemVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/AbiParameters.js":
/*!********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/AbiParameters.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidTypeError = exports.InvalidArrayError = exports.LengthMismatchError = exports.BytesSizeMismatchError = exports.ArrayLengthMismatchError = exports.ZeroDataError = exports.DataSizeTooSmallError = void 0;\nexports.decode = decode;\nexports.encode = encode;\nexports.encodePacked = encodePacked;\nexports.format = format;\nexports.from = from;\nconst abitype = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/cjs/exports/index.js\");\nconst Address = __webpack_require__(/*! ./Address.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Address.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst Solidity = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Solidity.js\");\nconst internal = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/abiParameters.js\");\nconst Cursor = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/cursor.js\");\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? Bytes.fromHex(data) : data;\n    const cursor = Cursor.create(bytes);\n    if (Bytes.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (Bytes.size(bytes) && Bytes.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : Hex.fromBytes(data),\n            parameters: parameters,\n            size: Bytes.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = internal.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    const preparedParameters = internal.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = internal.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return Hex.concat(...data);\n}\n(function (encodePacked) {\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            Address.assert(address);\n            return Hex.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return Hex.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return Hex.padLeft(Hex.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(Solidity.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits) / 8;\n            return Hex.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(Solidity.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size),\n                    value: value,\n                });\n            return Hex.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(Solidity.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return Hex.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (exports.encodePacked = encodePacked = {}));\nfunction format(parameters) {\n    return abitype.formatAbiParameters(parameters);\n}\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype.parseAbiParameters(parameters);\n    return parameters;\n}\nclass DataSizeTooSmallError extends Errors.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\nexports.DataSizeTooSmallError = DataSizeTooSmallError;\nclass ZeroDataError extends Errors.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\nexports.ZeroDataError = ZeroDataError;\nclass ArrayLengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\nexports.ArrayLengthMismatchError = ArrayLengthMismatchError;\nclass BytesSizeMismatchError extends Errors.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${Hex.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\nexports.BytesSizeMismatchError = BytesSizeMismatchError;\nclass LengthMismatchError extends Errors.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\nexports.LengthMismatchError = LengthMismatchError;\nclass InvalidArrayError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\nexports.InvalidArrayError = InvalidArrayError;\nclass InvalidTypeError extends Errors.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\nexports.InvalidTypeError = InvalidTypeError;\n//# sourceMappingURL=AbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLDhCQUE4QixHQUFHLGdDQUFnQyxHQUFHLHFCQUFxQixHQUFHLDZCQUE2QjtBQUM5TSxjQUFjO0FBQ2QsY0FBYztBQUNkLG9CQUFvQjtBQUNwQixjQUFjO0FBQ2QsWUFBWTtBQUNaLGdCQUFnQixtQkFBTyxDQUFDLDJFQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFjO0FBQ3RDLGNBQWMsbUJBQU8sQ0FBQyxrRUFBWTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDhEQUFVO0FBQzlCLGlCQUFpQixtQkFBTyxDQUFDLHdFQUFlO0FBQ3hDLGlCQUFpQixtQkFBTyxDQUFDLG9HQUE2QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsc0ZBQXNCO0FBQzdDLDhDQUE4QztBQUM5QyxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxtQkFBbUIsb0JBQW9CLG9CQUFvQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQyw4QkFBOEIsTUFBTTtBQUNwQztBQUNBLDRCQUE0Qix3Q0FBd0M7QUFDcEUsMkJBQTJCLE1BQU0sR0FBRyxNQUFNO0FBQzFDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrQkFBa0Isb0NBQW9DO0FBQ3RELGtEQUFrRCxLQUFLLGtCQUFrQixlQUFlLGVBQWUsWUFBWTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDLGdDQUFnQyxNQUFNLFVBQVUsZ0JBQWdCLHVDQUF1QyxhQUFhO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVELHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcQWJpUGFyYW1ldGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFR5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFycmF5RXJyb3IgPSBleHBvcnRzLkxlbmd0aE1pc21hdGNoRXJyb3IgPSBleHBvcnRzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IgPSBleHBvcnRzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvciA9IGV4cG9ydHMuWmVyb0RhdGFFcnJvciA9IGV4cG9ydHMuRGF0YVNpemVUb29TbWFsbEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGU7XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbmV4cG9ydHMuZW5jb2RlUGFja2VkID0gZW5jb2RlUGFja2VkO1xuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuY29uc3QgYWJpdHlwZSA9IHJlcXVpcmUoXCJhYml0eXBlXCIpO1xuY29uc3QgQWRkcmVzcyA9IHJlcXVpcmUoXCIuL0FkZHJlc3MuanNcIik7XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuL0J5dGVzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4vRXJyb3JzLmpzXCIpO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuY29uc3QgU29saWRpdHkgPSByZXF1aXJlKFwiLi9Tb2xpZGl0eS5qc1wiKTtcbmNvbnN0IGludGVybmFsID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYWJpUGFyYW1ldGVycy5qc1wiKTtcbmNvbnN0IEN1cnNvciA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2N1cnNvci5qc1wiKTtcbmZ1bmN0aW9uIGRlY29kZShwYXJhbWV0ZXJzLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0FycmF5JywgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBCeXRlcy5mcm9tSGV4KGRhdGEpIDogZGF0YTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKGJ5dGVzKTtcbiAgICBpZiAoQnl0ZXMuc2l6ZShieXRlcykgPT09IDAgJiYgcGFyYW1ldGVycy5sZW5ndGggPiAwKVxuICAgICAgICB0aHJvdyBuZXcgWmVyb0RhdGFFcnJvcigpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSAmJiBCeXRlcy5zaXplKGJ5dGVzKSA8IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRGF0YVNpemVUb29TbWFsbEVycm9yKHtcbiAgICAgICAgICAgIGRhdGE6IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IGRhdGEgOiBIZXguZnJvbUJ5dGVzKGRhdGEpLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICB9KTtcbiAgICBsZXQgY29uc3VtZWQgPSAwO1xuICAgIGNvbnN0IHZhbHVlcyA9IGFzID09PSAnQXJyYXknID8gW10gOiB7fTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oY29uc3VtZWQpO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGludGVybmFsLmRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgaWYgKGFzID09PSAnQXJyYXknKVxuICAgICAgICAgICAgdmFsdWVzLnB1c2goZGF0YSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlc1twYXJhbS5uYW1lID8/IGldID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGVuY29kZShwYXJhbWV0ZXJzLCB2YWx1ZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcyA9IGZhbHNlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGlmIChwYXJhbWV0ZXJzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHBhcmFtZXRlcnMubGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgIH0pO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IGludGVybmFsLnByZXBhcmVQYXJhbWV0ZXJzKHtcbiAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gaW50ZXJuYWwuZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIGVuY29kZVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHR5cGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBkYXRhLnB1c2goZW5jb2RlUGFja2VkLmVuY29kZSh0eXBlLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbn1cbihmdW5jdGlvbiAoZW5jb2RlUGFja2VkKSB7XG4gICAgZnVuY3Rpb24gZW5jb2RlKHR5cGUsIHZhbHVlLCBpc0FycmF5ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdhZGRyZXNzJykge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHZhbHVlO1xuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZExlZnQoYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdib29sJylcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpLCBpc0FycmF5ID8gMzIgOiAxKTtcbiAgICAgICAgY29uc3QgaW50TWF0Y2ggPSB0eXBlLm1hdGNoKFNvbGlkaXR5LmludGVnZXJSZWdleCk7XG4gICAgICAgIGlmIChpbnRNYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgW190eXBlLCBiYXNlVHlwZSwgYml0cyA9ICcyNTYnXSA9IGludE1hdGNoO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChiaXRzKSAvIDg7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmZyb21OdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBpc0FycmF5ID8gMzIgOiBzaXplLFxuICAgICAgICAgICAgICAgIHNpZ25lZDogYmFzZVR5cGUgPT09ICdpbnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXNNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYnl0ZXNSZWdleCk7XG4gICAgICAgIGlmIChieXRlc01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIHNpemVdID0gYnl0ZXNNYXRjaDtcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoc2l6ZSkgIT09ICh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZFNpemU6IE51bWJlci5wYXJzZUludChzaXplKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRSaWdodCh2YWx1ZSwgaXNBcnJheSA/IDMyIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJyYXlNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuYXJyYXlSZWdleCk7XG4gICAgICAgIGlmIChhcnJheU1hdGNoICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGNoaWxkVHlwZV0gPSBhcnJheU1hdGNoO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaChlbmNvZGUoY2hpbGRUeXBlLCB2YWx1ZVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAnMHgnO1xuICAgICAgICAgICAgcmV0dXJuIEhleC5jb25jYXQoLi4uZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUeXBlRXJyb3IodHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tlZC5lbmNvZGUgPSBlbmNvZGU7XG59KShlbmNvZGVQYWNrZWQgfHwgKGV4cG9ydHMuZW5jb2RlUGFja2VkID0gZW5jb2RlUGFja2VkID0ge30pKTtcbmZ1bmN0aW9uIGZvcm1hdChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbn1cbmZ1bmN0aW9uIGZyb20ocGFyYW1ldGVycykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtZXRlcnMpICYmIHR5cGVvZiBwYXJhbWV0ZXJzWzBdID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGFiaXR5cGUucGFyc2VBYmlQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIGlmICh0eXBlb2YgcGFyYW1ldGVycyA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICByZXR1cm4gcGFyYW1ldGVycztcbn1cbmNsYXNzIERhdGFTaXplVG9vU21hbGxFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZGF0YSwgcGFyYW1ldGVycywgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgRGF0YSBzaXplIG9mICR7c2l6ZX0gYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBQYXJhbXM6ICgke2FiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKX0pYCxcbiAgICAgICAgICAgICAgICBgRGF0YTogICAke2RhdGF9ICgke3NpemV9IGJ5dGVzKWAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkRhdGFTaXplVG9vU21hbGxFcnJvciA9IERhdGFTaXplVG9vU21hbGxFcnJvcjtcbmNsYXNzIFplcm9EYXRhRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0Nhbm5vdCBkZWNvZGUgemVybyBkYXRhIChcIjB4XCIpIHdpdGggQUJJIHBhcmFtZXRlcnMuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLlplcm9EYXRhRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuWmVyb0RhdGFFcnJvciA9IFplcm9EYXRhRXJyb3I7XG5jbGFzcyBBcnJheUxlbmd0aE1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkTGVuZ3RoLCBnaXZlbkxlbmd0aCwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgQXJyYXkgbGVuZ3RoIG1pc21hdGNoIGZvciB0eXBlIFxcYCR7dHlwZX1cXGAuIEV4cGVjdGVkOiBcXGAke2V4cGVjdGVkTGVuZ3RofVxcYC4gR2l2ZW46IFxcYCR7Z2l2ZW5MZW5ndGh9XFxgLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5BcnJheUxlbmd0aE1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yID0gQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yO1xuY2xhc3MgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRTaXplLCB2YWx1ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBvZiBieXRlcyBcIiR7dmFsdWV9XCIgKGJ5dGVzJHtIZXguc2l6ZSh2YWx1ZSl9KSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlcyR7ZXhwZWN0ZWRTaXplfSkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQnl0ZXNTaXplTWlzbWF0Y2hFcnJvciA9IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3I7XG5jbGFzcyBMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIH0pIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgJ0FCSSBlbmNvZGluZyBwYXJhbWV0ZXJzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2guJyxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBsZW5ndGggKHBhcmFtZXRlcnMpOiAke2V4cGVjdGVkTGVuZ3RofWAsXG4gICAgICAgICAgICBgR2l2ZW4gbGVuZ3RoICh2YWx1ZXMpOiAke2dpdmVuTGVuZ3RofWAsXG4gICAgICAgIF0uam9pbignXFxuJykpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5MZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkxlbmd0aE1pc21hdGNoRXJyb3IgPSBMZW5ndGhNaXNtYXRjaEVycm9yO1xuY2xhc3MgSW52YWxpZEFycmF5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRBcnJheUVycm9yID0gSW52YWxpZEFycmF5RXJyb3I7XG5jbGFzcyBJbnZhbGlkVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodHlwZSkge1xuICAgICAgICBzdXBlcihgVHlwZSBcXGAke3R5cGV9XFxgIGlzIG5vdCBhIHZhbGlkIEFCSSBUeXBlLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRUeXBlRXJyb3IgPSBJbnZhbGlkVHlwZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJpUGFyYW1ldGVycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Address.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Address.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidChecksumError = exports.InvalidInputError = exports.InvalidAddressError = void 0;\nexports.assert = assert;\nexports.checksum = checksum;\nexports.from = from;\nexports.fromPublicKey = fromPublicKey;\nexports.isEqual = isEqual;\nexports.validate = validate;\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Caches = __webpack_require__(/*! ./Caches.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Caches.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hash = __webpack_require__(/*! ./Hash.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hash.js\");\nconst PublicKey = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/../../node_modules/ox/_cjs/core/PublicKey.js\");\nconst addressRegex = /^0x[a-fA-F0-9]{40}$/;\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\nfunction checksum(address) {\n    if (Caches.checksum.has(address))\n        return Caches.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = Hash.keccak256(Bytes.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    Caches.checksum.set(address, result);\n    return result;\n}\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = Hash.keccak256(`0x${PublicKey.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nclass InvalidAddressError extends Errors.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\nexports.InvalidAddressError = InvalidAddressError;\nclass InvalidInputError extends Errors.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\nexports.InvalidInputError = InvalidInputError;\nclass InvalidChecksumError extends Errors.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\nexports.InvalidChecksumError = InvalidChecksumError;\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9BZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQjtBQUN0RixjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLFlBQVk7QUFDWixxQkFBcUI7QUFDckIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixjQUFjLG1CQUFPLENBQUMsa0VBQVk7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQyxhQUFhLG1CQUFPLENBQUMsZ0VBQVc7QUFDaEMsa0JBQWtCLG1CQUFPLENBQUMsMEVBQWdCO0FBQzFDLHFDQUFxQyxHQUFHO0FBQ3hDLG1DQUFtQztBQUNuQyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxnRUFBZ0UsYUFBYTtBQUM3RTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyx3Q0FBd0Msb0NBQW9DO0FBQzVFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSx1QkFBdUIsZUFBZTtBQUN0Qyx1QkFBdUIsZUFBZTtBQUN0QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxBZGRyZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkQ2hlY2tzdW1FcnJvciA9IGV4cG9ydHMuSW52YWxpZElucHV0RXJyb3IgPSBleHBvcnRzLkludmFsaWRBZGRyZXNzRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuY2hlY2tzdW0gPSBjaGVja3N1bTtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21QdWJsaWNLZXkgPSBmcm9tUHVibGljS2V5O1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBDYWNoZXMgPSByZXF1aXJlKFwiLi9DYWNoZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBIYXNoID0gcmVxdWlyZShcIi4vSGFzaC5qc1wiKTtcbmNvbnN0IFB1YmxpY0tleSA9IHJlcXVpcmUoXCIuL1B1YmxpY0tleS5qc1wiKTtcbmNvbnN0IGFkZHJlc3NSZWdleCA9IC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrc3VtKGFkZHJlc3MpIHtcbiAgICBpZiAoQ2FjaGVzLmNoZWNrc3VtLmhhcyhhZGRyZXNzKSlcbiAgICAgICAgcmV0dXJuIENhY2hlcy5jaGVja3N1bS5nZXQoYWRkcmVzcyk7XG4gICAgYXNzZXJ0KGFkZHJlc3MsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBjb25zdCBoZXhBZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBoYXNoID0gSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhoZXhBZGRyZXNzKSwgeyBhczogJ0J5dGVzJyB9KTtcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gaGV4QWRkcmVzcy5zcGxpdCgnJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0MDsgaSArPSAyKSB7XG4gICAgICAgIGlmIChoYXNoW2kgPj4gMV0gPj4gNCA+PSA4ICYmIGNoYXJhY3RlcnNbaV0pIHtcbiAgICAgICAgICAgIGNoYXJhY3RlcnNbaV0gPSBjaGFyYWN0ZXJzW2ldLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoYXNoW2kgPj4gMV0gJiAweDBmKSA+PSA4ICYmIGNoYXJhY3RlcnNbaSArIDFdKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2kgKyAxXSA9IGNoYXJhY3RlcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gYDB4JHtjaGFyYWN0ZXJzLmpvaW4oJycpfWA7XG4gICAgQ2FjaGVzLmNoZWNrc3VtLnNldChhZGRyZXNzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmcm9tKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY2hlY2tzdW06IGNoZWNrc3VtVmFsID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgYXNzZXJ0KGFkZHJlc3MpO1xuICAgIGlmIChjaGVja3N1bVZhbClcbiAgICAgICAgcmV0dXJuIGNoZWNrc3VtKGFkZHJlc3MpO1xuICAgIHJldHVybiBhZGRyZXNzO1xufVxuZnVuY3Rpb24gZnJvbVB1YmxpY0tleShwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBIYXNoLmtlY2NhazI1NihgMHgke1B1YmxpY0tleS50b0hleChwdWJsaWNLZXkpLnNsaWNlKDQpfWApLnN1YnN0cmluZygyNik7XG4gICAgcmV0dXJuIGZyb20oYDB4JHthZGRyZXNzfWAsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaXNFcXVhbChhZGRyZXNzQSwgYWRkcmVzc0IpIHtcbiAgICBhc3NlcnQoYWRkcmVzc0EsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBhc3NlcnQoYWRkcmVzc0IsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICByZXR1cm4gYWRkcmVzc0EudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzc0IudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKGFkZHJlc3MsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoYWRkcmVzcywgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzLCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCwge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRBZGRyZXNzRXJyb3IgPSBJbnZhbGlkQWRkcmVzc0Vycm9yO1xuY2xhc3MgSW52YWxpZElucHV0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgaXMgbm90IGEgMjAgYnl0ZSAoNDAgaGV4YWRlY2ltYWwgY2hhcmFjdGVyKSB2YWx1ZS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZElucHV0RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZElucHV0RXJyb3IgPSBJbnZhbGlkSW5wdXRFcnJvcjtcbmNsYXNzIEludmFsaWRDaGVja3N1bUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGRvZXMgbm90IG1hdGNoIGl0cyBjaGVja3N1bSBjb3VudGVycGFydC4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FkZHJlc3MuSW52YWxpZENoZWNrc3VtRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENoZWNrc3VtRXJyb3IgPSBJbnZhbGlkQ2hlY2tzdW1FcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZHJlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Address.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/BlockOverrides.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/BlockOverrides.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst Withdrawal = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Withdrawal.js\");\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(Withdrawal.fromRpc),\n        }),\n    };\n}\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: Hex.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: Hex.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: Hex.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: Hex.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: Hex.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: Hex.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(Withdrawal.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9CbG9ja092ZXJyaWRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsYUFBYTtBQUNiLFlBQVksbUJBQU8sQ0FBQyw4REFBVTtBQUM5QixtQkFBbUIsbUJBQU8sQ0FBQyw0RUFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXEJsb2NrT3ZlcnJpZGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mcm9tUnBjID0gZnJvbVJwYztcbmV4cG9ydHMudG9ScGMgPSB0b1JwYztcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IFdpdGhkcmF3YWwgPSByZXF1aXJlKFwiLi9XaXRoZHJhd2FsLmpzXCIpO1xuZnVuY3Rpb24gZnJvbVJwYyhycGNCbG9ja092ZXJyaWRlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5iYXNlRmVlUGVyR2FzKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSAmJiB7XG4gICAgICAgICAgICBibG9iQmFzZUZlZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLihycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQgJiYge1xuICAgICAgICAgICAgZmVlUmVjaXBpZW50OiBycGNCbG9ja092ZXJyaWRlcy5mZWVSZWNpcGllbnQsXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgJiYge1xuICAgICAgICAgICAgZ2FzTGltaXQ6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMubnVtYmVyICYmIHtcbiAgICAgICAgICAgIG51bWJlcjogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMucHJldlJhbmRhbyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMudGltZSAmJiB7XG4gICAgICAgICAgICB0aW1lOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLmZyb21ScGMpLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9ScGMoYmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSAnc3RyaW5nJyAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLm51bWJlciA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgdGltZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Bytes.js":
/*!************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Bytes.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidBytesTypeError = exports.InvalidBytesBooleanError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromArray = fromArray;\nexports.fromBoolean = fromBoolean;\nexports.fromHex = fromHex;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.size = size;\nexports.slice = slice;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toHex = toHex;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Json.js\");\nconst internal = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal_hex = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/hex.js\");\nconst decoder = new TextDecoder();\nconst encoder = new TextEncoder();\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        internal_hex.assertSize(value, size);\n        hex = Hex.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = internal.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new Errors.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\nfunction fromNumber(value, options) {\n    const hex = Hex.fromNumber(value, options);\n    return fromHex(hex);\n}\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        internal.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\nfunction isEqual(bytesA, bytesB) {\n    return (0, utils_1.equalBytes)(bytesA, bytesB);\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\nfunction size(value) {\n    return value.length;\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toBigInt(hex, options);\n}\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\nfunction toHex(value, options = {}) {\n    return Hex.fromBytes(value, options);\n}\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        internal.assertSize(bytes, size);\n    const hex = Hex.fromBytes(bytes, options);\n    return Hex.toNumber(hex, options);\n}\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        internal.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\nfunction trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nclass InvalidBytesBooleanError extends Errors.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\nexports.InvalidBytesBooleanError = InvalidBytesBooleanError;\nclass InvalidBytesTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\nexports.InvalidBytesTypeError = InvalidBytesTypeError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9CeXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQ0FBbUMsR0FBRyxtQ0FBbUMsR0FBRyx5QkFBeUIsR0FBRyw2QkFBNkIsR0FBRyxnQ0FBZ0M7QUFDeEssY0FBYztBQUNkLGNBQWM7QUFDZCxZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsWUFBWTtBQUNaLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGdCQUFnQixtQkFBTyxDQUFDLDhHQUE4QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsb0VBQWE7QUFDcEMsWUFBWSxtQkFBTyxDQUFDLDhEQUFVO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxnRUFBVztBQUNoQyxpQkFBaUIsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDOUMscUJBQXFCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQSwrQkFBK0IsZ0JBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxpQkFBaUIsRUFBRSxpQkFBaUIsUUFBUSxVQUFVO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtQkFBbUI7QUFDcEQ7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EseUJBQXlCLDBEQUEwRCxlQUFlLGFBQWE7QUFDL0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsUUFBUSwwQkFBMEIsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDLHVCQUF1Qiw4Q0FBOEMsY0FBYyxPQUFPLCtCQUErQixLQUFLO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXEJ5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBleHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IGV4cG9ydHMuU2l6ZU92ZXJmbG93RXJyb3IgPSBleHBvcnRzLkludmFsaWRCeXRlc1R5cGVFcnJvciA9IGV4cG9ydHMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21BcnJheSA9IGZyb21BcnJheTtcbmV4cG9ydHMuZnJvbUJvb2xlYW4gPSBmcm9tQm9vbGVhbjtcbmV4cG9ydHMuZnJvbUhleCA9IGZyb21IZXg7XG5leHBvcnRzLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuZXhwb3J0cy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbmV4cG9ydHMuaXNFcXVhbCA9IGlzRXF1YWw7XG5leHBvcnRzLnBhZExlZnQgPSBwYWRMZWZ0O1xuZXhwb3J0cy5wYWRSaWdodCA9IHBhZFJpZ2h0O1xuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG5leHBvcnRzLnNpemUgPSBzaXplO1xuZXhwb3J0cy5zbGljZSA9IHNsaWNlO1xuZXhwb3J0cy50b0JpZ0ludCA9IHRvQmlnSW50O1xuZXhwb3J0cy50b0Jvb2xlYW4gPSB0b0Jvb2xlYW47XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLnRvTnVtYmVyID0gdG9OdW1iZXI7XG5leHBvcnRzLnRvU3RyaW5nID0gdG9TdHJpbmc7XG5leHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5leHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoXCIuL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmNvbnN0IEpzb24gPSByZXF1aXJlKFwiLi9Kc29uLmpzXCIpO1xuY29uc3QgaW50ZXJuYWwgPSByZXF1aXJlKFwiLi9pbnRlcm5hbC9ieXRlcy5qc1wiKTtcbmNvbnN0IGludGVybmFsX2hleCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hleC5qc1wiKTtcbmNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKCEoJ0JZVEVTX1BFUl9FTEVNRU5UJyBpbiB2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh2YWx1ZS5CWVRFU19QRVJfRUxFTUVOVCAhPT0gMSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lICE9PSAnVWludDhBcnJheScpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBmcm9tSGV4KHZhbHVlKTtcbiAgICByZXR1cm4gZnJvbUFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21BcnJheSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyB2YWx1ZSA6IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBmcm9tSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGhleCA9IHZhbHVlO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2hleC5hc3NlcnRTaXplKHZhbHVlLCBzaXplKTtcbiAgICAgICAgaGV4ID0gSGV4LnBhZFJpZ2h0KHZhbHVlLCBzaXplKTtcbiAgICB9XG4gICAgbGV0IGhleFN0cmluZyA9IGhleC5zbGljZSgyKTtcbiAgICBpZiAoaGV4U3RyaW5nLmxlbmd0aCAlIDIpXG4gICAgICAgIGhleFN0cmluZyA9IGAwJHtoZXhTdHJpbmd9YDtcbiAgICBjb25zdCBsZW5ndGggPSBoZXhTdHJpbmcubGVuZ3RoIC8gMjtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBqID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgY29uc3QgbmliYmxlTGVmdCA9IGludGVybmFsLmNoYXJDb2RlVG9CYXNlMTYoaGV4U3RyaW5nLmNoYXJDb2RlQXQoaisrKSk7XG4gICAgICAgIGNvbnN0IG5pYmJsZVJpZ2h0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgaWYgKG5pYmJsZUxlZnQgPT09IHVuZGVmaW5lZCB8fCBuaWJibGVSaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBieXRlIHNlcXVlbmNlIChcIiR7aGV4U3RyaW5nW2ogLSAyXX0ke2hleFN0cmluZ1tqIC0gMV19XCIgaW4gXCIke2hleFN0cmluZ31cIikuYCk7XG4gICAgICAgIH1cbiAgICAgICAgYnl0ZXNbaW5kZXhdID0gbmliYmxlTGVmdCAqIDE2ICsgbmliYmxlUmlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbU51bWJlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZyb21IZXgoaGV4KTtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBpc0VxdWFsKGJ5dGVzQSwgYnl0ZXNCKSB7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKGJ5dGVzQSwgYnl0ZXNCKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubGVuZ3RoO1xufVxuZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gdmFsdWUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbmZ1bmN0aW9uIHRvQmlnSW50KGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b0JpZ0ludChoZXgsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG9Cb29sZWFuKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltTGVmdChieXRlc18pO1xuICAgIH1cbiAgICBpZiAoYnl0ZXNfLmxlbmd0aCA+IDEgfHwgYnl0ZXNfWzBdID4gMSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcihieXRlc18pO1xuICAgIHJldHVybiBCb29sZWFuKGJ5dGVzX1swXSk7XG59XG5mdW5jdGlvbiB0b0hleCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXModmFsdWUsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICBjb25zdCBoZXggPSBIZXguZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gSGV4LnRvTnVtYmVyKGhleCwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB0b1N0cmluZyhieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGxldCBieXRlc18gPSBieXRlcztcbiAgICBpZiAodHlwZW9mIHNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXNfLCBzaXplKTtcbiAgICAgICAgYnl0ZXNfID0gdHJpbVJpZ2h0KGJ5dGVzXyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShieXRlc18pO1xufVxuZnVuY3Rpb24gdHJpbUxlZnQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdsZWZ0JyB9KTtcbn1cbmZ1bmN0aW9uIHRyaW1SaWdodCh2YWx1ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC50cmltKHZhbHVlLCB7IGRpcjogJ3JpZ2h0JyB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yID0gSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yO1xuY2xhc3MgSW52YWxpZEJ5dGVzVHlwZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IEpzb24uc3RyaW5naWZ5KHZhbHVlKSA6IHZhbHVlfVxcYCBvZiB0eXBlIFxcYCR7dHlwZW9mIHZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydCeXRlcyB2YWx1ZXMgbXVzdCBiZSBvZiB0eXBlIGBCeXRlc2AuJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZXMuSW52YWxpZEJ5dGVzVHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRCeXRlc1R5cGVFcnJvciA9IEludmFsaWRCeXRlc1R5cGVFcnJvcjtcbmNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gU2l6ZU92ZXJmbG93RXJyb3I7XG5jbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yID0gU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yO1xuY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yID0gU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Caches.js":
/*!*************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Caches.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.checksum = void 0;\nexports.clear = clear;\nconst lru_js_1 = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/lru.js\");\nconst caches = {\n    checksum: new lru_js_1.LruMap(8192),\n};\nexports.checksum = caches.checksum;\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9DYWNoZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYixpQkFBaUIsbUJBQU8sQ0FBQyxnRkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXENhY2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hlY2tzdW0gPSB2b2lkIDA7XG5leHBvcnRzLmNsZWFyID0gY2xlYXI7XG5jb25zdCBscnVfanNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2xydS5qc1wiKTtcbmNvbnN0IGNhY2hlcyA9IHtcbiAgICBjaGVja3N1bTogbmV3IGxydV9qc18xLkxydU1hcCg4MTkyKSxcbn07XG5leHBvcnRzLmNoZWNrc3VtID0gY2FjaGVzLmNoZWNrc3VtO1xuZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlcykpXG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Errors.js":
/*!*************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Errors.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/errors.js\");\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0, errors_js_1.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\nexports.BaseError = BaseError;\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9FcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG9CQUFvQixtQkFBTyxDQUFDLHNGQUFzQjtBQUNsRDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QjtBQUN2RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcRXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2Vycm9ycy5qc1wiKTtcbmNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UuZGV0YWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgJ2RldGFpbHMnIGluIG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jYXVzZS5kZXRhaWxzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRldGFpbHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NQYXRoID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRvY3NQYXRoIHx8IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc0Jhc2VVcmwgPSAnaHR0cHM6Ly9veGxpYi5zaCc7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBgJHtkb2NzQmFzZVVybH0ke2RvY3NQYXRoID8/ICcnfWA7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zLmNhdXNlID8geyBjYXVzZTogb3B0aW9ucy5jYXVzZSB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQmFzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYG94QCR7KDAsIGVycm9yc19qc18xLmdldFZlcnNpb24pKCl9YFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuZG9jcyA9IGRvY3M7XG4gICAgICAgIHRoaXMuZG9jc1BhdGggPSBkb2NzUGF0aDtcbiAgICAgICAgdGhpcy5zaG9ydE1lc3NhZ2UgPSBzaG9ydE1lc3NhZ2U7XG4gICAgfVxuICAgIHdhbGsoZm4pIHtcbiAgICAgICAgcmV0dXJuIHdhbGsodGhpcywgZm4pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUVycm9yID0gQmFzZUVycm9yO1xuZnVuY3Rpb24gd2FsayhlcnIsIGZuKSB7XG4gICAgaWYgKGZuPy4oZXJyKSlcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICBpZiAoZXJyICYmIHR5cGVvZiBlcnIgPT09ICdvYmplY3QnICYmICdjYXVzZScgaW4gZXJyICYmIGVyci5jYXVzZSlcbiAgICAgICAgcmV0dXJuIHdhbGsoZXJyLmNhdXNlLCBmbik7XG4gICAgcmV0dXJuIGZuID8gbnVsbCA6IGVycjtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Hash.js":
/*!***********************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Hash.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.keccak256 = keccak256;\nexports.ripemd160 = ripemd160;\nexports.sha256 = sha256;\nexports.validate = validate;\nconst ripemd160_1 = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/ripemd160.js\");\nconst sha3_1 = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha3.js\");\nconst sha256_1 = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha256.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0, sha3_1.keccak_256)(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0, ripemd160_1.ripemd160)(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0, sha256_1.sha256)(Bytes.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return Hex.fromBytes(bytes);\n}\nfunction validate(value) {\n    return Hex.validate(value) && Hex.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9IYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixvQkFBb0IsbUJBQU8sQ0FBQyxvR0FBeUI7QUFDckQsZUFBZSxtQkFBTyxDQUFDLDBGQUFvQjtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyw4RkFBc0I7QUFDL0MsY0FBYyxtQkFBTyxDQUFDLGtFQUFZO0FBQ2xDLFlBQVksbUJBQU8sQ0FBQyw4REFBVTtBQUM5QixzQ0FBc0M7QUFDdEMsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxZQUFZLG1EQUFtRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFlBQVksbURBQW1EO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcSGFzaC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuZXhwb3J0cy5yaXBlbWQxNjAgPSByaXBlbWQxNjA7XG5leHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHJpcGVtZDE2MF8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvcmlwZW1kMTYwXCIpO1xuY29uc3Qgc2hhM18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhM1wiKTtcbmNvbnN0IHNoYTI1Nl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvc2hhMjU2XCIpO1xuY29uc3QgQnl0ZXMgPSByZXF1aXJlKFwiLi9CeXRlcy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuL0hleC5qc1wiKTtcbmZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgc2hhM18xLmtlY2Nha18yNTYpKEJ5dGVzLmZyb20odmFsdWUpKTtcbiAgICBpZiAoYXMgPT09ICdCeXRlcycpXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhieXRlcyk7XG59XG5mdW5jdGlvbiByaXBlbWQxNjAodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gJ0hleCcgOiAnQnl0ZXMnIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGJ5dGVzID0gKDAsIHJpcGVtZDE2MF8xLnJpcGVtZDE2MCkoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIHNoYTI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSAoMCwgc2hhMjU2XzEuc2hhMjU2KShCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Hex.js":
/*!**********************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Hex.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SizeExceedsPaddingSizeError = exports.SliceOffsetOutOfBoundsError = exports.SizeOverflowError = exports.InvalidLengthError = exports.InvalidHexValueError = exports.InvalidHexTypeError = exports.InvalidHexBooleanError = exports.IntegerOutOfRangeError = void 0;\nexports.assert = assert;\nexports.concat = concat;\nexports.from = from;\nexports.fromBoolean = fromBoolean;\nexports.fromBytes = fromBytes;\nexports.fromNumber = fromNumber;\nexports.fromString = fromString;\nexports.isEqual = isEqual;\nexports.padLeft = padLeft;\nexports.padRight = padRight;\nexports.random = random;\nexports.slice = slice;\nexports.size = size;\nexports.trimLeft = trimLeft;\nexports.trimRight = trimRight;\nexports.toBigInt = toBigInt;\nexports.toBoolean = toBoolean;\nexports.toBytes = toBytes;\nexports.toNumber = toNumber;\nexports.toString = toString;\nexports.validate = validate;\nconst utils_1 = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/ox/node_modules/@noble/curves/abstract/utils.js\");\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Json.js\");\nconst internal_bytes = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/bytes.js\");\nconst internal = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/internal/hex.js\");\nconst encoder = new TextEncoder();\nconst hexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        internal.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\nfunction isEqual(hexA, hexB) {\n    return (0, utils_1.equalBytes)(Bytes.fromHex(hexA), Bytes.fromHex(hexB));\n}\nfunction padLeft(value, size) {\n    return internal.pad(value, { dir: 'left', size });\n}\nfunction padRight(value, size) {\n    return internal.pad(value, { dir: 'right', size });\n}\nfunction random(length) {\n    return fromBytes(Bytes.random(length));\n}\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    internal.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        internal.assertEndOffset(value_, start, end);\n    return value_;\n}\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\nfunction trimLeft(value) {\n    return internal.trim(value, { dir: 'left' });\n}\nfunction trimRight(value) {\n    return internal.trim(value, { dir: 'right' });\n}\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        internal.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\nfunction toBytes(hex, options = {}) {\n    return Bytes.fromHex(hex, options);\n}\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = Bytes.fromHex(hex);\n    if (size) {\n        internal_bytes.assertSize(bytes, size);\n        bytes = Bytes.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\nclass IntegerOutOfRangeError extends Errors.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\nexports.IntegerOutOfRangeError = IntegerOutOfRangeError;\nclass InvalidHexBooleanError extends Errors.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\nexports.InvalidHexBooleanError = InvalidHexBooleanError;\nclass InvalidHexTypeError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? Json.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\nexports.InvalidHexTypeError = InvalidHexTypeError;\nclass InvalidHexValueError extends Errors.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\nexports.InvalidHexValueError = InvalidHexValueError;\nclass InvalidLengthError extends Errors.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\nexports.InvalidLengthError = InvalidLengthError;\nclass SizeOverflowError extends Errors.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\nexports.SizeOverflowError = SizeOverflowError;\nclass SliceOffsetOutOfBoundsError extends Errors.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\nexports.SliceOffsetOutOfBoundsError = SliceOffsetOutOfBoundsError;\nclass SizeExceedsPaddingSizeError extends Errors.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\nexports.SizeExceedsPaddingSizeError = SizeExceedsPaddingSizeError;\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9IZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsbUNBQW1DLEdBQUcseUJBQXlCLEdBQUcsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUcsMkJBQTJCLEdBQUcsOEJBQThCLEdBQUcsOEJBQThCO0FBQ2pRLGNBQWM7QUFDZCxjQUFjO0FBQ2QsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsYUFBYTtBQUNiLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQixtQkFBTyxDQUFDLDhHQUE4QjtBQUN0RCxjQUFjLG1CQUFPLENBQUMsa0VBQVk7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLG9FQUFhO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyxnRUFBVztBQUNoQyx1QkFBdUIsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDcEQsaUJBQWlCLG1CQUFPLENBQUMsZ0ZBQW1CO0FBQzVDO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEMsbUNBQW1DO0FBQ25DLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsU0FBUyxFQUFFLE9BQU87QUFDakQsb0JBQW9CLFNBQVMsRUFBRSxPQUFPO0FBQ3RDO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTSxFQUFFLE9BQU87QUFDckMsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLFlBQVksU0FBUztBQUNyQjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBLGtDQUFrQyxjQUFjO0FBQ2hEO0FBQ0EsbUNBQW1DO0FBQ25DLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFnQztBQUNsRCwwQkFBMEIsTUFBTSxtQkFBbUIsV0FBVyxTQUFTLFdBQVcsRUFBRSxrQ0FBa0MsZ0JBQWdCLFlBQVksSUFBSSxVQUFVLElBQUksbUJBQW1CLElBQUksS0FBSztBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QixJQUFJO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLHlCQUF5QiwwREFBMEQsZUFBZSxhQUFhO0FBQy9HLG1FQUFtRSxPQUFPO0FBQzFFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLDhCQUE4QixNQUFNLHdCQUF3QixrQkFBa0I7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsUUFBUSwwQkFBMEIsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDLHVCQUF1Qiw4Q0FBOEMsY0FBYyxPQUFPLCtCQUErQixLQUFLO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLGtCQUFrQix5QkFBeUI7QUFDM0MsaUJBQWlCLDZCQUE2QixFQUFFO0FBQ2hEO0FBQ0EsNEJBQTRCLFVBQVUsS0FBSyw4QkFBOEIsV0FBVztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXEhleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yID0gZXhwb3J0cy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgPSBleHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gZXhwb3J0cy5JbnZhbGlkTGVuZ3RoRXJyb3IgPSBleHBvcnRzLkludmFsaWRIZXhWYWx1ZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkSGV4VHlwZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yID0gZXhwb3J0cy5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbmNhdCA9IGNvbmNhdDtcbmV4cG9ydHMuZnJvbSA9IGZyb207XG5leHBvcnRzLmZyb21Cb29sZWFuID0gZnJvbUJvb2xlYW47XG5leHBvcnRzLmZyb21CeXRlcyA9IGZyb21CeXRlcztcbmV4cG9ydHMuZnJvbU51bWJlciA9IGZyb21OdW1iZXI7XG5leHBvcnRzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuZXhwb3J0cy5pc0VxdWFsID0gaXNFcXVhbDtcbmV4cG9ydHMucGFkTGVmdCA9IHBhZExlZnQ7XG5leHBvcnRzLnBhZFJpZ2h0ID0gcGFkUmlnaHQ7XG5leHBvcnRzLnJhbmRvbSA9IHJhbmRvbTtcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMuc2l6ZSA9IHNpemU7XG5leHBvcnRzLnRyaW1MZWZ0ID0gdHJpbUxlZnQ7XG5leHBvcnRzLnRyaW1SaWdodCA9IHRyaW1SaWdodDtcbmV4cG9ydHMudG9CaWdJbnQgPSB0b0JpZ0ludDtcbmV4cG9ydHMudG9Cb29sZWFuID0gdG9Cb29sZWFuO1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMudG9OdW1iZXIgPSB0b051bWJlcjtcbmV4cG9ydHMudG9TdHJpbmcgPSB0b1N0cmluZztcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlsc1wiKTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBKc29uID0gcmVxdWlyZShcIi4vSnNvbi5qc1wiKTtcbmNvbnN0IGludGVybmFsX2J5dGVzID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvYnl0ZXMuanNcIik7XG5jb25zdCBpbnRlcm5hbCA9IHJlcXVpcmUoXCIuL2ludGVybmFsL2hleC5qc1wiKTtcbmNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfdiwgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF2YWx1ZSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFR5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAoIS9eMHhbMC05YS1mQS1GXSokLy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghdmFsdWUuc3RhcnRzV2l0aCgnMHgnKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhWYWx1ZUVycm9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXModmFsdWUpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIGZyb21CeXRlcyhuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHN0cmluZyA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgIHN0cmluZyArPSBoZXhlc1t2YWx1ZVtpXV07XG4gICAgY29uc3QgaGV4ID0gYDB4JHtzdHJpbmd9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRSaWdodChoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlXykgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBmcm9tQnl0ZXMoZW5jb2Rlci5lbmNvZGUodmFsdWUpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiAoMCwgdXRpbHNfMS5lcXVhbEJ5dGVzKShCeXRlcy5mcm9tSGV4KGhleEEpLCBCeXRlcy5mcm9tSGV4KGhleEIpKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ2xlZnQnLCBzaXplIH0pO1xufVxuZnVuY3Rpb24gcGFkUmlnaHQodmFsdWUsIHNpemUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwucGFkKHZhbHVlLCB7IGRpcjogJ3JpZ2h0Jywgc2l6ZSB9KTtcbn1cbmZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbmZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IGAweCR7dmFsdWVcbiAgICAgICAgLnJlcGxhY2UoJzB4JywgJycpXG4gICAgICAgIC5zbGljZSgoc3RhcnQgPz8gMCkgKiAyLCAoZW5kID8/IHZhbHVlLmxlbmd0aCkgKiAyKX1gO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG5mdW5jdGlvbiBzaXplKHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyKTtcbn1cbmZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG5mdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG5mdW5jdGlvbiB0b0JpZ0ludChoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmVkIH0gPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zLnNpemUpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoaGV4LCBvcHRpb25zLnNpemUpO1xuICAgIGNvbnN0IHZhbHVlID0gQmlnSW50KGhleCk7XG4gICAgaWYgKCFzaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBjb25zdCBzaXplID0gKGhleC5sZW5ndGggLSAyKSAvIDI7XG4gICAgY29uc3QgbWF4X3Vuc2lnbmVkID0gKDFuIDw8IChCaWdJbnQoc2l6ZSkgKiA4bikpIC0gMW47XG4gICAgY29uc3QgbWF4X3NpZ25lZCA9IG1heF91bnNpZ25lZCA+PiAxbjtcbiAgICBpZiAodmFsdWUgPD0gbWF4X3NpZ25lZClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZSAtIG1heF91bnNpZ25lZCAtIDFuO1xufVxuZnVuY3Rpb24gdG9Cb29sZWFuKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKG9wdGlvbnMuc2l6ZSlcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgY29uc3QgaGV4XyA9IHRyaW1MZWZ0KGhleCk7XG4gICAgaWYgKGhleF8gPT09ICcweCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4MScpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHRocm93IG5ldyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yKGhleCk7XG59XG5mdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHRvTnVtYmVyKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduZWQsIHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFzaWduZWQgJiYgIXNpemUpXG4gICAgICAgIHJldHVybiBOdW1iZXIoaGV4KTtcbiAgICByZXR1cm4gTnVtYmVyKHRvQmlnSW50KGhleCwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gdG9TdHJpbmcoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzID0gQnl0ZXMuZnJvbUhleChoZXgpO1xuICAgIGlmIChzaXplKSB7XG4gICAgICAgIGludGVybmFsX2J5dGVzLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICBieXRlcyA9IEJ5dGVzLnRyaW1SaWdodChieXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0ID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZWdlck91dE9mUmFuZ2VFcnJvciA9IEludGVnZXJPdXRPZlJhbmdlRXJyb3I7XG5jbGFzcyBJbnZhbGlkSGV4Qm9vbGVhbkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4KSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke2hleH1cIlxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgaGV4IHZhbHVlIG11c3QgYmUgYFwiMHgwXCJgIChmYWxzZSkgb3IgYFwiMHgxXCJgICh0cnVlKS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguSW52YWxpZEhleEJvb2xlYW5FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yID0gSW52YWxpZEhleEJvb2xlYW5FcnJvcjtcbmNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRIZXhUeXBlRXJyb3IgPSBJbnZhbGlkSGV4VHlwZUVycm9yO1xuY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRIZXhWYWx1ZUVycm9yID0gSW52YWxpZEhleFZhbHVlRXJyb3I7XG5jbGFzcyBJbnZhbGlkTGVuZ3RoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgSGV4IHZhbHVlIFxcYFwiJHt2YWx1ZX1cIlxcYCBpcyBhbiBvZGQgbGVuZ3RoICgke3ZhbHVlLmxlbmd0aCAtIDJ9IG5pYmJsZXMpLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogWydJdCBtdXN0IGJlIGFuIGV2ZW4gbGVuZ3RoLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkTGVuZ3RoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZExlbmd0aEVycm9yID0gSW52YWxpZExlbmd0aEVycm9yO1xuY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNpemVPdmVyZmxvd0Vycm9yID0gU2l6ZU92ZXJmbG93RXJyb3I7XG5jbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciA9IFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjtcbmNsYXNzIFNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2l6ZSwgdGFyZ2V0U2l6ZSwgdHlwZSwgfSkge1xuICAgICAgICBzdXBlcihgJHt0eXBlLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpfSR7dHlwZVxuICAgICAgICAgICAgLnNsaWNlKDEpXG4gICAgICAgICAgICAudG9Mb3dlckNhc2UoKX0gc2l6ZSAoXFxgJHtzaXplfVxcYCkgZXhjZWVkcyBwYWRkaW5nIHNpemUgKFxcYCR7dGFyZ2V0U2l6ZX1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgPSBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Json.js":
/*!***********************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Json.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = parse;\nexports.stringify = stringify;\nconst bigIntSuffix = '#__bigint';\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9Kc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxKc29uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG5jb25zdCBiaWdJbnRTdWZmaXggPSAnI19fYmlnaW50JztcbmZ1bmN0aW9uIHBhcnNlKHN0cmluZywgcmV2aXZlcikge1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZywgKGtleSwgdmFsdWVfKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVfO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5lbmRzV2l0aChiaWdJbnRTdWZmaXgpKVxuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCh2YWx1ZS5zbGljZSgwLCAtYmlnSW50U3VmZml4Lmxlbmd0aCkpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyByZXZpdmVyKGtleSwgdmFsdWUpIDogdmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Json.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/PublicKey.js":
/*!****************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/PublicKey.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidSerializedSizeError = exports.InvalidUncompressedPrefixError = exports.InvalidCompressedPrefixError = exports.InvalidPrefixError = exports.InvalidError = void 0;\nexports.assert = assert;\nexports.compress = compress;\nexports.from = from;\nexports.fromBytes = fromBytes;\nexports.fromHex = fromHex;\nexports.toBytes = toBytes;\nexports.toHex = toHex;\nexports.validate = validate;\nconst Bytes = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst Json = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Json.js\");\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    throw new InvalidError({ publicKey });\n}\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\nfunction from(value) {\n    const publicKey = (() => {\n        if (Hex.validate(value))\n            return fromHex(value);\n        if (Bytes.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\nfunction fromBytes(publicKey) {\n    return fromHex(Hex.fromBytes(publicKey));\n}\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(Hex.slice(publicKey, 0, 32));\n        const y = BigInt(Hex.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(Hex.slice(publicKey, 0, 1));\n        const x = BigInt(Hex.slice(publicKey, 1, 33));\n        const y = BigInt(Hex.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(Hex.slice(publicKey, 0, 1));\n    const x = BigInt(Hex.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\nfunction toBytes(publicKey, options = {}) {\n    return Bytes.fromHex(toHex(publicKey, options));\n}\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = Hex.concat(includePrefix ? Hex.fromNumber(prefix, { size: 1 }) : '0x', Hex.fromNumber(x, { size: 32 }), typeof y === 'bigint' ? Hex.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\nclass InvalidError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${Json.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\nexports.InvalidError = InvalidError;\nclass InvalidPrefixError extends Errors.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\nexports.InvalidPrefixError = InvalidPrefixError;\nclass InvalidCompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\nexports.InvalidCompressedPrefixError = InvalidCompressedPrefixError;\nclass InvalidUncompressedPrefixError extends Errors.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\nexports.InvalidUncompressedPrefixError = InvalidUncompressedPrefixError;\nclass InvalidSerializedSizeError extends Errors.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${Hex.size(Hex.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\nexports.InvalidSerializedSizeError = InvalidSerializedSizeError;\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9QdWJsaWNLZXkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0NBQWtDLEdBQUcsc0NBQXNDLEdBQUcsb0NBQW9DLEdBQUcsMEJBQTBCLEdBQUcsb0JBQW9CO0FBQ3RLLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsWUFBWTtBQUNaLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2YsZUFBZTtBQUNmLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsY0FBYyxtQkFBTyxDQUFDLGtFQUFZO0FBQ2xDLGVBQWUsbUJBQU8sQ0FBQyxvRUFBYTtBQUNwQyxZQUFZLG1CQUFPLENBQUMsOERBQVU7QUFDOUIsYUFBYSxtQkFBTyxDQUFDLGdFQUFXO0FBQ2hDLHVDQUF1QztBQUN2QyxZQUFZLGFBQWE7QUFDekIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsWUFBWSxlQUFlO0FBQzNCLFlBQVksdUJBQXVCO0FBQ25DLDJFQUEyRSxTQUFTLDhCQUE4QixVQUFVLCtDQUErQyxVQUFVO0FBQ3JMO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLDBCQUEwQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxQdWJsaWNLZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgPSBleHBvcnRzLkludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3IgPSBleHBvcnRzLkludmFsaWRQcmVmaXhFcnJvciA9IGV4cG9ydHMuSW52YWxpZEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmNvbXByZXNzID0gY29tcHJlc3M7XG5leHBvcnRzLmZyb20gPSBmcm9tO1xuZXhwb3J0cy5mcm9tQnl0ZXMgPSBmcm9tQnl0ZXM7XG5leHBvcnRzLmZyb21IZXggPSBmcm9tSGV4O1xuZXhwb3J0cy50b0J5dGVzID0gdG9CeXRlcztcbmV4cG9ydHMudG9IZXggPSB0b0hleDtcbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4vQnl0ZXMuanNcIik7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi9FcnJvcnMuanNcIik7XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi9IZXguanNcIik7XG5jb25zdCBKc29uID0gcmVxdWlyZShcIi4vSnNvbi5qc1wiKTtcbmZ1bmN0aW9uIGFzc2VydChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgY29tcHJlc3NlZCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHByZWZpeCwgeCwgeSB9ID0gcHVibGljS2V5O1xuICAgIGlmIChjb21wcmVzc2VkID09PSBmYWxzZSB8fFxuICAgICAgICAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAnYmlnaW50JykpIHtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gNClcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJlZml4RXJyb3Ioe1xuICAgICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgICBjYXVzZTogbmV3IEludmFsaWRVbmNvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbmZ1bmN0aW9uIGNvbXByZXNzKHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gcHVibGljS2V5O1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeDogeSAlIDJuID09PSAwbiA/IDIgOiAzLFxuICAgICAgICB4LFxuICAgIH07XG59XG5mdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUhleCh2YWx1ZSk7XG4gICAgICAgIGlmIChCeXRlcy52YWxpZGF0ZSh2YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHgsIHkgfSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdiaWdpbnQnICYmIHR5cGVvZiB5ID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB7IHByZWZpeDogcHJlZml4ID8/IDB4MDQsIHgsIHkgfTtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB4IH07XG4gICAgfSkoKTtcbiAgICBhc3NlcnQocHVibGljS2V5KTtcbiAgICByZXR1cm4gcHVibGljS2V5O1xufVxuZnVuY3Rpb24gZnJvbUJ5dGVzKHB1YmxpY0tleSkge1xuICAgIHJldHVybiBmcm9tSGV4KEhleC5mcm9tQnl0ZXMocHVibGljS2V5KSk7XG59XG5mdW5jdGlvbiBmcm9tSGV4KHB1YmxpY0tleSkge1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAxMzIgJiZcbiAgICAgICAgcHVibGljS2V5Lmxlbmd0aCAhPT0gMTMwICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDY4KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IoeyBwdWJsaWNLZXkgfSk7XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDEzMCkge1xuICAgICAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IHkgPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMzIsIDY0KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXg6IDQsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHB1YmxpY0tleS5sZW5ndGggPT09IDEzMikge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBOdW1iZXIoSGV4LnNsaWNlKHB1YmxpY0tleSwgMCwgMSkpO1xuICAgICAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDEsIDMzKSk7XG4gICAgICAgIGNvbnN0IHkgPSBCaWdJbnQoSGV4LnNsaWNlKHB1YmxpY0tleSwgMzMsIDY1KSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICBjb25zdCB4ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDEsIDMzKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4LFxuICAgICAgICB4LFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcgPyBIZXguZnJvbU51bWJlcih5LCB7IHNpemU6IDMyIH0pIDogJzB4Jyk7XG4gICAgcmV0dXJuIHB1YmxpY0tleV87XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChwdWJsaWNLZXksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jbGFzcyBJbnZhbGlkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke0pzb24uc3RyaW5naWZ5KHB1YmxpY0tleSl9XFxgIGlzIG5vdCBhIHZhbGlkIHB1YmxpYyBrZXkuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1B1YmxpYyBrZXkgbXVzdCBjb250YWluOicsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgICAgICctIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZCknLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdQdWJsaWNLZXkuSW52YWxpZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRFcnJvciA9IEludmFsaWRFcnJvcjtcbmNsYXNzIEludmFsaWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4LCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBQcmVmaXggXCIke3ByZWZpeH1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFByZWZpeEVycm9yID0gSW52YWxpZFByZWZpeEVycm9yO1xuY2xhc3MgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignUHJlZml4IG11c3QgYmUgMiBvciAzIGZvciBjb21wcmVzc2VkIHB1YmxpYyBrZXlzLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnUHVibGljS2V5LkludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvciA9IEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3I7XG5jbGFzcyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDQgZm9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yID0gSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yO1xuY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3B1YmxpY0tleX1cXGAgaXMgYW4gaW52YWxpZCBwdWJsaWMga2V5IHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiAzMyBieXRlcyAoY29tcHJlc3NlZCArIHByZWZpeCksIDY0IGJ5dGVzICh1bmNvbXByZXNzZWQpIG9yIDY1IGJ5dGVzICh1bmNvbXByZXNzZWQgKyBwcmVmaXgpLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20ocHVibGljS2V5KSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciA9IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Solidity.js":
/*!***************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Solidity.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.minInt120 = exports.minInt112 = exports.minInt104 = exports.minInt96 = exports.minInt88 = exports.minInt80 = exports.minInt72 = exports.minInt64 = exports.minInt56 = exports.minInt48 = exports.minInt40 = exports.minInt32 = exports.minInt24 = exports.minInt16 = exports.minInt8 = exports.maxInt256 = exports.maxInt248 = exports.maxInt240 = exports.maxInt232 = exports.maxInt224 = exports.maxInt216 = exports.maxInt208 = exports.maxInt200 = exports.maxInt192 = exports.maxInt184 = exports.maxInt176 = exports.maxInt168 = exports.maxInt160 = exports.maxInt152 = exports.maxInt144 = exports.maxInt136 = exports.maxInt128 = exports.maxInt120 = exports.maxInt112 = exports.maxInt104 = exports.maxInt96 = exports.maxInt88 = exports.maxInt80 = exports.maxInt72 = exports.maxInt64 = exports.maxInt56 = exports.maxInt48 = exports.maxInt40 = exports.maxInt32 = exports.maxInt24 = exports.maxInt16 = exports.maxInt8 = exports.integerRegex = exports.bytesRegex = exports.arrayRegex = void 0;\nexports.maxUint256 = exports.maxUint248 = exports.maxUint240 = exports.maxUint232 = exports.maxUint224 = exports.maxUint216 = exports.maxUint208 = exports.maxUint200 = exports.maxUint192 = exports.maxUint184 = exports.maxUint176 = exports.maxUint168 = exports.maxUint160 = exports.maxUint152 = exports.maxUint144 = exports.maxUint136 = exports.maxUint128 = exports.maxUint120 = exports.maxUint112 = exports.maxUint104 = exports.maxUint96 = exports.maxUint88 = exports.maxUint80 = exports.maxUint72 = exports.maxUint64 = exports.maxUint56 = exports.maxUint48 = exports.maxUint40 = exports.maxUint32 = exports.maxUint24 = exports.maxUint16 = exports.maxUint8 = exports.minInt256 = exports.minInt248 = exports.minInt240 = exports.minInt232 = exports.minInt224 = exports.minInt216 = exports.minInt208 = exports.minInt200 = exports.minInt192 = exports.minInt184 = exports.minInt176 = exports.minInt168 = exports.minInt160 = exports.minInt152 = exports.minInt144 = exports.minInt136 = exports.minInt128 = void 0;\nexports.arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\nexports.bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\nexports.integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nexports.maxInt8 = 2n ** (8n - 1n) - 1n;\nexports.maxInt16 = 2n ** (16n - 1n) - 1n;\nexports.maxInt24 = 2n ** (24n - 1n) - 1n;\nexports.maxInt32 = 2n ** (32n - 1n) - 1n;\nexports.maxInt40 = 2n ** (40n - 1n) - 1n;\nexports.maxInt48 = 2n ** (48n - 1n) - 1n;\nexports.maxInt56 = 2n ** (56n - 1n) - 1n;\nexports.maxInt64 = 2n ** (64n - 1n) - 1n;\nexports.maxInt72 = 2n ** (72n - 1n) - 1n;\nexports.maxInt80 = 2n ** (80n - 1n) - 1n;\nexports.maxInt88 = 2n ** (88n - 1n) - 1n;\nexports.maxInt96 = 2n ** (96n - 1n) - 1n;\nexports.maxInt104 = 2n ** (104n - 1n) - 1n;\nexports.maxInt112 = 2n ** (112n - 1n) - 1n;\nexports.maxInt120 = 2n ** (120n - 1n) - 1n;\nexports.maxInt128 = 2n ** (128n - 1n) - 1n;\nexports.maxInt136 = 2n ** (136n - 1n) - 1n;\nexports.maxInt144 = 2n ** (144n - 1n) - 1n;\nexports.maxInt152 = 2n ** (152n - 1n) - 1n;\nexports.maxInt160 = 2n ** (160n - 1n) - 1n;\nexports.maxInt168 = 2n ** (168n - 1n) - 1n;\nexports.maxInt176 = 2n ** (176n - 1n) - 1n;\nexports.maxInt184 = 2n ** (184n - 1n) - 1n;\nexports.maxInt192 = 2n ** (192n - 1n) - 1n;\nexports.maxInt200 = 2n ** (200n - 1n) - 1n;\nexports.maxInt208 = 2n ** (208n - 1n) - 1n;\nexports.maxInt216 = 2n ** (216n - 1n) - 1n;\nexports.maxInt224 = 2n ** (224n - 1n) - 1n;\nexports.maxInt232 = 2n ** (232n - 1n) - 1n;\nexports.maxInt240 = 2n ** (240n - 1n) - 1n;\nexports.maxInt248 = 2n ** (248n - 1n) - 1n;\nexports.maxInt256 = 2n ** (256n - 1n) - 1n;\nexports.minInt8 = -(2n ** (8n - 1n));\nexports.minInt16 = -(2n ** (16n - 1n));\nexports.minInt24 = -(2n ** (24n - 1n));\nexports.minInt32 = -(2n ** (32n - 1n));\nexports.minInt40 = -(2n ** (40n - 1n));\nexports.minInt48 = -(2n ** (48n - 1n));\nexports.minInt56 = -(2n ** (56n - 1n));\nexports.minInt64 = -(2n ** (64n - 1n));\nexports.minInt72 = -(2n ** (72n - 1n));\nexports.minInt80 = -(2n ** (80n - 1n));\nexports.minInt88 = -(2n ** (88n - 1n));\nexports.minInt96 = -(2n ** (96n - 1n));\nexports.minInt104 = -(2n ** (104n - 1n));\nexports.minInt112 = -(2n ** (112n - 1n));\nexports.minInt120 = -(2n ** (120n - 1n));\nexports.minInt128 = -(2n ** (128n - 1n));\nexports.minInt136 = -(2n ** (136n - 1n));\nexports.minInt144 = -(2n ** (144n - 1n));\nexports.minInt152 = -(2n ** (152n - 1n));\nexports.minInt160 = -(2n ** (160n - 1n));\nexports.minInt168 = -(2n ** (168n - 1n));\nexports.minInt176 = -(2n ** (176n - 1n));\nexports.minInt184 = -(2n ** (184n - 1n));\nexports.minInt192 = -(2n ** (192n - 1n));\nexports.minInt200 = -(2n ** (200n - 1n));\nexports.minInt208 = -(2n ** (208n - 1n));\nexports.minInt216 = -(2n ** (216n - 1n));\nexports.minInt224 = -(2n ** (224n - 1n));\nexports.minInt232 = -(2n ** (232n - 1n));\nexports.minInt240 = -(2n ** (240n - 1n));\nexports.minInt248 = -(2n ** (248n - 1n));\nexports.minInt256 = -(2n ** (256n - 1n));\nexports.maxUint8 = 2n ** 8n - 1n;\nexports.maxUint16 = 2n ** 16n - 1n;\nexports.maxUint24 = 2n ** 24n - 1n;\nexports.maxUint32 = 2n ** 32n - 1n;\nexports.maxUint40 = 2n ** 40n - 1n;\nexports.maxUint48 = 2n ** 48n - 1n;\nexports.maxUint56 = 2n ** 56n - 1n;\nexports.maxUint64 = 2n ** 64n - 1n;\nexports.maxUint72 = 2n ** 72n - 1n;\nexports.maxUint80 = 2n ** 80n - 1n;\nexports.maxUint88 = 2n ** 88n - 1n;\nexports.maxUint96 = 2n ** 96n - 1n;\nexports.maxUint104 = 2n ** 104n - 1n;\nexports.maxUint112 = 2n ** 112n - 1n;\nexports.maxUint120 = 2n ** 120n - 1n;\nexports.maxUint128 = 2n ** 128n - 1n;\nexports.maxUint136 = 2n ** 136n - 1n;\nexports.maxUint144 = 2n ** 144n - 1n;\nexports.maxUint152 = 2n ** 152n - 1n;\nexports.maxUint160 = 2n ** 160n - 1n;\nexports.maxUint168 = 2n ** 168n - 1n;\nexports.maxUint176 = 2n ** 176n - 1n;\nexports.maxUint184 = 2n ** 184n - 1n;\nexports.maxUint192 = 2n ** 192n - 1n;\nexports.maxUint200 = 2n ** 200n - 1n;\nexports.maxUint208 = 2n ** 208n - 1n;\nexports.maxUint216 = 2n ** 216n - 1n;\nexports.maxUint224 = 2n ** 224n - 1n;\nexports.maxUint232 = 2n ** 232n - 1n;\nexports.maxUint240 = 2n ** 240n - 1n;\nexports.maxUint248 = 2n ** 248n - 1n;\nexports.maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9Tb2xpZGl0eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxlQUFlLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLG9CQUFvQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQjtBQUNoOUIsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCLEdBQUcsaUJBQWlCO0FBQ3ArQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixlQUFlO0FBQ2YsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcU29saWRpdHkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1pbkludDEyMCA9IGV4cG9ydHMubWluSW50MTEyID0gZXhwb3J0cy5taW5JbnQxMDQgPSBleHBvcnRzLm1pbkludDk2ID0gZXhwb3J0cy5taW5JbnQ4OCA9IGV4cG9ydHMubWluSW50ODAgPSBleHBvcnRzLm1pbkludDcyID0gZXhwb3J0cy5taW5JbnQ2NCA9IGV4cG9ydHMubWluSW50NTYgPSBleHBvcnRzLm1pbkludDQ4ID0gZXhwb3J0cy5taW5JbnQ0MCA9IGV4cG9ydHMubWluSW50MzIgPSBleHBvcnRzLm1pbkludDI0ID0gZXhwb3J0cy5taW5JbnQxNiA9IGV4cG9ydHMubWluSW50OCA9IGV4cG9ydHMubWF4SW50MjU2ID0gZXhwb3J0cy5tYXhJbnQyNDggPSBleHBvcnRzLm1heEludDI0MCA9IGV4cG9ydHMubWF4SW50MjMyID0gZXhwb3J0cy5tYXhJbnQyMjQgPSBleHBvcnRzLm1heEludDIxNiA9IGV4cG9ydHMubWF4SW50MjA4ID0gZXhwb3J0cy5tYXhJbnQyMDAgPSBleHBvcnRzLm1heEludDE5MiA9IGV4cG9ydHMubWF4SW50MTg0ID0gZXhwb3J0cy5tYXhJbnQxNzYgPSBleHBvcnRzLm1heEludDE2OCA9IGV4cG9ydHMubWF4SW50MTYwID0gZXhwb3J0cy5tYXhJbnQxNTIgPSBleHBvcnRzLm1heEludDE0NCA9IGV4cG9ydHMubWF4SW50MTM2ID0gZXhwb3J0cy5tYXhJbnQxMjggPSBleHBvcnRzLm1heEludDEyMCA9IGV4cG9ydHMubWF4SW50MTEyID0gZXhwb3J0cy5tYXhJbnQxMDQgPSBleHBvcnRzLm1heEludDk2ID0gZXhwb3J0cy5tYXhJbnQ4OCA9IGV4cG9ydHMubWF4SW50ODAgPSBleHBvcnRzLm1heEludDcyID0gZXhwb3J0cy5tYXhJbnQ2NCA9IGV4cG9ydHMubWF4SW50NTYgPSBleHBvcnRzLm1heEludDQ4ID0gZXhwb3J0cy5tYXhJbnQ0MCA9IGV4cG9ydHMubWF4SW50MzIgPSBleHBvcnRzLm1heEludDI0ID0gZXhwb3J0cy5tYXhJbnQxNiA9IGV4cG9ydHMubWF4SW50OCA9IGV4cG9ydHMuaW50ZWdlclJlZ2V4ID0gZXhwb3J0cy5ieXRlc1JlZ2V4ID0gZXhwb3J0cy5hcnJheVJlZ2V4ID0gdm9pZCAwO1xuZXhwb3J0cy5tYXhVaW50MjU2ID0gZXhwb3J0cy5tYXhVaW50MjQ4ID0gZXhwb3J0cy5tYXhVaW50MjQwID0gZXhwb3J0cy5tYXhVaW50MjMyID0gZXhwb3J0cy5tYXhVaW50MjI0ID0gZXhwb3J0cy5tYXhVaW50MjE2ID0gZXhwb3J0cy5tYXhVaW50MjA4ID0gZXhwb3J0cy5tYXhVaW50MjAwID0gZXhwb3J0cy5tYXhVaW50MTkyID0gZXhwb3J0cy5tYXhVaW50MTg0ID0gZXhwb3J0cy5tYXhVaW50MTc2ID0gZXhwb3J0cy5tYXhVaW50MTY4ID0gZXhwb3J0cy5tYXhVaW50MTYwID0gZXhwb3J0cy5tYXhVaW50MTUyID0gZXhwb3J0cy5tYXhVaW50MTQ0ID0gZXhwb3J0cy5tYXhVaW50MTM2ID0gZXhwb3J0cy5tYXhVaW50MTI4ID0gZXhwb3J0cy5tYXhVaW50MTIwID0gZXhwb3J0cy5tYXhVaW50MTEyID0gZXhwb3J0cy5tYXhVaW50MTA0ID0gZXhwb3J0cy5tYXhVaW50OTYgPSBleHBvcnRzLm1heFVpbnQ4OCA9IGV4cG9ydHMubWF4VWludDgwID0gZXhwb3J0cy5tYXhVaW50NzIgPSBleHBvcnRzLm1heFVpbnQ2NCA9IGV4cG9ydHMubWF4VWludDU2ID0gZXhwb3J0cy5tYXhVaW50NDggPSBleHBvcnRzLm1heFVpbnQ0MCA9IGV4cG9ydHMubWF4VWludDMyID0gZXhwb3J0cy5tYXhVaW50MjQgPSBleHBvcnRzLm1heFVpbnQxNiA9IGV4cG9ydHMubWF4VWludDggPSBleHBvcnRzLm1pbkludDI1NiA9IGV4cG9ydHMubWluSW50MjQ4ID0gZXhwb3J0cy5taW5JbnQyNDAgPSBleHBvcnRzLm1pbkludDIzMiA9IGV4cG9ydHMubWluSW50MjI0ID0gZXhwb3J0cy5taW5JbnQyMTYgPSBleHBvcnRzLm1pbkludDIwOCA9IGV4cG9ydHMubWluSW50MjAwID0gZXhwb3J0cy5taW5JbnQxOTIgPSBleHBvcnRzLm1pbkludDE4NCA9IGV4cG9ydHMubWluSW50MTc2ID0gZXhwb3J0cy5taW5JbnQxNjggPSBleHBvcnRzLm1pbkludDE2MCA9IGV4cG9ydHMubWluSW50MTUyID0gZXhwb3J0cy5taW5JbnQxNDQgPSBleHBvcnRzLm1pbkludDEzNiA9IGV4cG9ydHMubWluSW50MTI4ID0gdm9pZCAwO1xuZXhwb3J0cy5hcnJheVJlZ2V4ID0gL14oLiopXFxbKFswLTldKilcXF0kLztcbmV4cG9ydHMuYnl0ZXNSZWdleCA9IC9eYnl0ZXMoWzEtOV18MVswLTldfDJbMC05XXwzWzAtMl0pPyQvO1xuZXhwb3J0cy5pbnRlZ2VyUmVnZXggPSAvXih1P2ludCkoOHwxNnwyNHwzMnw0MHw0OHw1Nnw2NHw3Mnw4MHw4OHw5NnwxMDR8MTEyfDEyMHwxMjh8MTM2fDE0NHwxNTJ8MTYwfDE2OHwxNzZ8MTg0fDE5MnwyMDB8MjA4fDIxNnwyMjR8MjMyfDI0MHwyNDh8MjU2KT8kLztcbmV4cG9ydHMubWF4SW50OCA9IDJuICoqICg4biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQxNiA9IDJuICoqICgxNm4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50MjQgPSAybiAqKiAoMjRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDMyID0gMm4gKiogKDMybiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQ0MCA9IDJuICoqICg0MG4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50NDggPSAybiAqKiAoNDhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDU2ID0gMm4gKiogKDU2biAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQ2NCA9IDJuICoqICg2NG4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50NzIgPSAybiAqKiAoNzJuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDgwID0gMm4gKiogKDgwbiAtIDFuKSAtIDFuO1xuZXhwb3J0cy5tYXhJbnQ4OCA9IDJuICoqICg4OG4gLSAxbikgLSAxbjtcbmV4cG9ydHMubWF4SW50OTYgPSAybiAqKiAoOTZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDEwNCA9IDJuICoqICgxMDRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDExMiA9IDJuICoqICgxMTJuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDEyMCA9IDJuICoqICgxMjBuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDEyOCA9IDJuICoqICgxMjhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDEzNiA9IDJuICoqICgxMzZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE0NCA9IDJuICoqICgxNDRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE1MiA9IDJuICoqICgxNTJuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE2MCA9IDJuICoqICgxNjBuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE2OCA9IDJuICoqICgxNjhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE3NiA9IDJuICoqICgxNzZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE4NCA9IDJuICoqICgxODRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDE5MiA9IDJuICoqICgxOTJuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDIwMCA9IDJuICoqICgyMDBuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDIwOCA9IDJuICoqICgyMDhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDIxNiA9IDJuICoqICgyMTZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDIyNCA9IDJuICoqICgyMjRuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDIzMiA9IDJuICoqICgyMzJuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDI0MCA9IDJuICoqICgyNDBuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDI0OCA9IDJuICoqICgyNDhuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1heEludDI1NiA9IDJuICoqICgyNTZuIC0gMW4pIC0gMW47XG5leHBvcnRzLm1pbkludDggPSAtKDJuICoqICg4biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE2ID0gLSgybiAqKiAoMTZuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjQgPSAtKDJuICoqICgyNG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQzMiA9IC0oMm4gKiogKDMybiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDQwID0gLSgybiAqKiAoNDBuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50NDggPSAtKDJuICoqICg0OG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQ1NiA9IC0oMm4gKiogKDU2biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDY0ID0gLSgybiAqKiAoNjRuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50NzIgPSAtKDJuICoqICg3Mm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQ4MCA9IC0oMm4gKiogKDgwbiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDg4ID0gLSgybiAqKiAoODhuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50OTYgPSAtKDJuICoqICg5Nm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxMDQgPSAtKDJuICoqICgxMDRuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTEyID0gLSgybiAqKiAoMTEybiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDEyMCA9IC0oMm4gKiogKDEyMG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxMjggPSAtKDJuICoqICgxMjhuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTM2ID0gLSgybiAqKiAoMTM2biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE0NCA9IC0oMm4gKiogKDE0NG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxNTIgPSAtKDJuICoqICgxNTJuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTYwID0gLSgybiAqKiAoMTYwbiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE2OCA9IC0oMm4gKiogKDE2OG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQxNzYgPSAtKDJuICoqICgxNzZuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MTg0ID0gLSgybiAqKiAoMTg0biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDE5MiA9IC0oMm4gKiogKDE5Mm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQyMDAgPSAtKDJuICoqICgyMDBuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjA4ID0gLSgybiAqKiAoMjA4biAtIDFuKSk7XG5leHBvcnRzLm1pbkludDIxNiA9IC0oMm4gKiogKDIxNm4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQyMjQgPSAtKDJuICoqICgyMjRuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjMyID0gLSgybiAqKiAoMjMybiAtIDFuKSk7XG5leHBvcnRzLm1pbkludDI0MCA9IC0oMm4gKiogKDI0MG4gLSAxbikpO1xuZXhwb3J0cy5taW5JbnQyNDggPSAtKDJuICoqICgyNDhuIC0gMW4pKTtcbmV4cG9ydHMubWluSW50MjU2ID0gLSgybiAqKiAoMjU2biAtIDFuKSk7XG5leHBvcnRzLm1heFVpbnQ4ID0gMm4gKiogOG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDE2ID0gMm4gKiogMTZuIC0gMW47XG5leHBvcnRzLm1heFVpbnQyNCA9IDJuICoqIDI0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MzIgPSAybiAqKiAzMm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDQwID0gMm4gKiogNDBuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ0OCA9IDJuICoqIDQ4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50NTYgPSAybiAqKiA1Nm4gLSAxbjtcbmV4cG9ydHMubWF4VWludDY0ID0gMm4gKiogNjRuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ3MiA9IDJuICoqIDcybiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50ODAgPSAybiAqKiA4MG4gLSAxbjtcbmV4cG9ydHMubWF4VWludDg4ID0gMm4gKiogODhuIC0gMW47XG5leHBvcnRzLm1heFVpbnQ5NiA9IDJuICoqIDk2biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTA0ID0gMm4gKiogMTA0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTEyID0gMm4gKiogMTEybiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTIwID0gMm4gKiogMTIwbiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTI4ID0gMm4gKiogMTI4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTM2ID0gMm4gKiogMTM2biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTQ0ID0gMm4gKiogMTQ0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTUyID0gMm4gKiogMTUybiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTYwID0gMm4gKiogMTYwbiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTY4ID0gMm4gKiogMTY4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTc2ID0gMm4gKiogMTc2biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTg0ID0gMm4gKiogMTg0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MTkyID0gMm4gKiogMTkybiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjAwID0gMm4gKiogMjAwbiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjA4ID0gMm4gKiogMjA4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjE2ID0gMm4gKiogMjE2biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjI0ID0gMm4gKiogMjI0biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjMyID0gMm4gKiogMjMybiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjQwID0gMm4gKiogMjQwbiAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjQ4ID0gMm4gKiogMjQ4biAtIDFuO1xuZXhwb3J0cy5tYXhVaW50MjU2ID0gMm4gKiogMjU2biAtIDFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U29saWRpdHkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/Withdrawal.js":
/*!*****************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/Withdrawal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fromRpc = fromRpc;\nexports.toRpc = toRpc;\nconst Hex = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: Hex.fromNumber(withdrawal.amount),\n        index: Hex.fromNumber(withdrawal.index),\n        validatorIndex: Hex.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9XaXRoZHJhd2FsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixhQUFhO0FBQ2IsWUFBWSxtQkFBTyxDQUFDLDhEQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXFdpdGhkcmF3YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZyb21ScGMgPSBmcm9tUnBjO1xuZXhwb3J0cy50b1JwYyA9IHRvUnBjO1xuY29uc3QgSGV4ID0gcmVxdWlyZShcIi4vSGV4LmpzXCIpO1xuZnVuY3Rpb24gZnJvbVJwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ud2l0aGRyYXdhbCxcbiAgICAgICAgYW1vdW50OiBCaWdJbnQod2l0aGRyYXdhbC5hbW91bnQpLFxuICAgICAgICBpbmRleDogTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogTnVtYmVyKHdpdGhkcmF3YWwudmFsaWRhdG9ySW5kZXgpLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/abiItem.js":
/*!***********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/abiItem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeSignature = normalizeSignature;\nexports.isArgOfType = isArgOfType;\nexports.getAmbiguousTypes = getAmbiguousTypes;\nconst Address = __webpack_require__(/*! ../Address.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Address.js\");\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        if (['(', ')', ','].includes(char))\n            active = true;\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        if (!active)\n            continue;\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        if (char === ' ') {\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new Errors.BaseError('Unable to normalize signature.');\n    return result;\n}\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return Address.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return Address.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkIseUJBQXlCO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxxRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxTQUFTLEdBQUc7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxpbnRlcm5hbFxcYWJpSXRlbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm9ybWFsaXplU2lnbmF0dXJlID0gbm9ybWFsaXplU2lnbmF0dXJlO1xuZXhwb3J0cy5pc0FyZ09mVHlwZSA9IGlzQXJnT2ZUeXBlO1xuZXhwb3J0cy5nZXRBbWJpZ3VvdXNUeXBlcyA9IGdldEFtYmlndW91c1R5cGVzO1xuY29uc3QgQWRkcmVzcyA9IHJlcXVpcmUoXCIuLi9BZGRyZXNzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4uL0Vycm9ycy5qc1wiKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBsZXQgYWN0aXZlID0gdHJ1ZTtcbiAgICBsZXQgY3VycmVudCA9ICcnO1xuICAgIGxldCBsZXZlbCA9IDA7XG4gICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgIGxldCB2YWxpZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBzaWduYXR1cmVbaV07XG4gICAgICAgIGlmIChbJygnLCAnKScsICcsJ10uaW5jbHVkZXMoY2hhcikpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICBpZiAoY2hhciA9PT0gJygnKVxuICAgICAgICAgICAgbGV2ZWwrKztcbiAgICAgICAgaWYgKGNoYXIgPT09ICcpJylcbiAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGNoYXIgPT09ICcgJyAmJiBbJ2V2ZW50JywgJ2Z1bmN0aW9uJywgJ2Vycm9yJywgJyddLmluY2x1ZGVzKHJlc3VsdCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gJyc7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gY2hhcjtcbiAgICAgICAgICAgICAgICBpZiAoY2hhciA9PT0gJyknKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXIgPT09ICcgJykge1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZVtpIC0gMV0gIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCcgJiYgY3VycmVudCAhPT0gJywoJykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSAnJztcbiAgICAgICAgICAgICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICBjdXJyZW50ICs9IGNoYXI7XG4gICAgfVxuICAgIGlmICghdmFsaWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdVbmFibGUgdG8gbm9ybWFsaXplIHNpZ25hdHVyZS4nKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcbiAgICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gJ3R1cGxlJyAmJiAnY29tcG9uZW50cycgaW4gYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4XSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICgvXnU/aW50KDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ251bWJlcicgfHwgYXJnVHlwZSA9PT0gJ2JpZ2ludCc7XG4gICAgICAgICAgICBpZiAoL15ieXRlcyhbMS05XXwxWzAtOV18MlswLTldfDNbMC0yXSk/JC8udGVzdChhYmlQYXJhbWV0ZXJUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnVHlwZSA9PT0gJ3N0cmluZycgfHwgYXJnIGluc3RhbmNlb2YgVWludDhBcnJheTtcbiAgICAgICAgICAgIGlmICgvW2Etel0rWzEtOV17MCwzfShcXFtbMC05XXswLH1cXF0pKyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkoYXJnKSAmJlxuICAgICAgICAgICAgICAgICAgICBhcmcuZXZlcnkoKHgpID0+IGlzQXJnT2ZUeXBlKHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmFiaVBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGFiaVBhcmFtZXRlclR5cGUucmVwbGFjZSgvKFxcW1swLTldezAsfVxcXSkkLywgJycpLFxuICAgICAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiBzb3VyY2VQYXJhbWV0ZXIgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiB0YXJnZXRQYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVyLmNvbXBvbmVudHMsIHRhcmdldFBhcmFtZXRlci5jb21wb25lbnRzLCBhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMyMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoYW1iaWd1b3VzKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/abiParameters.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/abiParameters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.decodeParameter = decodeParameter;\nexports.decodeAddress = decodeAddress;\nexports.decodeArray = decodeArray;\nexports.decodeBool = decodeBool;\nexports.decodeBytes = decodeBytes;\nexports.decodeNumber = decodeNumber;\nexports.decodeTuple = decodeTuple;\nexports.decodeString = decodeString;\nexports.prepareParameters = prepareParameters;\nexports.prepareParameter = prepareParameter;\nexports.encode = encode;\nexports.encodeAddress = encodeAddress;\nexports.encodeArray = encodeArray;\nexports.encodeBytes = encodeBytes;\nexports.encodeBoolean = encodeBoolean;\nexports.encodeNumber = encodeNumber;\nexports.encodeString = encodeString;\nexports.encodeTuple = encodeTuple;\nexports.getArrayComponents = getArrayComponents;\nexports.hasDynamicChild = hasDynamicChild;\nconst AbiParameters = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/../../node_modules/ox/_cjs/core/AbiParameters.js\");\nconst Address = __webpack_require__(/*! ../Address.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Address.js\");\nconst Bytes = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst Hex = __webpack_require__(/*! ../Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nconst Solidity_js_1 = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Solidity.js\");\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new AbiParameters.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? Address.checksum(address) : address;\n    return [wrap(Hex.fromBytes(Bytes.slice(value, -20))), 32];\n}\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    if (!length) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        cursor.setPosition(start);\n        const length = Bytes.toNumber(cursor.readBytes(sizeOfLength));\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    if (hasDynamicChild(param)) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\nfunction decodeBool(cursor) {\n    return [Bytes.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        const offset = Bytes.toNumber(cursor.readBytes(32));\n        cursor.setPosition(staticPosition + offset);\n        const length = Bytes.toNumber(cursor.readBytes(32));\n        if (length === 0) {\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        cursor.setPosition(staticPosition + 32);\n        return [Hex.fromBytes(data), 32];\n    }\n    const value = Hex.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? Bytes.toBigInt(value, { signed })\n            : Bytes.toNumber(value, { signed }),\n        32,\n    ];\n}\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    if (hasDynamicChild(param)) {\n        const offset = Bytes.toNumber(cursor.readBytes(sizeOfOffset));\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\nfunction decodeString(cursor, { staticPosition }) {\n    const offset = Bytes.toNumber(cursor.readBytes(32));\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = Bytes.toNumber(cursor.readBytes(32));\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = Bytes.toString(Bytes.trimLeft(data));\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = Solidity_js_1.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new AbiParameters.InvalidTypeError(parameter.type);\n}\nfunction encode(preparedParameters) {\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += Hex.size(encoded);\n    }\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(Hex.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += Hex.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    return Hex.concat(...staticParameters, ...dynamicParameters);\n}\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    Address.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: Hex.padLeft(value.toLowerCase()),\n    };\n}\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new AbiParameters.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new AbiParameters.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = Hex.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? Hex.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = Hex.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        if (bytesSize % 32 !== 0)\n            value_ = Hex.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: Hex.concat(Hex.padLeft(Hex.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize))\n        throw new AbiParameters.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize),\n            value,\n        });\n    return { dynamic: false, encoded: Hex.padRight(value) };\n}\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new Errors.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: Hex.padLeft(Hex.fromBoolean(value)) };\n}\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new Hex.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: Hex.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\nfunction encodeString(value) {\n    const hexValue = Hex.fromString(value);\n    const partsLength = Math.ceil(Hex.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(Hex.padRight(Hex.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: Hex.concat(Hex.padRight(Hex.fromNumber(Hex.size(hexValue), { size: 32 })), ...parts),\n    };\n}\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : Hex.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ?\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsb0JBQW9CO0FBQ3BCLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEIseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixjQUFjO0FBQ2QscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIscUJBQXFCO0FBQ3JCLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsbUJBQW1CO0FBQ25CLDBCQUEwQjtBQUMxQix1QkFBdUI7QUFDdkIsc0JBQXNCLG1CQUFPLENBQUMsbUZBQXFCO0FBQ25ELGdCQUFnQixtQkFBTyxDQUFDLHVFQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxtRUFBYTtBQUNuQyxlQUFlLG1CQUFPLENBQUMscUVBQWM7QUFDckMsWUFBWSxtQkFBTyxDQUFDLCtEQUFXO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLHlFQUFnQjtBQUM5QztBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0IsSUFBSSx5Q0FBeUM7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVDQUF1QywyQkFBMkI7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsZ0JBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBDQUEwQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsU0FBUztBQUNULGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsTUFBTSxXQUFXLGFBQWE7QUFDNUYsYUFBYTtBQUNiO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsVUFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxpbnRlcm5hbFxcYWJpUGFyYW1ldGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlUGFyYW1ldGVyID0gZGVjb2RlUGFyYW1ldGVyO1xuZXhwb3J0cy5kZWNvZGVBZGRyZXNzID0gZGVjb2RlQWRkcmVzcztcbmV4cG9ydHMuZGVjb2RlQXJyYXkgPSBkZWNvZGVBcnJheTtcbmV4cG9ydHMuZGVjb2RlQm9vbCA9IGRlY29kZUJvb2w7XG5leHBvcnRzLmRlY29kZUJ5dGVzID0gZGVjb2RlQnl0ZXM7XG5leHBvcnRzLmRlY29kZU51bWJlciA9IGRlY29kZU51bWJlcjtcbmV4cG9ydHMuZGVjb2RlVHVwbGUgPSBkZWNvZGVUdXBsZTtcbmV4cG9ydHMuZGVjb2RlU3RyaW5nID0gZGVjb2RlU3RyaW5nO1xuZXhwb3J0cy5wcmVwYXJlUGFyYW1ldGVycyA9IHByZXBhcmVQYXJhbWV0ZXJzO1xuZXhwb3J0cy5wcmVwYXJlUGFyYW1ldGVyID0gcHJlcGFyZVBhcmFtZXRlcjtcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlO1xuZXhwb3J0cy5lbmNvZGVBZGRyZXNzID0gZW5jb2RlQWRkcmVzcztcbmV4cG9ydHMuZW5jb2RlQXJyYXkgPSBlbmNvZGVBcnJheTtcbmV4cG9ydHMuZW5jb2RlQnl0ZXMgPSBlbmNvZGVCeXRlcztcbmV4cG9ydHMuZW5jb2RlQm9vbGVhbiA9IGVuY29kZUJvb2xlYW47XG5leHBvcnRzLmVuY29kZU51bWJlciA9IGVuY29kZU51bWJlcjtcbmV4cG9ydHMuZW5jb2RlU3RyaW5nID0gZW5jb2RlU3RyaW5nO1xuZXhwb3J0cy5lbmNvZGVUdXBsZSA9IGVuY29kZVR1cGxlO1xuZXhwb3J0cy5nZXRBcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHM7XG5leHBvcnRzLmhhc0R5bmFtaWNDaGlsZCA9IGhhc0R5bmFtaWNDaGlsZDtcbmNvbnN0IEFiaVBhcmFtZXRlcnMgPSByZXF1aXJlKFwiLi4vQWJpUGFyYW1ldGVycy5qc1wiKTtcbmNvbnN0IEFkZHJlc3MgPSByZXF1aXJlKFwiLi4vQWRkcmVzcy5qc1wiKTtcbmNvbnN0IEJ5dGVzID0gcmVxdWlyZShcIi4uL0J5dGVzLmpzXCIpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZShcIi4uL0Vycm9ycy5qc1wiKTtcbmNvbnN0IEhleCA9IHJlcXVpcmUoXCIuLi9IZXguanNcIik7XG5jb25zdCBTb2xpZGl0eV9qc18xID0gcmVxdWlyZShcIi4uL1NvbGlkaXR5LmpzXCIpO1xuZnVuY3Rpb24gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBkZWNvZGVBcnJheShjdXJzb3IsIHsgLi4ucGFyYW0sIHR5cGUgfSwgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbS50eXBlID09PSAndHVwbGUnKVxuICAgICAgICByZXR1cm4gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYWRkcmVzcycpXG4gICAgICAgIHJldHVybiBkZWNvZGVBZGRyZXNzKGN1cnNvciwgeyBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYm9vbCcpXG4gICAgICAgIHJldHVybiBkZWNvZGVCb29sKGN1cnNvcik7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgndWludCcpIHx8IHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpXG4gICAgICAgIHJldHVybiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtLnR5cGUpO1xufVxuY29uc3Qgc2l6ZU9mTGVuZ3RoID0gMzI7XG5jb25zdCBzaXplT2ZPZmZzZXQgPSAzMjtcbmZ1bmN0aW9uIGRlY29kZUFkZHJlc3MoY3Vyc29yLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICBjb25zdCB3cmFwID0gKGFkZHJlc3MpID0+IGNoZWNrc3VtID8gQWRkcmVzcy5jaGVja3N1bShhZGRyZXNzKSA6IGFkZHJlc3M7XG4gICAgcmV0dXJuIFt3cmFwKEhleC5mcm9tQnl0ZXMoQnl0ZXMuc2xpY2UodmFsdWUsIC0yMCkpKSwgMzJdO1xufVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHN0YXJ0T2ZEYXRhID0gc3RhcnQgKyBzaXplT2ZMZW5ndGg7XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mTGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IGR5bmFtaWNDaGlsZCA9IGhhc0R5bmFtaWNDaGlsZChwYXJhbSk7XG4gICAgICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydE9mRGF0YSArIChkeW5hbWljQ2hpbGQgPyBpICogMzIgOiBjb25zdW1lZCkpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnRPZkRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGkgKiAzMik7XG4gICAgICAgICAgICBjb25zdCBbZGF0YV0gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGF0aWNQb3NpdGlvbiArIGNvbnN1bWVkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICB2YWx1ZS5wdXNoKGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gW3ZhbHVlLCBjb25zdW1lZF07XG59XG5mdW5jdGlvbiBkZWNvZGVCb29sKGN1cnNvcikge1xuICAgIHJldHVybiBbQnl0ZXMudG9Cb29sZWFuKGN1cnNvci5yZWFkQnl0ZXMoMzIpLCB7IHNpemU6IDMyIH0pLCAzMl07XG59XG5mdW5jdGlvbiBkZWNvZGVCeXRlcyhjdXJzb3IsIHBhcmFtLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICBjb25zdCBbXywgc2l6ZV0gPSBwYXJhbS50eXBlLnNwbGl0KCdieXRlcycpO1xuICAgIGlmICghc2l6ZSkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICAgICAgcmV0dXJuIFsnMHgnLCAzMl07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW0hleC5mcm9tQnl0ZXMoZGF0YSksIDMyXTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBIZXguZnJvbUJ5dGVzKGN1cnNvci5yZWFkQnl0ZXMoTnVtYmVyLnBhcnNlSW50KHNpemUpLCAzMikpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbmZ1bmN0aW9uIGRlY29kZU51bWJlcihjdXJzb3IsIHBhcmFtKSB7XG4gICAgY29uc3Qgc2lnbmVkID0gcGFyYW0udHlwZS5zdGFydHNXaXRoKCdpbnQnKTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KHBhcmFtLnR5cGUuc3BsaXQoJ2ludCcpWzFdIHx8ICcyNTYnKTtcbiAgICBjb25zdCB2YWx1ZSA9IGN1cnNvci5yZWFkQnl0ZXMoMzIpO1xuICAgIHJldHVybiBbXG4gICAgICAgIHNpemUgPiA0OFxuICAgICAgICAgICAgPyBCeXRlcy50b0JpZ0ludCh2YWx1ZSwgeyBzaWduZWQgfSlcbiAgICAgICAgICAgIDogQnl0ZXMudG9OdW1iZXIodmFsdWUsIHsgc2lnbmVkIH0pLFxuICAgICAgICAzMixcbiAgICBdO1xufVxuZnVuY3Rpb24gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBzdGF0aWNQb3NpdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBoYXNVbm5hbWVkQ2hpbGQgPSBwYXJhbS5jb21wb25lbnRzLmxlbmd0aCA9PT0gMCB8fCBwYXJhbS5jb21wb25lbnRzLnNvbWUoKHsgbmFtZSB9KSA9PiAhbmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSBoYXNVbm5hbWVkQ2hpbGQgPyBbXSA6IHt9O1xuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgaWYgKGhhc0R5bmFtaWNDaGlsZChwYXJhbSkpIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbS5jb21wb25lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBwYXJhbS5jb21wb25lbnRzW2ldO1xuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0ICsgY29uc3VtZWQpO1xuICAgICAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgICAgICB2YWx1ZVtoYXNVbm5hbWVkQ2hpbGQgPyBpIDogY29tcG9uZW50Py5uYW1lXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW0uY29tcG9uZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjb21wb25lbnQgPSBwYXJhbS5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgICAgICB2YWx1ZVtoYXNVbm5hbWVkQ2hpbGQgPyBpIDogY29tcG9uZW50Py5uYW1lXSA9IGRhdGE7XG4gICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICB9XG4gICAgcmV0dXJuIFt2YWx1ZSwgY29uc3VtZWRdO1xufVxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIGNvbnN0IHN0YXJ0ID0gc3RhdGljUG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICBjb25zdCBsZW5ndGggPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbJycsIDMyXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoLCAzMik7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlcy50b1N0cmluZyhCeXRlcy50cmltTGVmdChkYXRhKSk7XG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXJzKHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXJzLCB2YWx1ZXMsIH0pIHtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtZXRlcnNbaV0sXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2ldLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBwcmVwYXJlZFBhcmFtZXRlcnM7XG59XG5mdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVyKHsgY2hlY2tzdW1BZGRyZXNzID0gZmFsc2UsIHBhcmFtZXRlcjogcGFyYW1ldGVyXywgdmFsdWUsIH0pIHtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJfO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbWV0ZXIudHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cykge1xuICAgICAgICBjb25zdCBbbGVuZ3RoLCB0eXBlXSA9IGFycmF5Q29tcG9uZW50cztcbiAgICAgICAgcmV0dXJuIGVuY29kZUFycmF5KHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBsZW5ndGgsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVR1cGxlKHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtZXRlcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVBZGRyZXNzKHZhbHVlLCB7XG4gICAgICAgICAgICBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgndWludCcpIHx8IHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpKSB7XG4gICAgICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2ludCcpO1xuICAgICAgICBjb25zdCBbLCAsIHNpemUgPSAnMjU2J10gPSBTb2xpZGl0eV9qc18xLmludGVnZXJSZWdleC5leGVjKHBhcmFtZXRlci50eXBlKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKHNpemUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGU6IHBhcmFtZXRlci50eXBlIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtZXRlci50eXBlKTtcbn1cbmZ1bmN0aW9uIGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpIHtcbiAgICBsZXQgc3RhdGljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSAzMjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc3RhdGljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhdGljUGFyYW1ldGVycyA9IFtdO1xuICAgIGNvbnN0IGR5bmFtaWNQYXJhbWV0ZXJzID0gW107XG4gICAgbGV0IGR5bmFtaWNTaXplID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGR5bmFtaWMsIGVuY29kZWQgfSA9IHByZXBhcmVkUGFyYW1ldGVyc1tpXTtcbiAgICAgICAgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChIZXguZnJvbU51bWJlcihzdGF0aWNTaXplICsgZHluYW1pY1NpemUsIHsgc2l6ZTogMzIgfSkpO1xuICAgICAgICAgICAgZHluYW1pY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgICAgIGR5bmFtaWNTaXplICs9IEhleC5zaXplKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGljUGFyYW1ldGVycy5wdXNoKGVuY29kZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBIZXguY29uY2F0KC4uLnN0YXRpY1BhcmFtZXRlcnMsIC4uLmR5bmFtaWNQYXJhbWV0ZXJzKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFkZHJlc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgQWRkcmVzcy5hc3NlcnQodmFsdWUsIHsgc3RyaWN0OiBjaGVja3N1bSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LnBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGVuY29kZUFycmF5KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgcGFyYW1ldGVyIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGR5bmFtaWMgPSBsZW5ndGggPT09IG51bGw7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuSW52YWxpZEFycmF5RXJyb3IodmFsdWUpO1xuICAgIGlmICghZHluYW1pYyAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBsZW5ndGgsXG4gICAgICAgICAgICBnaXZlbkxlbmd0aDogdmFsdWUubGVuZ3RoLFxuICAgICAgICAgICAgdHlwZTogYCR7cGFyYW1ldGVyLnR5cGV9WyR7bGVuZ3RofV1gLFxuICAgICAgICB9KTtcbiAgICBsZXQgZHluYW1pY0NoaWxkID0gZmFsc2U7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVbaV0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJlcGFyZWRQYXJhbS5keW5hbWljKVxuICAgICAgICAgICAgZHluYW1pY0NoaWxkID0gdHJ1ZTtcbiAgICAgICAgcHJlcGFyZWRQYXJhbWV0ZXJzLnB1c2gocHJlcGFyZWRQYXJhbSk7XG4gICAgfVxuICAgIGlmIChkeW5hbWljIHx8IGR5bmFtaWNDaGlsZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZW5jb2RlKHByZXBhcmVkUGFyYW1ldGVycyk7XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBIZXguZnJvbU51bWJlcihwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoLCB7IHNpemU6IDMyIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgICAgIGVuY29kZWQ6IHByZXBhcmVkUGFyYW1ldGVycy5sZW5ndGggPiAwID8gSGV4LmNvbmNhdChsZW5ndGgsIGRhdGEpIDogbGVuZ3RoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZHluYW1pY0NoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIHsgZHluYW1pYzogdHJ1ZSwgZW5jb2RlZDogZGF0YSB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdCguLi5wcmVwYXJlZFBhcmFtZXRlcnMubWFwKCh7IGVuY29kZWQgfSkgPT4gZW5jb2RlZCkpLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVCeXRlcyh2YWx1ZSwgeyB0eXBlIH0pIHtcbiAgICBjb25zdCBbLCBwYXJhbWV0ZXJzaXplXSA9IHR5cGUuc3BsaXQoJ2J5dGVzJyk7XG4gICAgY29uc3QgYnl0ZXNTaXplID0gSGV4LnNpemUodmFsdWUpO1xuICAgIGlmICghcGFyYW1ldGVyc2l6ZSkge1xuICAgICAgICBsZXQgdmFsdWVfID0gdmFsdWU7XG4gICAgICAgIGlmIChieXRlc1NpemUgJSAzMiAhPT0gMClcbiAgICAgICAgICAgIHZhbHVlXyA9IEhleC5wYWRSaWdodCh2YWx1ZV8sIE1hdGguY2VpbCgodmFsdWUubGVuZ3RoIC0gMikgLyAyIC8gMzIpICogMzIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoSGV4LnBhZExlZnQoSGV4LmZyb21OdW1iZXIoYnl0ZXNTaXplLCB7IHNpemU6IDMyIH0pKSwgdmFsdWVfKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGJ5dGVzU2l6ZSAhPT0gTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUpKVxuICAgICAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHBhcmFtZXRlcnNpemUpLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkUmlnaHQodmFsdWUpIH07XG59XG5mdW5jdGlvbiBlbmNvZGVCb29sZWFuKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlOiBcIiR7dmFsdWV9XCIgKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkuIEV4cGVjdGVkOiBcXGB0cnVlXFxgIG9yIFxcYGZhbHNlXFxgLmApO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpKSB9O1xufVxuZnVuY3Rpb24gZW5jb2RlTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCwgc2l6ZSB9KSB7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25zdCBtYXggPSAybiAqKiAoQmlnSW50KHNpemUpIC0gKHNpZ25lZCA/IDFuIDogMG4pKSAtIDFuO1xuICAgICAgICBjb25zdCBtaW4gPSBzaWduZWQgPyAtbWF4IC0gMW4gOiAwbjtcbiAgICAgICAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEhleC5JbnRlZ2VyT3V0T2ZSYW5nZUVycm9yKHtcbiAgICAgICAgICAgICAgICBtYXg6IG1heC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIG1pbjogbWluLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgICAgIHNpemU6IHNpemUgLyA4LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS50b1N0cmluZygpLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGR5bmFtaWM6IGZhbHNlLFxuICAgICAgICBlbmNvZGVkOiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2l6ZTogMzIsXG4gICAgICAgICAgICBzaWduZWQsXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVTdHJpbmcodmFsdWUpIHtcbiAgICBjb25zdCBoZXhWYWx1ZSA9IEhleC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICBjb25zdCBwYXJ0c0xlbmd0aCA9IE1hdGguY2VpbChIZXguc2l6ZShoZXhWYWx1ZSkgLyAzMik7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcGFydHMucHVzaChIZXgucGFkUmlnaHQoSGV4LnNsaWNlKGhleFZhbHVlLCBpICogMzIsIChpICsgMSkgKiAzMikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkUmlnaHQoSGV4LmZyb21OdW1iZXIoSGV4LnNpemUoaGV4VmFsdWUpLCB7IHNpemU6IDMyIH0pKSwgLi4ucGFydHMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBlbmNvZGVUdXBsZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlci5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtXyA9IHBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gaSA6IHBhcmFtXy5uYW1lO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtXyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpbmRleF0sXG4gICAgICAgIH0pO1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljLFxuICAgICAgICBlbmNvZGVkOiBkeW5hbWljXG4gICAgICAgICAgICA/IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICA6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0QXJyYXlDb21wb25lbnRzKHR5cGUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gdHlwZS5tYXRjaCgvXiguKilcXFsoXFxkKyk/XFxdJC8pO1xuICAgIHJldHVybiBtYXRjaGVzXG4gICAgICAgID9cbiAgICAgICAgICAgIFttYXRjaGVzWzJdID8gTnVtYmVyKG1hdGNoZXNbMl0pIDogbnVsbCwgbWF0Y2hlc1sxXV1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBoYXNEeW5hbWljQ2hpbGQocGFyYW0pIHtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHBhcmFtO1xuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdieXRlcycpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlLmVuZHNXaXRoKCdbXScpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3R1cGxlJylcbiAgICAgICAgcmV0dXJuIHBhcmFtLmNvbXBvbmVudHM/LnNvbWUoaGFzRHluYW1pY0NoaWxkKTtcbiAgICBjb25zdCBhcnJheUNvbXBvbmVudHMgPSBnZXRBcnJheUNvbXBvbmVudHMocGFyYW0udHlwZSk7XG4gICAgaWYgKGFycmF5Q29tcG9uZW50cyAmJlxuICAgICAgICBoYXNEeW5hbWljQ2hpbGQoe1xuICAgICAgICAgICAgLi4ucGFyYW0sXG4gICAgICAgICAgICB0eXBlOiBhcnJheUNvbXBvbmVudHNbMV0sXG4gICAgICAgIH0pKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlQYXJhbWV0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/bytes.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.charCodeMap = void 0;\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.charCodeToBase16 = charCodeToBase16;\nexports.pad = pad;\nexports.trim = trim;\nconst Bytes = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Bytes.js\");\nfunction assertSize(bytes, size_) {\n    if (Bytes.size(bytes) > size_)\n        throw new Bytes.SizeOverflowError({\n            givenSize: Bytes.size(bytes),\n            maxSize: size_,\n        });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Bytes.size(value) - 1)\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Bytes.size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Bytes.size(value) !== end - start) {\n        throw new Bytes.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Bytes.size(value),\n        });\n    }\n}\nexports.charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\nfunction charCodeToBase16(char) {\n    if (char >= exports.charCodeMap.zero && char <= exports.charCodeMap.nine)\n        return char - exports.charCodeMap.zero;\n    if (char >= exports.charCodeMap.A && char <= exports.charCodeMap.F)\n        return char - (exports.charCodeMap.A - 10);\n    if (char >= exports.charCodeMap.a && char <= exports.charCodeMap.f)\n        return char - (exports.charCodeMap.a - 10);\n    return undefined;\n}\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new Bytes.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCLFdBQVc7QUFDWCxZQUFZO0FBQ1osY0FBYyxtQkFBTyxDQUFDLG1FQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcaW50ZXJuYWxcXGJ5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFyQ29kZU1hcCA9IHZvaWQgMDtcbmV4cG9ydHMuYXNzZXJ0U2l6ZSA9IGFzc2VydFNpemU7XG5leHBvcnRzLmFzc2VydFN0YXJ0T2Zmc2V0ID0gYXNzZXJ0U3RhcnRPZmZzZXQ7XG5leHBvcnRzLmFzc2VydEVuZE9mZnNldCA9IGFzc2VydEVuZE9mZnNldDtcbmV4cG9ydHMuY2hhckNvZGVUb0Jhc2UxNiA9IGNoYXJDb2RlVG9CYXNlMTY7XG5leHBvcnRzLnBhZCA9IHBhZDtcbmV4cG9ydHMudHJpbSA9IHRyaW07XG5jb25zdCBCeXRlcyA9IHJlcXVpcmUoXCIuLi9CeXRlcy5qc1wiKTtcbmZ1bmN0aW9uIGFzc2VydFNpemUoYnl0ZXMsIHNpemVfKSB7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEJ5dGVzLnNpemUoYnl0ZXMpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RhcnRPZmZzZXQodmFsdWUsIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPiAwICYmIHN0YXJ0ID4gQnl0ZXMuc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEJ5dGVzLnNpemUodmFsdWUpLFxuICAgICAgICB9KTtcbn1cbmZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEJ5dGVzLnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hhckNvZGVNYXAgPSB7XG4gICAgemVybzogNDgsXG4gICAgbmluZTogNTcsXG4gICAgQTogNjUsXG4gICAgRjogNzAsXG4gICAgYTogOTcsXG4gICAgZjogMTAyLFxufTtcbmZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGV4cG9ydHMuY2hhckNvZGVNYXAuemVybyAmJiBjaGFyIDw9IGV4cG9ydHMuY2hhckNvZGVNYXAubmluZSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBleHBvcnRzLmNoYXJDb2RlTWFwLnplcm87XG4gICAgaWYgKGNoYXIgPj0gZXhwb3J0cy5jaGFyQ29kZU1hcC5BICYmIGNoYXIgPD0gZXhwb3J0cy5jaGFyQ29kZU1hcC5GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChleHBvcnRzLmNoYXJDb2RlTWFwLkEgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gZXhwb3J0cy5jaGFyQ29kZU1hcC5hICYmIGNoYXIgPD0gZXhwb3J0cy5jaGFyQ29kZU1hcC5mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChleHBvcnRzLmNoYXJDb2RlTWFwLmEgLSAxMCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHBhZChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIsIHNpemUgPSAzMiB9ID0gb3B0aW9ucztcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIGlmIChieXRlcy5sZW5ndGggPiBzaXplKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IGJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnQnl0ZXMnLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhZEVuZCA9IGRpciA9PT0gJ3JpZ2h0JztcbiAgICAgICAgcGFkZGVkQnl0ZXNbcGFkRW5kID8gaSA6IHNpemUgLSBpIC0gMV0gPVxuICAgICAgICAgICAgYnl0ZXNbcGFkRW5kID8gaSA6IGJ5dGVzLmxlbmd0aCAtIGkgLSAxXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufVxuZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/cursor.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/cursor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RecursiveReadLimitExceededError = exports.PositionOutOfBoundsError = exports.NegativeOffsetError = void 0;\nexports.create = create;\nconst Errors = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Errors.js\");\nconst staticCursor = {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\nclass NegativeOffsetError extends Errors.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\nexports.NegativeOffsetError = NegativeOffsetError;\nclass PositionOutOfBoundsError extends Errors.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\nexports.PositionOutOfBoundsError = PositionOutOfBoundsError;\nclass RecursiveReadLimitExceededError extends Errors.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\nexports.RecursiveReadLimitExceededError = RecursiveReadLimitExceededError;\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9jdXJzb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUNBQXVDLEdBQUcsZ0NBQWdDLEdBQUcsMkJBQTJCO0FBQ3hHLGNBQWM7QUFDZCxlQUFlLG1CQUFPLENBQUMscUVBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCLDZCQUE2QixJQUFJO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQiwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDLDRCQUE0QixTQUFTLHdDQUF3QyxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGtCQUFrQixjQUFjO0FBQ2hDLDJDQUEyQyxNQUFNLHVDQUF1QyxNQUFNO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcaW50ZXJuYWxcXGN1cnNvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVjdXJzaXZlUmVhZExpbWl0RXhjZWVkZWRFcnJvciA9IGV4cG9ydHMuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yID0gZXhwb3J0cy5OZWdhdGl2ZU9mZnNldEVycm9yID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKFwiLi4vRXJyb3JzLmpzXCIpO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0ge1xuICAgIGJ5dGVzOiBuZXcgVWludDhBcnJheSgpLFxuICAgIGRhdGFWaWV3OiBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDApKSxcbiAgICBwb3NpdGlvbjogMCxcbiAgICBwb3NpdGlvblJlYWRDb3VudDogbmV3IE1hcCgpLFxuICAgIHJlY3Vyc2l2ZVJlYWRDb3VudDogMCxcbiAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICBhc3NlcnRSZWFkTGltaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCA+PSB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdClcbiAgICAgICAgICAgIHRocm93IG5ldyBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb3VudDogdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQgKyAxLFxuICAgICAgICAgICAgICAgIGxpbWl0OiB0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCxcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+IHRoaXMuYnl0ZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIHRocm93IG5ldyBQb3NpdGlvbk91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5ieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gLSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBnZXRSZWFkQ291bnQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb25SZWFkQ291bnQuZ2V0KHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pIHx8IDA7XG4gICAgfSxcbiAgICBpbmNyZW1lbnRQb3NpdGlvbihvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgTmVnYXRpdmVPZmZzZXRFcnJvcih7IG9mZnNldCB9KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgIH0sXG4gICAgaW5zcGVjdEJ5dGUocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZXMobGVuZ3RoLCBwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIGxlbmd0aCAtIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5zdWJhcnJheShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQ4KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXNbcG9zaXRpb25dO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQxNihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MTYocG9zaXRpb24pO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQyNChwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDIpO1xuICAgICAgICByZXR1cm4gKCh0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbikgPDwgOCkgK1xuICAgICAgICAgICAgdGhpcy5kYXRhVmlldy5nZXRVaW50OChwb3NpdGlvbiArIDIpKTtcbiAgICB9LFxuICAgIGluc3BlY3RVaW50MzIocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24gKyAzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVZpZXcuZ2V0VWludDMyKHBvc2l0aW9uKTtcbiAgICB9LFxuICAgIHB1c2hCeXRlKGJ5dGUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5ieXRlc1t0aGlzLnBvc2l0aW9uXSA9IGJ5dGU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hCeXRlcyhieXRlcykge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyBieXRlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5ieXRlcy5zZXQoYnl0ZXMsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IGJ5dGVzLmxlbmd0aDtcbiAgICB9LFxuICAgIHB1c2hVaW50OCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIHRoaXMucG9zaXRpb24rKztcbiAgICB9LFxuICAgIHB1c2hVaW50MTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMSk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDE2KHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgIH0sXG4gICAgcHVzaFVpbnQyNCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAyKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUgPj4gOCk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5wb3NpdGlvbiArIDIsIHZhbHVlICYgfjQyOTQ5NjcwNDApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgfSxcbiAgICBwdXNoVWludDMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDMpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQzMih0aGlzLnBvc2l0aW9uLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICB9LFxuICAgIHJlYWRCeXRlKCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdEJ5dGUoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkQnl0ZXMobGVuZ3RoLCBzaXplKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSBzaXplID8/IGxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQ4KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQ4KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQxNigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MTYoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDI0KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQyNCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDM7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MzIoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDMyKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMubGVuZ3RoIC0gdGhpcy5wb3NpdGlvbjtcbiAgICB9LFxuICAgIHNldFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG9sZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLnBvc2l0aW9uID0gb2xkUG9zaXRpb24pO1xuICAgIH0sXG4gICAgX3RvdWNoKCkge1xuICAgICAgICBpZiAodGhpcy5yZWN1cnNpdmVSZWFkTGltaXQgPT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldFJlYWRDb3VudCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uUmVhZENvdW50LnNldCh0aGlzLnBvc2l0aW9uLCBjb3VudCArIDEpO1xuICAgICAgICBpZiAoY291bnQgPiAwKVxuICAgICAgICAgICAgdGhpcy5yZWN1cnNpdmVSZWFkQ291bnQrKztcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGNyZWF0ZShieXRlcywgeyByZWN1cnNpdmVSZWFkTGltaXQgPSA4XzE5MiB9ID0ge30pIHtcbiAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuY3JlYXRlKHN0YXRpY0N1cnNvcik7XG4gICAgY3Vyc29yLmJ5dGVzID0gYnl0ZXM7XG4gICAgY3Vyc29yLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgY3Vyc29yLnBvc2l0aW9uUmVhZENvdW50ID0gbmV3IE1hcCgpO1xuICAgIGN1cnNvci5yZWN1cnNpdmVSZWFkTGltaXQgPSByZWN1cnNpdmVSZWFkTGltaXQ7XG4gICAgcmV0dXJuIGN1cnNvcjtcbn1cbmNsYXNzIE5lZ2F0aXZlT2Zmc2V0RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCB9KSB7XG4gICAgICAgIHN1cGVyKGBPZmZzZXQgXFxgJHtvZmZzZXR9XFxgIGNhbm5vdCBiZSBuZWdhdGl2ZS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5OZWdhdGl2ZU9mZnNldEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk5lZ2F0aXZlT2Zmc2V0RXJyb3IgPSBOZWdhdGl2ZU9mZnNldEVycm9yO1xuY2xhc3MgUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBsZW5ndGgsIHBvc2l0aW9uIH0pIHtcbiAgICAgICAgc3VwZXIoYFBvc2l0aW9uIFxcYCR7cG9zaXRpb259XFxgIGlzIG91dCBvZiBib3VuZHMgKFxcYDAgPCBwb3NpdGlvbiA8ICR7bGVuZ3RofVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuUG9zaXRpb25PdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciA9IFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcjtcbmNsYXNzIFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvdW50LCBsaW1pdCB9KSB7XG4gICAgICAgIHN1cGVyKGBSZWN1cnNpdmUgcmVhZCBsaW1pdCBvZiBcXGAke2xpbWl0fVxcYCBleGNlZWRlZCAocmVjdXJzaXZlIHJlYWQgY291bnQ6IFxcYCR7Y291bnR9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5SZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgPSBSZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Vyc29yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/errors.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getUrl = getUrl;\nexports.getVersion = getVersion;\nexports.prettyPrint = prettyPrint;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(ssr)/../../node_modules/ox/_cjs/core/version.js\");\nfunction getUrl(url) {\n    return url;\n}\nfunction getVersion() {\n    return version_js_1.version;\n}\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCLG1CQUFPLENBQUMsdUVBQWU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRyxJQUFJLDJCQUEyQixFQUFFLE1BQU07QUFDOUU7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfY2pzXFxjb3JlXFxpbnRlcm5hbFxcZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG5leHBvcnRzLmdldFZlcnNpb24gPSBnZXRWZXJzaW9uO1xuZXhwb3J0cy5wcmV0dHlQcmludCA9IHByZXR0eVByaW50O1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uL3ZlcnNpb24uanNcIik7XG5mdW5jdGlvbiBnZXRVcmwodXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbn1cbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnNpb25fanNfMS52ZXJzaW9uO1xufVxuZnVuY3Rpb24gcHJldHR5UHJpbnQoYXJncykge1xuICAgIGlmICghYXJncylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBba2V5XSkgPT4gTWF0aC5tYXgoYWNjLCBrZXkubGVuZ3RoKSwgMCk7XG4gICAgcmV0dXJuIGVudHJpZXNcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgICAke2Ake2tleX06YC5wYWRFbmQobWF4TGVuZ3RoICsgMSl9ICAke3ZhbHVlfWApXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/hex.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/hex.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.assertSize = assertSize;\nexports.assertStartOffset = assertStartOffset;\nexports.assertEndOffset = assertEndOffset;\nexports.pad = pad;\nexports.trim = trim;\nconst Hex = __webpack_require__(/*! ../Hex.js */ \"(ssr)/../../node_modules/ox/_cjs/core/Hex.js\");\nfunction assertSize(hex, size_) {\n    if (Hex.size(hex) > size_)\n        throw new Hex.SizeOverflowError({\n            givenSize: Hex.size(hex),\n            maxSize: size_,\n        });\n}\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > Hex.size(value) - 1)\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: Hex.size(value),\n        });\n}\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        Hex.size(value) !== end - start) {\n        throw new Hex.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: Hex.size(value),\n        });\n    }\n}\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new Hex.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9oZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsV0FBVztBQUNYLFlBQVk7QUFDWixZQUFZLG1CQUFPLENBQUMsK0RBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQSxpQ0FBaUM7QUFDakMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixLQUFLO0FBQ3pCLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXGludGVybmFsXFxoZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFzc2VydFNpemUgPSBhc3NlcnRTaXplO1xuZXhwb3J0cy5hc3NlcnRTdGFydE9mZnNldCA9IGFzc2VydFN0YXJ0T2Zmc2V0O1xuZXhwb3J0cy5hc3NlcnRFbmRPZmZzZXQgPSBhc3NlcnRFbmRPZmZzZXQ7XG5leHBvcnRzLnBhZCA9IHBhZDtcbmV4cG9ydHMudHJpbSA9IHRyaW07XG5jb25zdCBIZXggPSByZXF1aXJlKFwiLi4vSGV4LmpzXCIpO1xuZnVuY3Rpb24gYXNzZXJ0U2l6ZShoZXgsIHNpemVfKSB7XG4gICAgaWYgKEhleC5zaXplKGhleCkgPiBzaXplXylcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplT3ZlcmZsb3dFcnJvcih7XG4gICAgICAgICAgICBnaXZlblNpemU6IEhleC5zaXplKGhleCksXG4gICAgICAgICAgICBtYXhTaXplOiBzaXplXyxcbiAgICAgICAgfSk7XG59XG5mdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBIZXguc2l6ZSh2YWx1ZSkgLSAxKVxuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IHN0YXJ0LFxuICAgICAgICAgICAgcG9zaXRpb246ICdzdGFydCcsXG4gICAgICAgICAgICBzaXplOiBIZXguc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgSGV4LnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IGVuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFkKGhleF8sIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBoZXhfO1xuICAgIGNvbnN0IGhleCA9IGhleF8ucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgaWYgKGhleC5sZW5ndGggPiBzaXplICogMilcbiAgICAgICAgdGhyb3cgbmV3IEhleC5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3Ioe1xuICAgICAgICAgICAgc2l6ZTogTWF0aC5jZWlsKGhleC5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIHRhcmdldFNpemU6IHNpemUsXG4gICAgICAgICAgICB0eXBlOiAnSGV4JyxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIGAweCR7aGV4W2RpciA9PT0gJ3JpZ2h0JyA/ICdwYWRFbmQnIDogJ3BhZFN0YXJ0J10oc2l6ZSAqIDIsICcwJyl9YDtcbn1cbmZ1bmN0aW9uIHRyaW0odmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyID0gJ2xlZnQnIH0gPSBvcHRpb25zO1xuICAgIGxldCBkYXRhID0gdmFsdWUucmVwbGFjZSgnMHgnLCAnJyk7XG4gICAgbGV0IHNsaWNlTGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGlmIChkYXRhW2RpciA9PT0gJ2xlZnQnID8gaSA6IGRhdGEubGVuZ3RoIC0gaSAtIDFdLnRvU3RyaW5nKCkgPT09ICcwJylcbiAgICAgICAgICAgIHNsaWNlTGVuZ3RoKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXRhID1cbiAgICAgICAgZGlyID09PSAnbGVmdCdcbiAgICAgICAgICAgID8gZGF0YS5zbGljZShzbGljZUxlbmd0aClcbiAgICAgICAgICAgIDogZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIHNsaWNlTGVuZ3RoKTtcbiAgICBpZiAoZGF0YSA9PT0gJzAnKVxuICAgICAgICByZXR1cm4gJzB4JztcbiAgICBpZiAoZGlyID09PSAncmlnaHQnICYmIGRhdGEubGVuZ3RoICUgMiA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGAweCR7ZGF0YX0wYDtcbiAgICByZXR1cm4gYDB4JHtkYXRhfWA7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/internal/lru.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/internal/lru.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LruMap = void 0;\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\nexports.LruMap = LruMap;\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS9pbnRlcm5hbC9scnUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2Nqc1xcY29yZVxcaW50ZXJuYWxcXGxydS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTHJ1TWFwID0gdm9pZCAwO1xuY2xhc3MgTHJ1TWFwIGV4dGVuZHMgTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1heFNpemVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tYXhTaXplID0gc2l6ZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN1cGVyLmdldChrZXkpO1xuICAgICAgICBpZiAoc3VwZXIuaGFzKGtleSkgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMubWF4U2l6ZSAmJiB0aGlzLnNpemUgPiB0aGlzLm1heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0S2V5ID0gdGhpcy5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGZpcnN0S2V5KVxuICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlKGZpcnN0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkxydU1hcCA9IExydU1hcDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxydS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_cjs/core/version.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_cjs/core/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\nexports.version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19janMvY29yZS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9janNcXGNvcmVcXHZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5leHBvcnRzLnZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_cjs/core/version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/AbiConstructor.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/AbiConstructor.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/../../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/../../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/** @internal */\nfunction decode(abiConstructor, options) {\n    const { bytecode } = options;\n    if (abiConstructor.inputs.length === 0)\n        return undefined;\n    const data = options.data.replace(bytecode, '0x');\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.decode(abiConstructor.inputs, data);\n}\n/**\n * ABI-encodes the provided constructor input (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiConstructor } from 'ox'\n *\n * const constructor = AbiConstructor.from('constructor(address, uint256)')\n *\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiConstructor.encode` to encode the constructor of a contract and deploy it.\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { AbiConstructor, Hex } from 'ox'\n *\n * // 1. Instantiate the ABI Constructor.\n * const constructor = AbiConstructor.from(\n *   'constructor(address owner, uint256 amount)',\n * )\n *\n * // 2. Encode the ABI Constructor.\n * const data = AbiConstructor.encode(constructor, {\n *   bytecode: '0x...',\n *   args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 123n],\n * })\n *\n * // 3. Deploy the contract.\n * const hash = await window.ethereum!.request({\n *   method: 'eth_sendTransaction',\n *   params: [{ data }],\n * })\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiConstructor - The ABI Constructor to encode.\n * @param options - Encoding options.\n * @returns The encoded constructor.\n */\nfunction encode(abiConstructor, options) {\n    const { bytecode, args } = options;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(bytecode, abiConstructor.inputs?.length && args?.length\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.encode(abiConstructor.inputs, args)\n        : '0x');\n}\n/** @internal */\nfunction format(abiConstructor) {\n    return abitype__WEBPACK_IMPORTED_MODULE_2__.formatAbiItem(abiConstructor);\n}\n/** @internal */\nfunction from(abiConstructor) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.from(abiConstructor);\n}\n/** @internal */\nfunction fromAbi(abi) {\n    const item = abi.find((item) => item.type === 'constructor');\n    if (!item)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_3__.NotFoundError({ name: 'constructor' });\n    return item;\n}\n//# sourceMappingURL=AbiConstructor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlDb25zdHJ1Y3Rvci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNZO0FBQ3BCO0FBQ2hDO0FBQ087QUFDUCxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxREFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLGlCQUFpQjtBQUM3QixXQUFXLDJDQUFVO0FBQ3JCLFVBQVUscURBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxrREFBcUI7QUFDaEM7QUFDQTtBQUNPO0FBQ1AsV0FBVyw2Q0FBWTtBQUN2QjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFxQixHQUFHLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEFiaUNvbnN0cnVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBYmlJdGVtIGZyb20gJy4vQWJpSXRlbS5qcyc7XG5pbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4vQWJpUGFyYW1ldGVycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShhYmlDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKGFiaUNvbnN0cnVjdG9yLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YS5yZXBsYWNlKGJ5dGVjb2RlLCAnMHgnKTtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoYWJpQ29uc3RydWN0b3IuaW5wdXRzLCBkYXRhKTtcbn1cbi8qKlxuICogQUJJLWVuY29kZXMgdGhlIHByb3ZpZGVkIGNvbnN0cnVjdG9yIGlucHV0IChgaW5wdXRzYCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlDb25zdHJ1Y3RvciB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGNvbnN0cnVjdG9yID0gQWJpQ29uc3RydWN0b3IuZnJvbSgnY29uc3RydWN0b3IoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlDb25zdHJ1Y3Rvci5lbmNvZGUoY29uc3RydWN0b3IsIHtcbiAqICAgYnl0ZWNvZGU6ICcweC4uLicsXG4gKiAgIGFyZ3M6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgMTIzbl0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlDb25zdHJ1Y3Rvci5lbmNvZGVgIHRvIGVuY29kZSB0aGUgY29uc3RydWN0b3Igb2YgYSBjb250cmFjdCBhbmQgZGVwbG95IGl0LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaUNvbnN0cnVjdG9yLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBJbnN0YW50aWF0ZSB0aGUgQUJJIENvbnN0cnVjdG9yLlxuICogY29uc3QgY29uc3RydWN0b3IgPSBBYmlDb25zdHJ1Y3Rvci5mcm9tKFxuICogICAnY29uc3RydWN0b3IoYWRkcmVzcyBvd25lciwgdWludDI1NiBhbW91bnQpJyxcbiAqIClcbiAqXG4gKiAvLyAyLiBFbmNvZGUgdGhlIEFCSSBDb25zdHJ1Y3Rvci5cbiAqIGNvbnN0IGRhdGEgPSBBYmlDb25zdHJ1Y3Rvci5lbmNvZGUoY29uc3RydWN0b3IsIHtcbiAqICAgYnl0ZWNvZGU6ICcweC4uLicsXG4gKiAgIGFyZ3M6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgMTIzbl0sXG4gKiB9KVxuICpcbiAqIC8vIDMuIERlcGxveSB0aGUgY29udHJhY3QuXG4gKiBjb25zdCBoYXNoID0gYXdhaXQgd2luZG93LmV0aGVyZXVtIS5yZXF1ZXN0KHtcbiAqICAgbWV0aG9kOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gKiAgIHBhcmFtczogW3sgZGF0YSB9XSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRm9yIHNpbXBsaWNpdHksIHRoZSBhYm92ZSBleGFtcGxlIHVzZXMgYHdpbmRvdy5ldGhlcmV1bS5yZXF1ZXN0YCwgYnV0IHlvdSBjYW4gdXNlIGFueVxuICogdHlwZSBvZiBKU09OLVJQQyBpbnRlcmZhY2UuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaUNvbnN0cnVjdG9yIC0gVGhlIEFCSSBDb25zdHJ1Y3RvciB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBjb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShhYmlDb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYnl0ZWNvZGUsIGFyZ3MgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhleC5jb25jYXQoYnl0ZWNvZGUsIGFiaUNvbnN0cnVjdG9yLmlucHV0cz8ubGVuZ3RoICYmIGFyZ3M/Lmxlbmd0aFxuICAgICAgICA/IEFiaVBhcmFtZXRlcnMuZW5jb2RlKGFiaUNvbnN0cnVjdG9yLmlucHV0cywgYXJncylcbiAgICAgICAgOiAnMHgnKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXQoYWJpQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gYWJpdHlwZS5mb3JtYXRBYmlJdGVtKGFiaUNvbnN0cnVjdG9yKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZnJvbShhYmlDb25zdHJ1Y3Rvcik7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFiaShhYmkpIHtcbiAgICBjb25zdCBpdGVtID0gYWJpLmZpbmQoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyk7XG4gICAgaWYgKCFpdGVtKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZTogJ2NvbnN0cnVjdG9yJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUNvbnN0cnVjdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/AbiConstructor.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/AbiFunction.js":
/*!******************************************************!*\
  !*** ../../node_modules/ox/_esm/core/AbiFunction.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeData: () => (/* binding */ decodeData),\n/* harmony export */   decodeResult: () => (/* binding */ decodeResult),\n/* harmony export */   encodeData: () => (/* binding */ encodeData),\n/* harmony export */   encodeResult: () => (/* binding */ encodeResult),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AbiItem.js */ \"(ssr)/../../node_modules/ox/_esm/core/AbiItem.js\");\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AbiParameters.js */ \"(ssr)/../../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * ABI-decodes function arguments according to the ABI Item's input types (`inputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n *\n * const input = AbiFunction.decodeData(approve, data) // [!code focus]\n * // @log: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * ```\n *\n * @param abiFunction - The ABI Item to decode.\n * @param data - The data to decode.\n */\nfunction decodeData(abiFunction, data) {\n    const { overloads } = abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) < 4)\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSelectorSizeError({ data });\n    if (abiFunction.inputs.length === 0)\n        return undefined;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], data)\n        : abiFunction;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(data) <= 4)\n        return undefined;\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(item.inputs, _Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(data, 4));\n}\n/**\n * ABI-decodes a function's result according to the ABI Item's output types (`outputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function return values (e.g. the response of an `eth_call` or the `input` property of a Transaction).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const data = '0x000000000000000000000000000000000000000000000000000000000000002a'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const totalSupply = AbiFunction.fromAbi(erc20Abi, 'totalSupply') // [!code hl]\n *\n * const output = AbiFunction.decodeResult(totalSupply, data)\n * // @log: 42n\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.decodeResult` to decode the result of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   balanceOf,\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B']\n * )\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output. // [!code focus]\n * const balance = AbiFunction.decodeResult(balanceOf, response) // [!code focus]\n * // @log: 42n\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to decode\n * @param data - ABI-encoded function output\n * @param options - Decoding options\n * @returns Decoded function output\n */\nfunction decodeResult(abiFunction, data, options = {}) {\n    const values = _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.decode(abiFunction.outputs, data, options);\n    if (values && Object.keys(values).length === 0)\n        return undefined;\n    if (values && Object.keys(values).length === 1) {\n        if (Array.isArray(values))\n            return values[0];\n        return Object.values(values)[0];\n    }\n    return values;\n}\n/**\n * ABI-encodes function arguments (`inputs`), prefixed with the 4 byte function selector.\n *\n * :::tip\n *\n * This function is typically used to encode a contract function and its arguments for contract calls (e.g. `data` parameter of an `eth_call` or `eth_sendTransaction`).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from('function approve(address, uint256)')\n *\n * const data = AbiFunction.encodeData( // [!code focus]\n *   approve, // [!code focus]\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Function from a JSON ABI with {@link ox#AbiFunction.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const erc20Abi = Abi.from([...]) // [!code hl]\n * const approve = AbiFunction.fromAbi(erc20Abi, 'approve') // [!code hl]\n *\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiFunction.encodeData` to encode the input of a `balanceOf` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * import 'ox/window'\n * import { Abi, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     name: 'balanceOf',\n *     type: 'function',\n *     inputs: [{ name: 'account', type: 'address' }],\n *     outputs: [{ name: 'balance', type: 'uint256' }],\n *     stateMutability: 'view',\n *   },\n *   // ...\n * ])\n * const balanceOf = AbiFunction.fromAbi(abi, 'balanceOf')\n *\n * // 2. Encode the Function Input. // [!code focus]\n * const data = AbiFunction.encodeData( // [!code focus]\n *   balanceOf, // [!code focus]\n *   ['0xd2135CfB216b74109775236E36d4b433F1DF507B'] // [!code focus]\n * ) // [!code focus]\n *\n * // 3. Perform the Contract Call.\n * const response = await window.ethereum!.request({\n *   method: 'eth_call',\n *   params: [\n *     {\n *       data,\n *       to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *     },\n *   ],\n * })\n *\n * // 4. Decode the Function Output.\n * const balance = AbiFunction.decodeResult(balanceOf, response)\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiFunction - ABI Function to encode\n * @param args - Function arguments\n * @returns ABI-encoded function name and arguments\n */\nfunction encodeData(abiFunction, ...args) {\n    const { overloads } = abiFunction;\n    const item = overloads\n        ? fromAbi([abiFunction, ...overloads], abiFunction.name, {\n            args: args[0],\n        })\n        : abiFunction;\n    const selector = getSelector(item);\n    const data = args.length > 0\n        ? _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(item.inputs, args[0])\n        : undefined;\n    return data ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(selector, data) : selector;\n}\n/**\n * ABI-encodes a function's result (`outputs`).\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const totalSupply = AbiFunction.from('function totalSupply() returns (uint256)')\n * const output = AbiFunction.decodeResult(totalSupply, '0x000000000000000000000000000000000000000000000000000000000000002a')\n * // 42n\n *\n * const data = AbiFunction.encodeResult(totalSupply, 42n) // [!code focus]\n * // @log: '0x000000000000000000000000000000000000000000000000000000000000002a'\n * ```\n *\n * @param abiFunction - The ABI item to encode the function output for.\n * @param output - The function output to encode.\n * @param options - Encoding options.\n * @returns The encoded function output.\n */\nfunction encodeResult(abiFunction, output, options = {}) {\n    const { as = 'Array' } = options;\n    const values = (() => {\n        if (abiFunction.outputs.length === 1)\n            return [output];\n        if (Array.isArray(output))\n            return output;\n        if (as === 'Object')\n            return Object.values(output);\n        return [output];\n    })();\n    return _AbiParameters_js__WEBPACK_IMPORTED_MODULE_2__.encode(abiFunction.outputs, values);\n}\n/**\n * Formats an {@link ox#AbiFunction.AbiFunction} into a **Human Readable ABI Function**.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const formatted = AbiFunction.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiFunction - The ABI Function to format.\n * @returns The formatted ABI Function.\n */\nfunction format(abiFunction) {\n    return abitype__WEBPACK_IMPORTED_MODULE_3__.formatAbiItem(abiFunction);\n}\n/**\n * Parses an arbitrary **JSON ABI Function** or **Human Readable ABI Function** into a typed {@link ox#AbiFunction.AbiFunction}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const approve = AbiFunction.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * approve\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiFunction - The ABI Function to parse.\n * @returns Typed ABI Function.\n */\nfunction from(abiFunction, options = {}) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.from(abiFunction, options);\n}\n/**\n * Extracts an {@link ox#AbiFunction.AbiFunction} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Functions can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiFunction.fromAbi(abi, 'foo') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Functions can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiFunction.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Function from an `eth_call` RPC response or\n * from a Transaction `input`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const item = _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.fromAbi(abi, name, options);\n    if (item.type !== 'function')\n        throw new _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.NotFoundError({ name, type: 'function' });\n    return item;\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiFunction.AbiFunction}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiFunction } from 'ox'\n *\n * const selector = AbiFunction.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _AbiItem_js__WEBPACK_IMPORTED_MODULE_1__.getSelector(abiItem);\n}\n//# sourceMappingURL=AbiFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSztBQUNZO0FBQ3BCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVksWUFBWTtBQUN4QixRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixpRUFBZ0MsR0FBRyxNQUFNO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCO0FBQ0EsV0FBVyxxREFBb0IsY0FBYywwQ0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELHdDQUF3QztBQUNqRztBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELG1CQUFtQixrQ0FBa0M7QUFDckQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFD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eFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcQWJpRnVuY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEFiaUl0ZW0gZnJvbSAnLi9BYmlJdGVtLmpzJztcbmltcG9ydCAqIGFzIEFiaVBhcmFtZXRlcnMgZnJvbSAnLi9BYmlQYXJhbWV0ZXJzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIEFCSS1kZWNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyBhY2NvcmRpbmcgdG8gdGhlIEFCSSBJdGVtJ3MgaW5wdXQgdHlwZXMgKGBpbnB1dHNgKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcywgdWludDI1NiknKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKlxuICogY29uc3QgaW5wdXQgPSBBYmlGdW5jdGlvbi5kZWNvZGVEYXRhKGFwcHJvdmUsIGRhdGEpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUZ1bmN0aW9uIC0gVGhlIEFCSSBJdGVtIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgdG8gZGVjb2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlRGF0YShhYmlGdW5jdGlvbiwgZGF0YSkge1xuICAgIGNvbnN0IHsgb3ZlcmxvYWRzIH0gPSBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPCA0KVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IoeyBkYXRhIH0pO1xuICAgIGlmIChhYmlGdW5jdGlvbi5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgZGF0YSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBpZiAoSGV4LnNpemUoZGF0YSkgPD0gNClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICByZXR1cm4gQWJpUGFyYW1ldGVycy5kZWNvZGUoaXRlbS5pbnB1dHMsIEhleC5zbGljZShkYXRhLCA0KSk7XG59XG4vKipcbiAqIEFCSS1kZWNvZGVzIGEgZnVuY3Rpb24ncyByZXN1bHQgYWNjb3JkaW5nIHRvIHRoZSBBQkkgSXRlbSdzIG91dHB1dCB0eXBlcyAoYG91dHB1dHNgKS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHR5cGljYWxseSB1c2VkIHRvIGRlY29kZSBjb250cmFjdCBmdW5jdGlvbiByZXR1cm4gdmFsdWVzIChlLmcuIHRoZSByZXNwb25zZSBvZiBhbiBgZXRoX2NhbGxgIG9yIHRoZSBgaW5wdXRgIHByb3BlcnR5IG9mIGEgVHJhbnNhY3Rpb24pLlxuICpcbiAqIFNlZSB0aGUgW0VuZC10by1lbmQgRXhhbXBsZV0oI2VuZC10by1lbmQpLlxuICpcbiAqIDo6OlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIFlvdSBjYW4gZXh0cmFjdCBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhIEpTT04gQUJJIHdpdGgge0BsaW5rIG94I0FiaUZ1bmN0aW9uLihmcm9tQWJpOmZ1bmN0aW9uKX06XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJ1xuICpcbiAqIGNvbnN0IGVyYzIwQWJpID0gQWJpLmZyb20oWy4uLl0pIC8vIFshY29kZSBobF1cbiAqIGNvbnN0IHRvdGFsU3VwcGx5ID0gQWJpRnVuY3Rpb24uZnJvbUFiaShlcmMyMEFiaSwgJ3RvdGFsU3VwcGx5JykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IG91dHB1dCA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdCh0b3RhbFN1cHBseSwgZGF0YSlcbiAqIC8vIEBsb2c6IDQyblxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFbmQtdG8tZW5kXG4gKlxuICogQmVsb3cgaXMgYW4gZW5kLXRvLWVuZCBleGFtcGxlIG9mIHVzaW5nIGBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHRgIHRvIGRlY29kZSB0aGUgcmVzdWx0IG9mIGEgYGJhbGFuY2VPZmAgY29udHJhY3QgY2FsbCBvbiB0aGUgW1dhZ21pIE1pbnQgRXhhbXBsZSBjb250cmFjdF0oaHR0cHM6Ly9ldGhlcnNjYW4uaW8vYWRkcmVzcy8weGZiYTM5MTJjYTA0ZGQ0NThjODQzZTJlZTA4OTY3ZmMwNGYzNTc5YzIpLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgJ294L3dpbmRvdydcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiAvLyAxLiBFeHRyYWN0IHRoZSBGdW5jdGlvbiBmcm9tIHRoZSBDb250cmFjdCdzIEFCSS5cbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgLy8gLi4uXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnYmFsYW5jZU9mJyxcbiAqICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICogICAgIGlucHV0czogW3sgbmFtZTogJ2FjY291bnQnLCB0eXBlOiAnYWRkcmVzcycgfV0sXG4gKiAgICAgb3V0cHV0czogW3sgbmFtZTogJ2JhbGFuY2UnLCB0eXBlOiAndWludDI1NicgfV0sXG4gKiAgICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiAgIH0sXG4gKiAgIC8vIC4uLlxuICogXSlcbiAqIGNvbnN0IGJhbGFuY2VPZiA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnYmFsYW5jZU9mJylcbiAqXG4gKiAvLyAyLiBFbmNvZGUgdGhlIEZ1bmN0aW9uIElucHV0LlxuICogY29uc3QgZGF0YSA9IEFiaUZ1bmN0aW9uLmVuY29kZURhdGEoXG4gKiAgIGJhbGFuY2VPZixcbiAqICAgWycweGQyMTM1Q2ZCMjE2Yjc0MTA5Nzc1MjM2RTM2ZDRiNDMzRjFERjUwN0InXVxuICogKVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC4gLy8gWyFjb2RlIGZvY3VzXVxuICogY29uc3QgYmFsYW5jZSA9IEFiaUZ1bmN0aW9uLmRlY29kZVJlc3VsdChiYWxhbmNlT2YsIHJlc3BvbnNlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiA0Mm5cbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZGVjb2RlXG4gKiBAcGFyYW0gZGF0YSAtIEFCSS1lbmNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zXG4gKiBAcmV0dXJucyBEZWNvZGVkIGZ1bmN0aW9uIG91dHB1dFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmVzdWx0KGFiaUZ1bmN0aW9uLCBkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBBYmlQYXJhbWV0ZXJzLmRlY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCBkYXRhLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWVzICYmIE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGlmICh2YWx1ZXMgJiYgT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbMF07XG4gICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHZhbHVlcylbMF07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG4vKipcbiAqIEFCSS1lbmNvZGVzIGZ1bmN0aW9uIGFyZ3VtZW50cyAoYGlucHV0c2ApLCBwcmVmaXhlZCB3aXRoIHRoZSA0IGJ5dGUgZnVuY3Rpb24gc2VsZWN0b3IuXG4gKlxuICogOjo6dGlwXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0eXBpY2FsbHkgdXNlZCB0byBlbmNvZGUgYSBjb250cmFjdCBmdW5jdGlvbiBhbmQgaXRzIGFyZ3VtZW50cyBmb3IgY29udHJhY3QgY2FsbHMgKGUuZy4gYGRhdGFgIHBhcmFtZXRlciBvZiBhbiBgZXRoX2NhbGxgIG9yIGBldGhfc2VuZFRyYW5zYWN0aW9uYCkuXG4gKlxuICogU2VlIHRoZSBbRW5kLXRvLWVuZCBFeGFtcGxlXSgjZW5kLXRvLWVuZCkuXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFwcHJvdmUgPSBBYmlGdW5jdGlvbi5mcm9tKCdmdW5jdGlvbiBhcHByb3ZlKGFkZHJlc3MsIHVpbnQyNTYpJylcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpRnVuY3Rpb24uZW5jb2RlRGF0YSggLy8gWyFjb2RlIGZvY3VzXVxuICogICBhcHByb3ZlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIFsnMHhkOGRhNmJmMjY5NjRhZjlkN2VlZDllMDNlNTM0MTVkMzdhYTk2MDQ1JywgNjk0MjBuXSAvLyBbIWNvZGUgZm9jdXNdXG4gKiApIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogWW91IGNhbiBleHRyYWN0IGFuIEFCSSBGdW5jdGlvbiBmcm9tIGEgSlNPTiBBQkkgd2l0aCB7QGxpbmsgb3gjQWJpRnVuY3Rpb24uKGZyb21BYmk6ZnVuY3Rpb24pfTpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZXJjMjBBYmkgPSBBYmkuZnJvbShbLi4uXSkgLy8gWyFjb2RlIGhsXVxuICogY29uc3QgYXBwcm92ZSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoZXJjMjBBYmksICdhcHByb3ZlJykgLy8gWyFjb2RlIGhsXVxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKFxuICogICBhcHByb3ZlLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsIDY5NDIwbl1cbiAqIClcbiAqIC8vIEBsb2c6ICcweDA5NWVhN2IzMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmMmMnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEVuZC10by1lbmRcbiAqXG4gKiBCZWxvdyBpcyBhbiBlbmQtdG8tZW5kIGV4YW1wbGUgb2YgdXNpbmcgYEFiaUZ1bmN0aW9uLmVuY29kZURhdGFgIHRvIGVuY29kZSB0aGUgaW5wdXQgb2YgYSBgYmFsYW5jZU9mYCBjb250cmFjdCBjYWxsIG9uIHRoZSBbV2FnbWkgTWludCBFeGFtcGxlIGNvbnRyYWN0XShodHRwczovL2V0aGVyc2Nhbi5pby9hZGRyZXNzLzB4ZmJhMzkxMmNhMDRkZDQ1OGM4NDNlMmVlMDg5NjdmYzA0ZjM1NzljMikuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCAnb3gvd2luZG93J1xuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIC8vIDEuIEV4dHJhY3QgdGhlIEZ1bmN0aW9uIGZyb20gdGhlIENvbnRyYWN0J3MgQUJJLlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAvLyAuLi5cbiAqICAge1xuICogICAgIG5hbWU6ICdiYWxhbmNlT2YnLFxuICogICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgICAgaW5wdXRzOiBbeyBuYW1lOiAnYWNjb3VudCcsIHR5cGU6ICdhZGRyZXNzJyB9XSxcbiAqICAgICBvdXRwdXRzOiBbeyBuYW1lOiAnYmFsYW5jZScsIHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgfSxcbiAqICAgLy8gLi4uXG4gKiBdKVxuICogY29uc3QgYmFsYW5jZU9mID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdiYWxhbmNlT2YnKVxuICpcbiAqIC8vIDIuIEVuY29kZSB0aGUgRnVuY3Rpb24gSW5wdXQuIC8vIFshY29kZSBmb2N1c11cbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVEYXRhKCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIGJhbGFuY2VPZiwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBbJzB4ZDIxMzVDZkIyMTZiNzQxMDk3NzUyMzZFMzZkNGI0MzNGMURGNTA3QiddIC8vIFshY29kZSBmb2N1c11cbiAqICkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIDMuIFBlcmZvcm0gdGhlIENvbnRyYWN0IENhbGwuXG4gKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5ldGhlcmV1bSEucmVxdWVzdCh7XG4gKiAgIG1ldGhvZDogJ2V0aF9jYWxsJyxcbiAqICAgcGFyYW1zOiBbXG4gKiAgICAge1xuICogICAgICAgZGF0YSxcbiAqICAgICAgIHRvOiAnMHhmYmEzOTEyY2EwNGRkNDU4Yzg0M2UyZWUwODk2N2ZjMDRmMzU3OWMyJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqXG4gKiAvLyA0LiBEZWNvZGUgdGhlIEZ1bmN0aW9uIE91dHB1dC5cbiAqIGNvbnN0IGJhbGFuY2UgPSBBYmlGdW5jdGlvbi5kZWNvZGVSZXN1bHQoYmFsYW5jZU9mLCByZXNwb25zZSlcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBGb3Igc2ltcGxpY2l0eSwgdGhlIGFib3ZlIGV4YW1wbGUgdXNlcyBgd2luZG93LmV0aGVyZXVtLnJlcXVlc3RgLCBidXQgeW91IGNhbiB1c2UgYW55XG4gKiB0eXBlIG9mIEpTT04tUlBDIGludGVyZmFjZS5cbiAqXG4gKiA6OjpcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBBQkkgRnVuY3Rpb24gdG8gZW5jb2RlXG4gKiBAcGFyYW0gYXJncyAtIEZ1bmN0aW9uIGFyZ3VtZW50c1xuICogQHJldHVybnMgQUJJLWVuY29kZWQgZnVuY3Rpb24gbmFtZSBhbmQgYXJndW1lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVEYXRhKGFiaUZ1bmN0aW9uLCAuLi5hcmdzKSB7XG4gICAgY29uc3QgeyBvdmVybG9hZHMgfSA9IGFiaUZ1bmN0aW9uO1xuICAgIGNvbnN0IGl0ZW0gPSBvdmVybG9hZHNcbiAgICAgICAgPyBmcm9tQWJpKFthYmlGdW5jdGlvbiwgLi4ub3ZlcmxvYWRzXSwgYWJpRnVuY3Rpb24ubmFtZSwge1xuICAgICAgICAgICAgYXJnczogYXJnc1swXSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBhYmlGdW5jdGlvbjtcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGl0ZW0pO1xuICAgIGNvbnN0IGRhdGEgPSBhcmdzLmxlbmd0aCA+IDBcbiAgICAgICAgPyBBYmlQYXJhbWV0ZXJzLmVuY29kZShpdGVtLmlucHV0cywgYXJnc1swXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGRhdGEgPyBIZXguY29uY2F0KHNlbGVjdG9yLCBkYXRhKSA6IHNlbGVjdG9yO1xufVxuLyoqXG4gKiBBQkktZW5jb2RlcyBhIGZ1bmN0aW9uJ3MgcmVzdWx0IChgb3V0cHV0c2ApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB0b3RhbFN1cHBseSA9IEFiaUZ1bmN0aW9uLmZyb20oJ2Z1bmN0aW9uIHRvdGFsU3VwcGx5KCkgcmV0dXJucyAodWludDI1NiknKVxuICogY29uc3Qgb3V0cHV0ID0gQWJpRnVuY3Rpb24uZGVjb2RlUmVzdWx0KHRvdGFsU3VwcGx5LCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDJhJylcbiAqIC8vIDQyblxuICpcbiAqIGNvbnN0IGRhdGEgPSBBYmlGdW5jdGlvbi5lbmNvZGVSZXN1bHQodG90YWxTdXBwbHksIDQybikgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAyYSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgaXRlbSB0byBlbmNvZGUgdGhlIGZ1bmN0aW9uIG91dHB1dCBmb3IuXG4gKiBAcGFyYW0gb3V0cHV0IC0gVGhlIGZ1bmN0aW9uIG91dHB1dCB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBmdW5jdGlvbiBvdXRwdXQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVSZXN1bHQoYWJpRnVuY3Rpb24sIG91dHB1dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9ICdBcnJheScgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdmFsdWVzID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGFiaUZ1bmN0aW9uLm91dHB1dHMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIFtvdXRwdXRdO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXQpKVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgaWYgKGFzID09PSAnT2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKG91dHB1dCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBBYmlQYXJhbWV0ZXJzLmVuY29kZShhYmlGdW5jdGlvbi5vdXRwdXRzLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBGb3JtYXRzIGFuIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0gaW50byBhICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiouXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUZ1bmN0aW9uLmZvcm1hdCh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogZm9ybWF0dGVkXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWJpRnVuY3Rpb24gLSBUaGUgQUJJIEZ1bmN0aW9uIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0KGFiaUZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlGdW5jdGlvbik7XG59XG4vKipcbiAqIFBhcnNlcyBhbiBhcmJpdHJhcnkgKipKU09OIEFCSSBGdW5jdGlvbioqIG9yICoqSHVtYW4gUmVhZGFibGUgQUJJIEZ1bmN0aW9uKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlGdW5jdGlvbi5BYmlGdW5jdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBKU09OIEFCSXNcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbSh7XG4gKiAgIHR5cGU6ICdmdW5jdGlvbicsXG4gKiAgIG5hbWU6ICdhcHByb3ZlJyxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAnbm9ucGF5YWJsZScsXG4gKiAgIGlucHV0czogW1xuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdzcGVuZGVyJyxcbiAqICAgICAgIHR5cGU6ICdhZGRyZXNzJyxcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIG5hbWU6ICdhbW91bnQnLFxuICogICAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiAgIG91dHB1dHM6IFt7IHR5cGU6ICdib29sJyB9XSxcbiAqIH0pXG4gKlxuICogYXBwcm92ZVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBBQklzXG4gKlxuICogQSBIdW1hbiBSZWFkYWJsZSBBQkkgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQgQUJJIG9iamVjdDpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhcHByb3ZlID0gQWJpRnVuY3Rpb24uZnJvbShbXG4gKiAgICdzdHJ1Y3QgRm9vIHsgYWRkcmVzcyBzcGVuZGVyOyB1aW50MjU2IGFtb3VudDsgfScsIC8vIFshY29kZSBobF1cbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoRm9vIGZvbykgcmV0dXJucyAoYm9vbCknLFxuICogXSlcbiAqXG4gKiBhcHByb3ZlXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKlxuICpcbiAqIEBwYXJhbSBhYmlGdW5jdGlvbiAtIFRoZSBBQkkgRnVuY3Rpb24gdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUeXBlZCBBQkkgRnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gQWJpSXRlbS5mcm9tKGFiaUZ1bmN0aW9uLCBvcHRpb25zKTtcbn1cbi8qKlxuICogRXh0cmFjdHMgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEV4dHJhY3RpbmcgYnkgTmFtZVxuICpcbiAqIEFCSSBGdW5jdGlvbnMgY2FuIGJlIGV4dHJhY3RlZCBieSB0aGVpciBuYW1lIHVzaW5nIHRoZSBgbmFtZWAgb3B0aW9uOlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpRnVuY3Rpb24uZnJvbUFiaShhYmksICdmb28nKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBFeHRyYWN0aW5nIGJ5IFNlbGVjdG9yXG4gKlxuICogQUJJIEZ1bmN0aW9ucyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmkgPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oKScsXG4gKiAgICdldmVudCBUcmFuc2ZlcihhZGRyZXNzIG93bmVyLCBhZGRyZXNzIHRvLCB1aW50MjU2IHRva2VuSWQpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcihzdHJpbmcgYSkgcmV0dXJucyAodWludDI1NiB4KScsXG4gKiBdKVxuICogY29uc3QgaXRlbSA9IEFiaUZ1bmN0aW9uLmZyb21BYmkoYWJpLCAnMHgwOTVlYTdiMycpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiA6Ojpub3RlXG4gKlxuICogRXh0cmFjdGluZyB2aWEgYSBoZXggc2VsZWN0b3IgaXMgdXNlZnVsIHdoZW4gZXh0cmFjdGluZyBhbiBBQkkgRnVuY3Rpb24gZnJvbSBhbiBgZXRoX2NhbGxgIFJQQyByZXNwb25zZSBvclxuICogZnJvbSBhIFRyYW5zYWN0aW9uIGBpbnB1dGAuXG4gKlxuICogOjo6XG4gKlxuICogQHBhcmFtIGFiaSAtIFRoZSBBQkkgdG8gZXh0cmFjdCBmcm9tLlxuICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSAob3Igc2VsZWN0b3IpIG9mIHRoZSBBQkkgaXRlbSB0byBleHRyYWN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBFeHRyYWN0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgQUJJIGl0ZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQWJpKGFiaSwgbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGl0ZW0gPSBBYmlJdGVtLmZyb21BYmkoYWJpLCBuYW1lLCBvcHRpb25zKTtcbiAgICBpZiAoaXRlbS50eXBlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgQWJpSXRlbS5Ob3RGb3VuZEVycm9yKHsgbmFtZSwgdHlwZTogJ2Z1bmN0aW9uJyB9KTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFs0LWJ5dGUgc2VsZWN0b3JdKGh0dHBzOi8vc29saWRpdHktYnktZXhhbXBsZS5vcmcvZnVuY3Rpb24tc2VsZWN0b3IvKSBmb3IgYW4ge0BsaW5rIG94I0FiaUZ1bmN0aW9uLkFiaUZ1bmN0aW9ufS5cbiAqXG4gKiBVc2VmdWwgZm9yIGNvbXB1dGluZyBmdW5jdGlvbiBzZWxlY3RvcnMgZm9yIGNhbGxkYXRhLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUZ1bmN0aW9uLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlGdW5jdGlvbi5nZXRTZWxlY3Rvcih7XG4gKiAgIGlucHV0czogW3sgdHlwZTogJ3VpbnQyNTYnIH1dLFxuICogICBuYW1lOiAnb3duZXJPZicsXG4gKiAgIG91dHB1dHM6IFtdLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICd2aWV3JyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICogfSlcbiAqIC8vIEBsb2c6ICcweDYzNTIyMTFlJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIGl0ZW0gdG8gY29tcHV0ZSB0aGUgc2VsZWN0b3IgZm9yLlxuICogQHJldHVybnMgVGhlIGZpcnN0IDQgYnl0ZXMgb2YgdGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3RvcihhYmlJdGVtKSB7XG4gICAgcmV0dXJuIEFiaUl0ZW0uZ2V0U2VsZWN0b3IoYWJpSXRlbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BYmlGdW5jdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/AbiFunction.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/AbiItem.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_esm/core/AbiItem.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AmbiguityError: () => (/* binding */ AmbiguityError),\n/* harmony export */   InvalidSelectorSizeError: () => (/* binding */ InvalidSelectorSizeError),\n/* harmony export */   NotFoundError: () => (/* binding */ NotFoundError),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromAbi: () => (/* binding */ fromAbi),\n/* harmony export */   getSelector: () => (/* binding */ getSelector),\n/* harmony export */   getSignature: () => (/* binding */ getSignature),\n/* harmony export */   getSignatureHash: () => (/* binding */ getSignatureHash)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/formatAbiItem.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/parseAbiItem.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiItem.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/abiItem.js\");\n\n\n\n\n\n/**\n * Formats an {@link ox#AbiItem.AbiItem} into a **Human Readable ABI Item**.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const formatted = AbiItem.format({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiItem - The ABI Item to format.\n * @returns The formatted ABI Item  .\n */\nfunction format(abiItem) {\n    return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n}\n/**\n * Parses an arbitrary **JSON ABI Item** or **Human Readable ABI Item** into a typed {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from({\n *   type: 'function',\n *   name: 'approve',\n *   stateMutability: 'nonpayable',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n *   outputs: [{ type: 'bool' }],\n * })\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from(\n *   'function approve(address spender, uint256 amount) returns (bool)' // [!code hl]\n * )\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const abiItem = AbiItem.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'function approve(Foo foo) returns (bool)',\n * ])\n *\n * abiItem\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiItem - The ABI Item to parse.\n * @returns The typed ABI Item.\n */\nfunction from(abiItem, options = {}) {\n    const { prepare = true } = options;\n    const item = (() => {\n        if (Array.isArray(abiItem))\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        if (typeof abiItem === 'string')\n            return abitype__WEBPACK_IMPORTED_MODULE_1__.parseAbiItem(abiItem);\n        return abiItem;\n    })();\n    return {\n        ...item,\n        ...(prepare ? { hash: getSignatureHash(item) } : {}),\n    };\n}\n/**\n * Extracts an {@link ox#AbiItem.AbiItem} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ABI Items can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiItem.fromAbi(abi, 'Transfer') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Items can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiItem } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'event Transfer(address owner, address to, uint256 tokenId)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiItem.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Item from an `eth_call` RPC response,\n * a Transaction `input`, or from Event Log `topics`.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nfunction fromAbi(abi, name, options) {\n    const { args = [], prepare = true } = (options ??\n        {});\n    const isSelector = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(name, { strict: false });\n    const abiItems = abi.filter((abiItem) => {\n        if (isSelector) {\n            if (abiItem.type === 'function' || abiItem.type === 'error')\n                return getSelector(abiItem) === _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(name, 0, 4);\n            if (abiItem.type === 'event')\n                return getSignatureHash(abiItem) === name;\n            return false;\n        }\n        return 'name' in abiItem && abiItem.name === name;\n    });\n    if (abiItems.length === 0)\n        throw new NotFoundError({ name: name });\n    if (abiItems.length === 1)\n        return {\n            ...abiItems[0],\n            ...(prepare ? { hash: getSignatureHash(abiItems[0]) } : {}),\n        };\n    let matchedAbiItem = undefined;\n    for (const abiItem of abiItems) {\n        if (!('inputs' in abiItem))\n            continue;\n        if (!args || args.length === 0) {\n            if (!abiItem.inputs || abiItem.inputs.length === 0)\n                return {\n                    ...abiItem,\n                    ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n                };\n            continue;\n        }\n        if (!abiItem.inputs)\n            continue;\n        if (abiItem.inputs.length === 0)\n            continue;\n        if (abiItem.inputs.length !== args.length)\n            continue;\n        const matched = args.every((arg, index) => {\n            const abiParameter = 'inputs' in abiItem && abiItem.inputs[index];\n            if (!abiParameter)\n                return false;\n            return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.isArgOfType(arg, abiParameter);\n        });\n        if (matched) {\n            // Check for ambiguity against already matched parameters (e.g. `address` vs `bytes20`).\n            if (matchedAbiItem &&\n                'inputs' in matchedAbiItem &&\n                matchedAbiItem.inputs) {\n                const ambiguousTypes = _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.getAmbiguousTypes(abiItem.inputs, matchedAbiItem.inputs, args);\n                if (ambiguousTypes)\n                    throw new AmbiguityError({\n                        abiItem,\n                        type: ambiguousTypes[0],\n                    }, {\n                        abiItem: matchedAbiItem,\n                        type: ambiguousTypes[1],\n                    });\n            }\n            matchedAbiItem = abiItem;\n        }\n    }\n    const abiItem = (() => {\n        if (matchedAbiItem)\n            return matchedAbiItem;\n        const [abiItem, ...overloads] = abiItems;\n        return { ...abiItem, overloads };\n    })();\n    if (!abiItem)\n        throw new NotFoundError({ name: name });\n    return {\n        ...abiItem,\n        ...(prepare ? { hash: getSignatureHash(abiItem) } : {}),\n    };\n}\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing function selectors for calldata.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector('function ownerOf(uint256 tokenId)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const selector = AbiItem.getSelector({\n *   inputs: [{ type: 'uint256' }],\n *   name: 'ownerOf',\n *   outputs: [],\n *   stateMutability: 'view',\n *   type: 'function'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for. Can be a signature or an ABI item for an error, event, function, etc.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the function signature.\n */\nfunction getSelector(abiItem) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(getSignatureHash(abiItem), 0, 4);\n}\n/**\n * Computes the stringified signature for a given {@link ox#AbiItem.AbiItem}.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature('function ownerOf(uint256 tokenId)')\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const signature = AbiItem.getSignature({\n *   name: 'ownerOf',\n *   type: 'function',\n *   inputs: [{ name: 'tokenId', type: 'uint256' }],\n *   outputs: [],\n *   stateMutability: 'view',\n * })\n * // @log: 'ownerOf(uint256)'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature for.\n * @returns The stringified signature of the ABI Item.\n */\nfunction getSignature(abiItem) {\n    const signature = (() => {\n        if (typeof abiItem === 'string')\n            return abiItem;\n        return abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(abiItem);\n    })();\n    return _internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(signature);\n}\n/**\n * Computes the signature hash for an {@link ox#AbiItem.AbiItem}.\n *\n * Useful for computing Event Topic values.\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash('event Transfer(address indexed from, address indexed to, uint256 amount)')\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiItem } from 'ox'\n *\n * const hash = AbiItem.getSignatureHash({\n *   name: 'Transfer',\n *   type: 'event',\n *   inputs: [\n *     { name: 'from', type: 'address', indexed: true },\n *     { name: 'to', type: 'address', indexed: true },\n *     { name: 'amount', type: 'uint256', indexed: false },\n *   ],\n * })\n * // @log: '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef'\n * ```\n *\n * @param abiItem - The ABI Item to compute the signature hash for.\n * @returns The {@link ox#Hash.(keccak256:function)} hash of the ABI item's signature.\n */\nfunction getSignatureHash(abiItem) {\n    if (typeof abiItem !== 'string' && 'hash' in abiItem && abiItem.hash)\n        return abiItem.hash;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_4__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(getSignature(abiItem)));\n}\n/**\n * Throws when ambiguous types are found on overloaded ABI items.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from(['function foo(address)', 'function foo(bytes20)'])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n *\n * ### Solution\n *\n * Remove one of the ambiguous types from the ABI.\n *\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function foo(bytes20)' // [!code --]\n * ])\n * AbiFunction.fromAbi(foo, 'foo', {\n *   args: ['0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'],\n * })\n * // @error: AbiItem.AmbiguityError: Found ambiguous types in overloaded ABI Items.\n * // @error: `bytes20` in `foo(bytes20)`, and\n * // @error: `address` in `foo(address)`\n * // @error: These types encode differently and cannot be distinguished at runtime.\n * // @error: Remove one of the ambiguous items in the ABI.\n * ```\n */\nclass AmbiguityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor(x, y) {\n        super('Found ambiguous types in overloaded ABI Items.', {\n            metaMessages: [\n                // TODO: abitype to add support for signature-formatted ABI items.\n                `\\`${x.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(x.abiItem))}\\`, and`,\n                `\\`${y.type}\\` in \\`${_internal_abiItem_js__WEBPACK_IMPORTED_MODULE_3__.normalizeSignature(abitype__WEBPACK_IMPORTED_MODULE_0__.formatAbiItem(y.abiItem))}\\``,\n                '',\n                'These types encode differently and cannot be distinguished at runtime.',\n                'Remove one of the ambiguous items in the ABI.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.AmbiguityError'\n        });\n    }\n}\n/**\n * Throws when an ABI item is not found in the ABI.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * // @error: AbiItem.NotFoundError: ABI function with name \"baz\" not found.\n * ```\n *\n * ### Solution\n *\n * Ensure the ABI item exists on the ABI.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)',\n *   'function baz(bool)' // [!code ++]\n * ])\n * AbiFunction.fromAbi(foo, 'baz')\n * ```\n */\nclass NotFoundError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ name, data, type = 'item', }) {\n        const selector = (() => {\n            if (name)\n                return ` with name \"${name}\"`;\n            if (data)\n                return ` with data \"${data}\"`;\n            return '';\n        })();\n        super(`ABI ${type}${selector} not found.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.NotFoundError'\n        });\n    }\n}\n/**\n * Throws when the selector size is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0xaaa')\n * // @error: AbiItem.InvalidSelectorSizeError: Selector size is invalid. Expected 4 bytes. Received 2 bytes (\"0xaaa\").\n * ```\n *\n * ### Solution\n *\n * Ensure the selector size is 4 bytes.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiFunction } from 'ox'\n *\n * const foo = Abi.from([\n *   'function foo(address)',\n *   'function bar(uint)'\n * ])\n * AbiFunction.fromAbi(foo, '0x7af82b1a')\n * ```\n */\nclass InvalidSelectorSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError {\n    constructor({ data }) {\n        super(`Selector size is invalid. Expected 4 bytes. Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(data)} bytes (\"${data}\").`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiItem.InvalidSelectorSizeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNHO0FBQ0o7QUFDRjtBQUNrQjtBQUNsRDtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGtEQUFxQjtBQUNoQztBQUNBO0FBQ0Esc0ZBQXNGLHlCQUF5QjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpQkFBaUIsY0FBYztBQUMvQixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCLGlCQUFpQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Qiw0QkFBNEI7QUFDOUM7QUFDQTtBQUNBLHNDQUFzQyxLQUFLO0FBQzNDO0FBQ0Esc0NBQXNDLEtBQUs7QUFDM0M7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLEtBQUssRUFBRSxVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDLGlEQUFnQjtBQUM5RCxrQkFBa0IsTUFBTTtBQUN4QixzRUFBc0UseUNBQVEsUUFBUSxVQUFVLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEFiaUl0ZW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgYWJpdHlwZSBmcm9tICdhYml0eXBlJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9hYmlJdGVtLmpzJztcbi8qKlxuICogRm9ybWF0cyBhbiB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfSBpbnRvIGEgKipIdW1hbiBSZWFkYWJsZSBBQkkgSXRlbSoqLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvcm1hdHRlZCA9IEFiaUl0ZW0uZm9ybWF0KHtcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAqICAgbmFtZTogJ2FwcHJvdmUnLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqICAgb3V0cHV0czogW3sgdHlwZTogJ2Jvb2wnIH1dLFxuICogfSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBJdGVtIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIEl0ZW0gIC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChhYmlJdGVtKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpSXRlbShhYmlJdGVtKTtcbn1cbi8qKlxuICogUGFyc2VzIGFuIGFyYml0cmFyeSAqKkpTT04gQUJJIEl0ZW0qKiBvciAqKkh1bWFuIFJlYWRhYmxlIEFCSSBJdGVtKiogaW50byBhIHR5cGVkIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19LlxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBBQklzXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhYmlJdGVtID0gQWJpSXRlbS5mcm9tKHtcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAqICAgbmFtZTogJ2FwcHJvdmUnLFxuICogICBzdGF0ZU11dGFiaWxpdHk6ICdub25wYXlhYmxlJyxcbiAqICAgaW5wdXRzOiBbXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ3NwZW5kZXInLFxuICogICAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgICB0eXBlOiAndWludDI1NicsXG4gKiAgICAgfSxcbiAqICAgXSxcbiAqICAgb3V0cHV0czogW3sgdHlwZTogJ2Jvb2wnIH1dLFxuICogfSlcbiAqXG4gKiBhYmlJdGVtXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEh1bWFuIFJlYWRhYmxlIEFCSXNcbiAqXG4gKiBBIEh1bWFuIFJlYWRhYmxlIEFCSSBjYW4gYmUgcGFyc2VkIGludG8gYSB0eXBlZCBBQkkgb2JqZWN0OlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpSXRlbSA9IEFiaUl0ZW0uZnJvbShcbiAqICAgJ2Z1bmN0aW9uIGFwcHJvdmUoYWRkcmVzcyBzcGVuZGVyLCB1aW50MjU2IGFtb3VudCkgcmV0dXJucyAoYm9vbCknIC8vIFshY29kZSBobF1cbiAqIClcbiAqXG4gKiBhYmlJdGVtXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaUl0ZW0gPSBBYmlJdGVtLmZyb20oW1xuICogICAnc3RydWN0IEZvbyB7IGFkZHJlc3Mgc3BlbmRlcjsgdWludDI1NiBhbW91bnQ7IH0nLCAvLyBbIWNvZGUgaGxdXG4gKiAgICdmdW5jdGlvbiBhcHByb3ZlKEZvbyBmb28pIHJldHVybnMgKGJvb2wpJyxcbiAqIF0pXG4gKlxuICogYWJpSXRlbVxuICogLy9eP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICpcbiAqXG4gKiBAcGFyYW0gYWJpSXRlbSAtIFRoZSBBQkkgSXRlbSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBQkkgSXRlbS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oYWJpSXRlbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVwYXJlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBpdGVtID0gKCgpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYWJpSXRlbSkpXG4gICAgICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgICAgIGlmICh0eXBlb2YgYWJpSXRlbSA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgICAgIHJldHVybiBhYmlJdGVtO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXRlbSxcbiAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goaXRlbSkgfSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhbiB7QGxpbmsgb3gjQWJpSXRlbS5BYmlJdGVtfSBmcm9tIGFuIHtAbGluayBveCNBYmkuQWJpfSBnaXZlbiBhIG5hbWUgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogQUJJIEl0ZW1zIGNhbiBiZSBleHRyYWN0ZWQgYnkgdGhlaXIgbmFtZSB1c2luZyB0aGUgYG5hbWVgIG9wdGlvbjpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYWJpID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKCknLFxuICogICAnZXZlbnQgVHJhbnNmZXIoYWRkcmVzcyBvd25lciwgYWRkcmVzcyB0bywgdWludDI1NiB0b2tlbklkKScsXG4gKiAgICdmdW5jdGlvbiBiYXIoc3RyaW5nIGEpIHJldHVybnMgKHVpbnQyNTYgeCknLFxuICogXSlcbiAqXG4gKiBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgJ1RyYW5zZmVyJykgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gICAgXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRXh0cmFjdGluZyBieSBTZWxlY3RvclxuICpcbiAqIEFCSSBJdGVtcyBjYW4gYmUgZXh0cmFjdCBieSB0aGVpciBzZWxlY3RvciB3aGVuIHtAbGluayBveCNIZXguSGV4fSBpcyBwcm92aWRlZCB0byBgbmFtZWAuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGFiaSA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbygpJyxcbiAqICAgJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3Mgb3duZXIsIGFkZHJlc3MgdG8sIHVpbnQyNTYgdG9rZW5JZCknLFxuICogICAnZnVuY3Rpb24gYmFyKHN0cmluZyBhKSByZXR1cm5zICh1aW50MjU2IHgpJyxcbiAqIF0pXG4gKiBjb25zdCBpdGVtID0gQWJpSXRlbS5mcm9tQWJpKGFiaSwgJzB4MDk1ZWE3YjMnKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyAgICBeP1xuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIDo6Om5vdGVcbiAqXG4gKiBFeHRyYWN0aW5nIHZpYSBhIGhleCBzZWxlY3RvciBpcyB1c2VmdWwgd2hlbiBleHRyYWN0aW5nIGFuIEFCSSBJdGVtIGZyb20gYW4gYGV0aF9jYWxsYCBSUEMgcmVzcG9uc2UsXG4gKiBhIFRyYW5zYWN0aW9uIGBpbnB1dGAsIG9yIGZyb20gRXZlbnQgTG9nIGB0b3BpY3NgLlxuICpcbiAqIDo6OlxuICpcbiAqIEBwYXJhbSBhYmkgLSBUaGUgQUJJIHRvIGV4dHJhY3QgZnJvbS5cbiAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgKG9yIHNlbGVjdG9yKSBvZiB0aGUgQUJJIGl0ZW0gdG8gZXh0cmFjdC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRXh0cmFjdGlvbiBvcHRpb25zLlxuICogQHJldHVybnMgVGhlIEFCSSBpdGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUFiaShhYmksIG5hbWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFyZ3MgPSBbXSwgcHJlcGFyZSA9IHRydWUgfSA9IChvcHRpb25zID8/XG4gICAgICAgIHt9KTtcbiAgICBjb25zdCBpc1NlbGVjdG9yID0gSGV4LnZhbGlkYXRlKG5hbWUsIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBjb25zdCBhYmlJdGVtcyA9IGFiaS5maWx0ZXIoKGFiaUl0ZW0pID0+IHtcbiAgICAgICAgaWYgKGlzU2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGlmIChhYmlJdGVtLnR5cGUgPT09ICdmdW5jdGlvbicgfHwgYWJpSXRlbS50eXBlID09PSAnZXJyb3InKVxuICAgICAgICAgICAgICAgIHJldHVybiBnZXRTZWxlY3RvcihhYmlJdGVtKSA9PT0gSGV4LnNsaWNlKG5hbWUsIDAsIDQpO1xuICAgICAgICAgICAgaWYgKGFiaUl0ZW0udHlwZSA9PT0gJ2V2ZW50JylcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSA9PT0gbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ25hbWUnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5uYW1lID09PSBuYW1lO1xuICAgIH0pO1xuICAgIGlmIChhYmlJdGVtcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZTogbmFtZSB9KTtcbiAgICBpZiAoYWJpSXRlbXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYWJpSXRlbXNbMF0sXG4gICAgICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtc1swXSkgfSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICBsZXQgbWF0Y2hlZEFiaUl0ZW0gPSB1bmRlZmluZWQ7XG4gICAgZm9yIChjb25zdCBhYmlJdGVtIG9mIGFiaUl0ZW1zKSB7XG4gICAgICAgIGlmICghKCdpbnB1dHMnIGluIGFiaUl0ZW0pKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICghYXJncyB8fCBhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cyB8fCBhYmlJdGVtLmlucHV0cy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uYWJpSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgLi4uKHByZXBhcmUgPyB7IGhhc2g6IGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhYmlJdGVtLmlucHV0cylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoYWJpSXRlbS5pbnB1dHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChhYmlJdGVtLmlucHV0cy5sZW5ndGggIT09IGFyZ3MubGVuZ3RoKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IG1hdGNoZWQgPSBhcmdzLmV2ZXJ5KChhcmcsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhYmlQYXJhbWV0ZXIgPSAnaW5wdXRzJyBpbiBhYmlJdGVtICYmIGFiaUl0ZW0uaW5wdXRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcm5hbC5pc0FyZ09mVHlwZShhcmcsIGFiaVBhcmFtZXRlcik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFtYmlndWl0eSBhZ2FpbnN0IGFscmVhZHkgbWF0Y2hlZCBwYXJhbWV0ZXJzIChlLmcuIGBhZGRyZXNzYCB2cyBgYnl0ZXMyMGApLlxuICAgICAgICAgICAgaWYgKG1hdGNoZWRBYmlJdGVtICYmXG4gICAgICAgICAgICAgICAgJ2lucHV0cycgaW4gbWF0Y2hlZEFiaUl0ZW0gJiZcbiAgICAgICAgICAgICAgICBtYXRjaGVkQWJpSXRlbS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbWJpZ3VvdXNUeXBlcyA9IGludGVybmFsLmdldEFtYmlndW91c1R5cGVzKGFiaUl0ZW0uaW5wdXRzLCBtYXRjaGVkQWJpSXRlbS5pbnB1dHMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChhbWJpZ3VvdXNUeXBlcylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJpSXRlbTogbWF0Y2hlZEFiaUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBhbWJpZ3VvdXNUeXBlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaGVkQWJpSXRlbSA9IGFiaUl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJpSXRlbSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChtYXRjaGVkQWJpSXRlbSlcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkQWJpSXRlbTtcbiAgICAgICAgY29uc3QgW2FiaUl0ZW0sIC4uLm92ZXJsb2Fkc10gPSBhYmlJdGVtcztcbiAgICAgICAgcmV0dXJuIHsgLi4uYWJpSXRlbSwgb3ZlcmxvYWRzIH07XG4gICAgfSkoKTtcbiAgICBpZiAoIWFiaUl0ZW0pXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEVycm9yKHsgbmFtZTogbmFtZSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5hYmlJdGVtLFxuICAgICAgICAuLi4ocHJlcGFyZSA/IHsgaGFzaDogZ2V0U2lnbmF0dXJlSGFzaChhYmlJdGVtKSB9IDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBbNC1ieXRlIHNlbGVjdG9yXShodHRwczovL3NvbGlkaXR5LWJ5LWV4YW1wbGUub3JnL2Z1bmN0aW9uLXNlbGVjdG9yLykgZm9yIGFuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19LlxuICpcbiAqIFVzZWZ1bCBmb3IgY29tcHV0aW5nIGZ1bmN0aW9uIHNlbGVjdG9ycyBmb3IgY2FsbGRhdGEuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2VsZWN0b3IgPSBBYmlJdGVtLmdldFNlbGVjdG9yKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJzB4NjM1MjIxMWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzZWxlY3RvciA9IEFiaUl0ZW0uZ2V0U2VsZWN0b3Ioe1xuICogICBpbnB1dHM6IFt7IHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgbmFtZTogJ293bmVyT2YnLFxuICogICBvdXRwdXRzOiBbXSxcbiAqICAgc3RhdGVNdXRhYmlsaXR5OiAndmlldycsXG4gKiAgIHR5cGU6ICdmdW5jdGlvbidcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHg2MzUyMjExZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhYmlJdGVtIC0gVGhlIEFCSSBpdGVtIHRvIGNvbXB1dGUgdGhlIHNlbGVjdG9yIGZvci4gQ2FuIGJlIGEgc2lnbmF0dXJlIG9yIGFuIEFCSSBpdGVtIGZvciBhbiBlcnJvciwgZXZlbnQsIGZ1bmN0aW9uLCBldGMuXG4gKiBAcmV0dXJucyBUaGUgZmlyc3QgNCBieXRlcyBvZiB0aGUge0BsaW5rIG94I0hhc2guKGtlY2NhazI1NjpmdW5jdGlvbil9IGhhc2ggb2YgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbGVjdG9yKGFiaUl0ZW0pIHtcbiAgICByZXR1cm4gSGV4LnNsaWNlKGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSksIDAsIDQpO1xufVxuLyoqXG4gKiBDb21wdXRlcyB0aGUgc3RyaW5naWZpZWQgc2lnbmF0dXJlIGZvciBhIGdpdmVuIHtAbGluayBveCNBYmlJdGVtLkFiaUl0ZW19LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IEFiaUl0ZW0uZ2V0U2lnbmF0dXJlKCdmdW5jdGlvbiBvd25lck9mKHVpbnQyNTYgdG9rZW5JZCknKVxuICogLy8gQGxvZzogJ293bmVyT2YodWludDI1NiknXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaUl0ZW0gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBBYmlJdGVtLmdldFNpZ25hdHVyZSh7XG4gKiAgIG5hbWU6ICdvd25lck9mJyxcbiAqICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAqICAgaW5wdXRzOiBbeyBuYW1lOiAndG9rZW5JZCcsIHR5cGU6ICd1aW50MjU2JyB9XSxcbiAqICAgb3V0cHV0czogW10sXG4gKiAgIHN0YXRlTXV0YWJpbGl0eTogJ3ZpZXcnLFxuICogfSlcbiAqIC8vIEBsb2c6ICdvd25lck9mKHVpbnQyNTYpJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gY29tcHV0ZSB0aGUgc2lnbmF0dXJlIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzdHJpbmdpZmllZCBzaWduYXR1cmUgb2YgdGhlIEFCSSBJdGVtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlKGFiaUl0ZW0pIHtcbiAgICBjb25zdCBzaWduYXR1cmUgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGFiaUl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGFiaUl0ZW07XG4gICAgICAgIHJldHVybiBhYml0eXBlLmZvcm1hdEFiaUl0ZW0oYWJpSXRlbSk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4gaW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKHNpZ25hdHVyZSk7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaWduYXR1cmUgaGFzaCBmb3IgYW4ge0BsaW5rIG94I0FiaUl0ZW0uQWJpSXRlbX0uXG4gKlxuICogVXNlZnVsIGZvciBjb21wdXRpbmcgRXZlbnQgVG9waWMgdmFsdWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpSXRlbSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGhhc2ggPSBBYmlJdGVtLmdldFNpZ25hdHVyZUhhc2goJ2V2ZW50IFRyYW5zZmVyKGFkZHJlc3MgaW5kZXhlZCBmcm9tLCBhZGRyZXNzIGluZGV4ZWQgdG8sIHVpbnQyNTYgYW1vdW50KScpXG4gKiAvLyBAbG9nOiAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlJdGVtIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgaGFzaCA9IEFiaUl0ZW0uZ2V0U2lnbmF0dXJlSGFzaCh7XG4gKiAgIG5hbWU6ICdUcmFuc2ZlcicsXG4gKiAgIHR5cGU6ICdldmVudCcsXG4gKiAgIGlucHV0czogW1xuICogICAgIHsgbmFtZTogJ2Zyb20nLCB0eXBlOiAnYWRkcmVzcycsIGluZGV4ZWQ6IHRydWUgfSxcbiAqICAgICB7IG5hbWU6ICd0bycsIHR5cGU6ICdhZGRyZXNzJywgaW5kZXhlZDogdHJ1ZSB9LFxuICogICAgIHsgbmFtZTogJ2Ftb3VudCcsIHR5cGU6ICd1aW50MjU2JywgaW5kZXhlZDogZmFsc2UgfSxcbiAqICAgXSxcbiAqIH0pXG4gKiAvLyBAbG9nOiAnMHhkZGYyNTJhZDFiZTJjODliNjljMmIwNjhmYzM3OGRhYTk1MmJhN2YxNjNjNGExMTYyOGY1NWE0ZGY1MjNiM2VmJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIGFiaUl0ZW0gLSBUaGUgQUJJIEl0ZW0gdG8gY29tcHV0ZSB0aGUgc2lnbmF0dXJlIGhhc2ggZm9yLlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNIYXNoLihrZWNjYWsyNTY6ZnVuY3Rpb24pfSBoYXNoIG9mIHRoZSBBQkkgaXRlbSdzIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25hdHVyZUhhc2goYWJpSXRlbSkge1xuICAgIGlmICh0eXBlb2YgYWJpSXRlbSAhPT0gJ3N0cmluZycgJiYgJ2hhc2gnIGluIGFiaUl0ZW0gJiYgYWJpSXRlbS5oYXNoKVxuICAgICAgICByZXR1cm4gYWJpSXRlbS5oYXNoO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihIZXguZnJvbVN0cmluZyhnZXRTaWduYXR1cmUoYWJpSXRlbSkpKTtcbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW1iaWd1b3VzIHR5cGVzIGFyZSBmb3VuZCBvbiBvdmVybG9hZGVkIEFCSSBpdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsICdmdW5jdGlvbiBmb28oYnl0ZXMyMCknXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnZm9vJywge1xuICogICBhcmdzOiBbJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSddLFxuICogfSlcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5BbWJpZ3VpdHlFcnJvcjogRm91bmQgYW1iaWd1b3VzIHR5cGVzIGluIG92ZXJsb2FkZWQgQUJJIEl0ZW1zLlxuICogLy8gQGVycm9yOiBgYnl0ZXMyMGAgaW4gYGZvbyhieXRlczIwKWAsIGFuZFxuICogLy8gQGVycm9yOiBgYWRkcmVzc2AgaW4gYGZvbyhhZGRyZXNzKWBcbiAqIC8vIEBlcnJvcjogVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLlxuICogLy8gQGVycm9yOiBSZW1vdmUgb25lIG9mIHRoZSBhbWJpZ3VvdXMgaXRlbXMgaW4gdGhlIEFCSS5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyB0eXBlcyBmcm9tIHRoZSBBQkkuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gZm9vKGJ5dGVzMjApJyAvLyBbIWNvZGUgLS1dXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICdmb28nLCB7XG4gKiAgIGFyZ3M6IFsnMHhBMENmNzk4ODE2RDRiOWI5ODY2YjUzMzBFRWE0NmExODM4MmYyNTFlJ10sXG4gKiB9KVxuICogLy8gQGVycm9yOiBBYmlJdGVtLkFtYmlndWl0eUVycm9yOiBGb3VuZCBhbWJpZ3VvdXMgdHlwZXMgaW4gb3ZlcmxvYWRlZCBBQkkgSXRlbXMuXG4gKiAvLyBAZXJyb3I6IGBieXRlczIwYCBpbiBgZm9vKGJ5dGVzMjApYCwgYW5kXG4gKiAvLyBAZXJyb3I6IGBhZGRyZXNzYCBpbiBgZm9vKGFkZHJlc3MpYFxuICogLy8gQGVycm9yOiBUaGVzZSB0eXBlcyBlbmNvZGUgZGlmZmVyZW50bHkgYW5kIGNhbm5vdCBiZSBkaXN0aW5ndWlzaGVkIGF0IHJ1bnRpbWUuXG4gKiAvLyBAZXJyb3I6IFJlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBBbWJpZ3VpdHlFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcbiAgICAgICAgc3VwZXIoJ0ZvdW5kIGFtYmlndW91cyB0eXBlcyBpbiBvdmVybG9hZGVkIEFCSSBJdGVtcy4nLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBhYml0eXBlIHRvIGFkZCBzdXBwb3J0IGZvciBzaWduYXR1cmUtZm9ybWF0dGVkIEFCSSBpdGVtcy5cbiAgICAgICAgICAgICAgICBgXFxgJHt4LnR5cGV9XFxgIGluIFxcYCR7aW50ZXJuYWwubm9ybWFsaXplU2lnbmF0dXJlKGFiaXR5cGUuZm9ybWF0QWJpSXRlbSh4LmFiaUl0ZW0pKX1cXGAsIGFuZGAsXG4gICAgICAgICAgICAgICAgYFxcYCR7eS50eXBlfVxcYCBpbiBcXGAke2ludGVybmFsLm5vcm1hbGl6ZVNpZ25hdHVyZShhYml0eXBlLmZvcm1hdEFiaUl0ZW0oeS5hYmlJdGVtKSl9XFxgYCxcbiAgICAgICAgICAgICAgICAnJyxcbiAgICAgICAgICAgICAgICAnVGhlc2UgdHlwZXMgZW5jb2RlIGRpZmZlcmVudGx5IGFuZCBjYW5ub3QgYmUgZGlzdGluZ3Vpc2hlZCBhdCBydW50aW1lLicsXG4gICAgICAgICAgICAgICAgJ1JlbW92ZSBvbmUgb2YgdGhlIGFtYmlndW91cyBpdGVtcyBpbiB0aGUgQUJJLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uQW1iaWd1aXR5RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3dzIHdoZW4gYW4gQUJJIGl0ZW0gaXMgbm90IGZvdW5kIGluIHRoZSBBQkkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaSwgQWJpRnVuY3Rpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb28gPSBBYmkuZnJvbShbXG4gKiAgICdmdW5jdGlvbiBmb28oYWRkcmVzcyknLFxuICogICAnZnVuY3Rpb24gYmFyKHVpbnQpJ1xuICogXSlcbiAqIEFiaUZ1bmN0aW9uLmZyb21BYmkoZm9vLCAnYmF6JylcbiAqIC8vIEBlcnJvcjogQWJpSXRlbS5Ob3RGb3VuZEVycm9yOiBBQkkgZnVuY3Rpb24gd2l0aCBuYW1lIFwiYmF6XCIgbm90IGZvdW5kLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogRW5zdXJlIHRoZSBBQkkgaXRlbSBleGlzdHMgb24gdGhlIEFCSS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KScsXG4gKiAgICdmdW5jdGlvbiBiYXooYm9vbCknIC8vIFshY29kZSArK11cbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJ2JheicpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG5hbWUsIGRhdGEsIHR5cGUgPSAnaXRlbScsIH0pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSAoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGAgd2l0aCBuYW1lIFwiJHtuYW1lfVwiYDtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHJldHVybiBgIHdpdGggZGF0YSBcIiR7ZGF0YX1cImA7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHN1cGVyKGBBQkkgJHt0eXBlfSR7c2VsZWN0b3J9IG5vdCBmb3VuZC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaUl0ZW0uTm90Rm91bmRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd3Mgd2hlbiB0aGUgc2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpLCBBYmlGdW5jdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGZvbyA9IEFiaS5mcm9tKFtcbiAqICAgJ2Z1bmN0aW9uIGZvbyhhZGRyZXNzKScsXG4gKiAgICdmdW5jdGlvbiBiYXIodWludCknXG4gKiBdKVxuICogQWJpRnVuY3Rpb24uZnJvbUFiaShmb28sICcweGFhYScpXG4gKiAvLyBAZXJyb3I6IEFiaUl0ZW0uSW52YWxpZFNlbGVjdG9yU2l6ZUVycm9yOiBTZWxlY3RvciBzaXplIGlzIGludmFsaWQuIEV4cGVjdGVkIDQgYnl0ZXMuIFJlY2VpdmVkIDIgYnl0ZXMgKFwiMHhhYWFcIikuXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBFbnN1cmUgdGhlIHNlbGVjdG9yIHNpemUgaXMgNCBieXRlcy5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmksIEFiaUZ1bmN0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZm9vID0gQWJpLmZyb20oW1xuICogICAnZnVuY3Rpb24gZm9vKGFkZHJlc3MpJyxcbiAqICAgJ2Z1bmN0aW9uIGJhcih1aW50KSdcbiAqIF0pXG4gKiBBYmlGdW5jdGlvbi5mcm9tQWJpKGZvbywgJzB4N2FmODJiMWEnKVxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VsZWN0b3JTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGRhdGEgfSkge1xuICAgICAgICBzdXBlcihgU2VsZWN0b3Igc2l6ZSBpcyBpbnZhbGlkLiBFeHBlY3RlZCA0IGJ5dGVzLiBSZWNlaXZlZCAke0hleC5zaXplKGRhdGEpfSBieXRlcyAoXCIke2RhdGF9XCIpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpSXRlbS5JbnZhbGlkU2VsZWN0b3JTaXplRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaUl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/AbiItem.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/AbiParameters.js":
/*!********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/AbiParameters.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArrayLengthMismatchError: () => (/* binding */ ArrayLengthMismatchError),\n/* harmony export */   BytesSizeMismatchError: () => (/* binding */ BytesSizeMismatchError),\n/* harmony export */   DataSizeTooSmallError: () => (/* binding */ DataSizeTooSmallError),\n/* harmony export */   InvalidArrayError: () => (/* binding */ InvalidArrayError),\n/* harmony export */   InvalidTypeError: () => (/* binding */ InvalidTypeError),\n/* harmony export */   LengthMismatchError: () => (/* binding */ LengthMismatchError),\n/* harmony export */   ZeroDataError: () => (/* binding */ ZeroDataError),\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodePacked: () => (/* binding */ encodePacked),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   from: () => (/* binding */ from)\n/* harmony export */ });\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/formatAbiParameters.js\");\n/* harmony import */ var abitype__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! abitype */ \"(ssr)/../../node_modules/abitype/dist/esm/human-readable/parseAbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Address.js */ \"(ssr)/../../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Solidity.js */ \"(ssr)/../../node_modules/ox/_esm/core/Solidity.js\");\n/* harmony import */ var _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/abiParameters.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/abiParameters.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/cursor.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n\n\n\n\n// eslint-disable-next-line jsdoc/require-jsdoc\nfunction decode(parameters, data, options = {}) {\n    const { as = 'Array', checksumAddress = false } = options;\n    const bytes = typeof data === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.fromHex(data) : data;\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_1__.create(bytes);\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) === 0 && parameters.length > 0)\n        throw new ZeroDataError();\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) && _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) < 32)\n        throw new DataSizeTooSmallError({\n            data: typeof data === 'string' ? data : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data),\n            parameters: parameters,\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n        });\n    let consumed = 0;\n    const values = as === 'Array' ? [] : {};\n    for (let i = 0; i < parameters.length; ++i) {\n        const param = parameters[i];\n        cursor.setPosition(consumed);\n        const [data, consumed_] = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: 0,\n        });\n        consumed += consumed_;\n        if (as === 'Array')\n            values.push(data);\n        else\n            values[param.name ?? i] = data;\n    }\n    return values;\n}\n/**\n * Encodes primitive values into ABI encoded data as per the [Application Binary Interface (ABI) Specification](https://docs.soliditylang.org/en/latest/abi-spec).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   AbiParameters.from(['string', 'uint', 'bool']),\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @example\n * ### JSON Parameters\n *\n * Specify **JSON ABI** Parameters as schema:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const data = AbiParameters.encode(\n *   [\n *     { type: 'string', name: 'name' },\n *     { type: 'uint', name: 'age' },\n *     { type: 'bool', name: 'isOwner' },\n *   ],\n *   ['wagmi', 420n, true],\n * )\n * ```\n *\n * @param parameters - The set of ABI parameters to encode, in the shape of the `inputs` or `outputs` attribute of an ABI Item. These parameters must include valid [ABI types](https://docs.soliditylang.org/en/latest/types.html).\n * @param values - The set of primitive values that correspond to the ABI types defined in `parameters`.\n * @returns ABI encoded data.\n */\nfunction encode(parameters, values, options) {\n    const { checksumAddress = false } = options ?? {};\n    if (parameters.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: parameters.length,\n            givenLength: values.length,\n        });\n    // Prepare the parameters to determine dynamic types to encode.\n    const preparedParameters = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.prepareParameters({\n        checksumAddress,\n        parameters: parameters,\n        values: values,\n    });\n    const data = _internal_abiParameters_js__WEBPACK_IMPORTED_MODULE_3__.encode(preparedParameters);\n    if (data.length === 0)\n        return '0x';\n    return data;\n}\n/**\n * Encodes an array of primitive values to a [packed ABI encoding](https://docs.soliditylang.org/en/latest/abi-spec.html#non-standard-packed-mode).\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const encoded = AbiParameters.encodePacked(\n *   ['address', 'string'],\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 'hello world'],\n * )\n * // @log: '0xd8da6bf26964af9d7eed9e03e53415d37aa9604568656c6c6f20776f726c64'\n * ```\n *\n * @param types - Set of ABI types to pack encode.\n * @param values - The set of primitive values that correspond to the ABI types defined in `types`.\n * @returns The encoded packed data.\n */\nfunction encodePacked(types, values) {\n    if (types.length !== values.length)\n        throw new LengthMismatchError({\n            expectedLength: types.length,\n            givenLength: values.length,\n        });\n    const data = [];\n    for (let i = 0; i < types.length; i++) {\n        const type = types[i];\n        const value = values[i];\n        data.push(encodePacked.encode(type, value));\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n}\n(function (encodePacked) {\n    // eslint-disable-next-line jsdoc/require-jsdoc\n    function encode(type, value, isArray = false) {\n        if (type === 'address') {\n            const address = value;\n            _Address_js__WEBPACK_IMPORTED_MODULE_4__.assert(address);\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(address.toLowerCase(), isArray ? 32 : 0);\n        }\n        if (type === 'string')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n        if (type === 'bytes')\n            return value;\n        if (type === 'bool')\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value), isArray ? 32 : 1);\n        const intMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.integerRegex);\n        if (intMatch) {\n            const [_type, baseType, bits = '256'] = intMatch;\n            const size = Number.parseInt(bits) / 8;\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n                size: isArray ? 32 : size,\n                signed: baseType === 'int',\n            });\n        }\n        const bytesMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.bytesRegex);\n        if (bytesMatch) {\n            const [_type, size] = bytesMatch;\n            if (Number.parseInt(size) !== (value.length - 2) / 2)\n                throw new BytesSizeMismatchError({\n                    expectedSize: Number.parseInt(size),\n                    value: value,\n                });\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, isArray ? 32 : 0);\n        }\n        const arrayMatch = type.match(_Solidity_js__WEBPACK_IMPORTED_MODULE_5__.arrayRegex);\n        if (arrayMatch && Array.isArray(value)) {\n            const [_type, childType] = arrayMatch;\n            const data = [];\n            for (let i = 0; i < value.length; i++) {\n                data.push(encode(childType, value[i], true));\n            }\n            if (data.length === 0)\n                return '0x';\n            return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...data);\n        }\n        throw new InvalidTypeError(type);\n    }\n    encodePacked.encode = encode;\n})(encodePacked || (encodePacked = {}));\n/**\n * Formats {@link ox#AbiParameters.AbiParameters} into **Human Readable ABI Parameters**.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const formatted = AbiParameters.format([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param parameters - The ABI Parameters to format.\n * @returns The formatted ABI Parameters  .\n */\nfunction format(parameters) {\n    return abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters);\n}\n/**\n * Parses arbitrary **JSON ABI Parameters** or **Human Readable ABI Parameters** into typed {@link ox#AbiParameters.AbiParameters}.\n *\n * @example\n * ### JSON Parameters\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   {\n *     name: 'spender',\n *     type: 'address',\n *   },\n *   {\n *     name: 'amount',\n *     type: 'uint256',\n *   },\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable Parameters\n *\n * Human Readable ABI Parameters can be parsed into a typed {@link ox#AbiParameters.AbiParameters}:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from('address spender, uint256 amount')\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * const parameters = AbiParameters.from([\n *   'struct Foo { address spender; uint256 amount; }', // [!code hl]\n *   'Foo foo, address bar',\n * ])\n *\n * parameters\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param parameters - The ABI Parameters to parse.\n * @returns The typed ABI Parameters.\n */\nfunction from(parameters) {\n    if (Array.isArray(parameters) && typeof parameters[0] === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    if (typeof parameters === 'string')\n        return abitype__WEBPACK_IMPORTED_MODULE_7__.parseAbiParameters(parameters);\n    return parameters;\n}\n/**\n * Throws when the data size is too small for the given parameters.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x010f')\n * //                                             ↑ ❌ 2 bytes\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass a valid data size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nclass DataSizeTooSmallError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ data, parameters, size, }) {\n        super(`Data size of ${size} bytes is too small for given parameters.`, {\n            metaMessages: [\n                `Params: (${abitype__WEBPACK_IMPORTED_MODULE_6__.formatAbiParameters(parameters)})`,\n                `Data:   ${data} (${size} bytes)`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.DataSizeTooSmallError'\n        });\n    }\n}\n/**\n * Throws when zero data is provided, but data is expected.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x')\n * //                                           ↑ ❌ zero data\n * // @error: AbiParameters.DataSizeTooSmallError: Data size of 2 bytes is too small for given parameters.\n * // @error: Params: (uint256)\n * // @error: Data:   0x010f (2 bytes)\n * ```\n *\n * ### Solution\n *\n * Pass valid data.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'uint256' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                                             ↑ ✅ 32 bytes\n * ```\n */\nclass ZeroDataError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor() {\n        super('Cannot decode zero data (\"0x\") with ABI parameters.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ZeroDataError'\n        });\n    }\n}\n/**\n * The length of the array value does not match the length specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('uint256[3]'), [[69n, 420n]])\n * //                                               ↑ expected: 3  ↑ ❌ length: 2\n * // @error: AbiParameters.ArrayLengthMismatchError: ABI encoding array length mismatch\n * // @error: for type `uint256[3]`. Expected: `3`. Given: `2`.\n * ```\n *\n * ### Solution\n *\n * Pass an array of the correct length.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [[69n, 420n, 69n]])\n * //                                                         ↑ ✅ length: 3\n * ```\n */\nclass ArrayLengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, type, }) {\n        super(`Array length mismatch for type \\`${type}\\`. Expected: \\`${expectedLength}\\`. Given: \\`${givenLength}\\`.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.ArrayLengthMismatchError'\n        });\n    }\n}\n/**\n * The size of the bytes value does not match the size specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from('bytes8'), [['0xdeadbeefdeadbeefdeadbeef']])\n * //                                            ↑ expected: 8 bytes  ↑ ❌ size: 12 bytes\n * // @error: BytesSizeMismatchError: Size of bytes \"0xdeadbeefdeadbeefdeadbeef\"\n * // @error: (bytes12) does not match expected size (bytes8).\n * ```\n *\n * ### Solution\n *\n * Pass a bytes value of the correct size.\n *\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['bytes8']), ['0xdeadbeefdeadbeef'])\n * //                                                       ↑ ✅ size: 8 bytes\n * ```\n */\nclass BytesSizeMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedSize, value, }) {\n        super(`Size of bytes \"${value}\" (bytes${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value)}) does not match expected size (bytes${expectedSize}).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.BytesSizeMismatchError'\n        });\n    }\n}\n/**\n * The length of the values to encode does not match the length of the ABI parameters.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['string', 'uint256']), ['hello'])\n * // @error: LengthMismatchError: ABI encoding params/values length mismatch.\n * // @error: Expected length (params): 2\n * // @error: Given length (values): 1\n * ```\n *\n * ### Solution\n *\n * Pass the correct number of values to encode.\n *\n * ### Solution\n *\n * Pass a [valid ABI type](https://docs.soliditylang.org/en/develop/abi-spec.html#types).\n */\nclass LengthMismatchError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor({ expectedLength, givenLength, }) {\n        super([\n            'ABI encoding parameters/values length mismatch.',\n            `Expected length (parameters): ${expectedLength}`,\n            `Given length (values): ${givenLength}`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.LengthMismatchError'\n        });\n    }\n}\n/**\n * The value provided is not a valid array as specified in the corresponding ABI parameter.\n *\n * ### Example\n *\n * ```ts twoslash\n * // @noErrors\n * import { AbiParameters } from 'ox'\n * // ---cut---\n * AbiParameters.encode(AbiParameters.from(['uint256[3]']), [69])\n * ```\n *\n * ### Solution\n *\n * Pass an array value.\n */\nclass InvalidArrayError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is not a valid array.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidArrayError'\n        });\n    }\n}\n/**\n * Throws when the ABI parameter type is invalid.\n *\n * @example\n * ```ts twoslash\n * import { AbiParameters } from 'ox'\n *\n * AbiParameters.decode([{ type: 'lol' }], '0x00000000000000000000000000000000000000000000000000000000000010f')\n * //                             ↑ ❌ invalid type\n * // @error: AbiParameters.InvalidTypeError: Type `lol` is not a valid ABI Type.\n * ```\n */\nclass InvalidTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_8__.BaseError {\n    constructor(type) {\n        super(`Type \\`${type}\\` is not a valid ABI Type.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AbiParameters.InvalidTypeError'\n        });\n    }\n}\n//# sourceMappingURL=AbiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtQztBQUNLO0FBQ0o7QUFDRTtBQUNOO0FBQ1U7QUFDYztBQUNUO0FBQy9DO0FBQ08sOENBQThDO0FBQ3JELFlBQVksd0NBQXdDO0FBQ3BELDZDQUE2Qyw4Q0FBYTtBQUMxRCxtQkFBbUIsdURBQWE7QUFDaEMsUUFBUSwyQ0FBVTtBQUNsQjtBQUNBLFFBQVEsMkNBQVUsV0FBVywyQ0FBVTtBQUN2QztBQUNBLG9EQUFvRCw4Q0FBYTtBQUNqRTtBQUNBLGtCQUFrQiwyQ0FBVTtBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBLGtDQUFrQyx1RUFBd0I7QUFDMUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkMsU0FBUywyQkFBMkI7QUFDcEMsU0FBUywrQkFBK0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLDBCQUEwQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtCQUErQix5RUFBMEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlCQUFpQiw4REFBZTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFD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QkFBOEI7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QyxlQUFlO0FBQzVELHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGlEQUFnQjtBQUN2RDtBQUNBLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLGlEQUFnQjtBQUN0RDtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxBYmlQYXJhbWV0ZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGFiaXR5cGUgZnJvbSAnYWJpdHlwZSc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgU29saWRpdHkgZnJvbSAnLi9Tb2xpZGl0eS5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbCBmcm9tICcuL2ludGVybmFsL2FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQ3Vyc29yIGZyb20gJy4vaW50ZXJuYWwvY3Vyc29yLmpzJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc2RvYy9yZXF1aXJlLWpzZG9jXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlKHBhcmFtZXRlcnMsIGRhdGEsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnQXJyYXknLCBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoZGF0YSkgOiBkYXRhO1xuICAgIGNvbnN0IGN1cnNvciA9IEN1cnNvci5jcmVhdGUoYnl0ZXMpO1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSA9PT0gMCAmJiBwYXJhbWV0ZXJzLmxlbmd0aCA+IDApXG4gICAgICAgIHRocm93IG5ldyBaZXJvRGF0YUVycm9yKCk7XG4gICAgaWYgKEJ5dGVzLnNpemUoYnl0ZXMpICYmIEJ5dGVzLnNpemUoYnl0ZXMpIDwgMzIpXG4gICAgICAgIHRocm93IG5ldyBEYXRhU2l6ZVRvb1NtYWxsRXJyb3Ioe1xuICAgICAgICAgICAgZGF0YTogdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID8gZGF0YSA6IEhleC5mcm9tQnl0ZXMoZGF0YSksXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZShieXRlcyksXG4gICAgICAgIH0pO1xuICAgIGxldCBjb25zdW1lZCA9IDA7XG4gICAgY29uc3QgdmFsdWVzID0gYXMgPT09ICdBcnJheScgPyBbXSA6IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IHBhcmFtZXRlcnNbaV07XG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihjb25zdW1lZCk7XG4gICAgICAgIGNvbnN0IFtkYXRhLCBjb25zdW1lZF9dID0gaW50ZXJuYWwuZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICBpZiAoYXMgPT09ICdBcnJheScpXG4gICAgICAgICAgICB2YWx1ZXMucHVzaChkYXRhKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLm5hbWUgPz8gaV0gPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIHByaW1pdGl2ZSB2YWx1ZXMgaW50byBBQkkgZW5jb2RlZCBkYXRhIGFzIHBlciB0aGUgW0FwcGxpY2F0aW9uIEJpbmFyeSBJbnRlcmZhY2UgKEFCSSkgU3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L2FiaS1zcGVjKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpUGFyYW1ldGVycy5lbmNvZGUoXG4gKiAgIEFiaVBhcmFtZXRlcnMuZnJvbShbJ3N0cmluZycsICd1aW50JywgJ2Jvb2wnXSksXG4gKiAgIFsnd2FnbWknLCA0MjBuLCB0cnVlXSxcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgSlNPTiBQYXJhbWV0ZXJzXG4gKlxuICogU3BlY2lmeSAqKkpTT04gQUJJKiogUGFyYW1ldGVycyBhcyBzY2hlbWE6XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQWJpUGFyYW1ldGVycy5lbmNvZGUoXG4gKiAgIFtcbiAqICAgICB7IHR5cGU6ICdzdHJpbmcnLCBuYW1lOiAnbmFtZScgfSxcbiAqICAgICB7IHR5cGU6ICd1aW50JywgbmFtZTogJ2FnZScgfSxcbiAqICAgICB7IHR5cGU6ICdib29sJywgbmFtZTogJ2lzT3duZXInIH0sXG4gKiAgIF0sXG4gKiAgIFsnd2FnbWknLCA0MjBuLCB0cnVlXSxcbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIHNldCBvZiBBQkkgcGFyYW1ldGVycyB0byBlbmNvZGUsIGluIHRoZSBzaGFwZSBvZiB0aGUgYGlucHV0c2Agb3IgYG91dHB1dHNgIGF0dHJpYnV0ZSBvZiBhbiBBQkkgSXRlbS4gVGhlc2UgcGFyYW1ldGVycyBtdXN0IGluY2x1ZGUgdmFsaWQgW0FCSSB0eXBlc10oaHR0cHM6Ly9kb2NzLnNvbGlkaXR5bGFuZy5vcmcvZW4vbGF0ZXN0L3R5cGVzLmh0bWwpLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXQgb2YgcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIEFCSSB0eXBlcyBkZWZpbmVkIGluIGBwYXJhbWV0ZXJzYC5cbiAqIEByZXR1cm5zIEFCSSBlbmNvZGVkIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocGFyYW1ldGVycywgdmFsdWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBpZiAocGFyYW1ldGVycy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBMZW5ndGhNaXNtYXRjaEVycm9yKHtcbiAgICAgICAgICAgIGV4cGVjdGVkTGVuZ3RoOiBwYXJhbWV0ZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICAvLyBQcmVwYXJlIHRoZSBwYXJhbWV0ZXJzIHRvIGRldGVybWluZSBkeW5hbWljIHR5cGVzIHRvIGVuY29kZS5cbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBpbnRlcm5hbC5wcmVwYXJlUGFyYW1ldGVycyh7XG4gICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgfSk7XG4gICAgY29uc3QgZGF0YSA9IGludGVybmFsLmVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuICcweCc7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIEVuY29kZXMgYW4gYXJyYXkgb2YgcHJpbWl0aXZlIHZhbHVlcyB0byBhIFtwYWNrZWQgQUJJIGVuY29kaW5nXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9sYXRlc3QvYWJpLXNwZWMuaHRtbCNub24tc3RhbmRhcmQtcGFja2VkLW1vZGUpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVuY29kZWQgPSBBYmlQYXJhbWV0ZXJzLmVuY29kZVBhY2tlZChcbiAqICAgWydhZGRyZXNzJywgJ3N0cmluZyddLFxuICogICBbJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NScsICdoZWxsbyB3b3JsZCddLFxuICogKVxuICogLy8gQGxvZzogJzB4ZDhkYTZiZjI2OTY0YWY5ZDdlZWQ5ZTAzZTUzNDE1ZDM3YWE5NjA0NTY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHlwZXMgLSBTZXQgb2YgQUJJIHR5cGVzIHRvIHBhY2sgZW5jb2RlLlxuICogQHBhcmFtIHZhbHVlcyAtIFRoZSBzZXQgb2YgcHJpbWl0aXZlIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIEFCSSB0eXBlcyBkZWZpbmVkIGluIGB0eXBlc2AuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCBwYWNrZWQgZGF0YS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVBhY2tlZCh0eXBlcywgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IExlbmd0aE1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IHR5cGVzLmxlbmd0aCxcbiAgICAgICAgICAgIGdpdmVuTGVuZ3RoOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBkYXRhLnB1c2goZW5jb2RlUGFja2VkLmVuY29kZSh0eXBlLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbn1cbihmdW5jdGlvbiAoZW5jb2RlUGFja2VkKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzZG9jL3JlcXVpcmUtanNkb2NcbiAgICBmdW5jdGlvbiBlbmNvZGUodHlwZSwgdmFsdWUsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdmFsdWU7XG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBIZXgucGFkTGVmdChhZGRyZXNzLnRvTG93ZXJDYXNlKCksIGlzQXJyYXkgPyAzMiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ2Jvb2wnKVxuICAgICAgICAgICAgcmV0dXJuIEhleC5wYWRMZWZ0KEhleC5mcm9tQm9vbGVhbih2YWx1ZSksIGlzQXJyYXkgPyAzMiA6IDEpO1xuICAgICAgICBjb25zdCBpbnRNYXRjaCA9IHR5cGUubWF0Y2goU29saWRpdHkuaW50ZWdlclJlZ2V4KTtcbiAgICAgICAgaWYgKGludE1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCBbX3R5cGUsIGJhc2VUeXBlLCBiaXRzID0gJzI1NiddID0gaW50TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBzaXplID0gTnVtYmVyLnBhcnNlSW50KGJpdHMpIC8gODtcbiAgICAgICAgICAgIHJldHVybiBIZXguZnJvbU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgICAgIHNpemU6IGlzQXJyYXkgPyAzMiA6IHNpemUsXG4gICAgICAgICAgICAgICAgc2lnbmVkOiBiYXNlVHlwZSA9PT0gJ2ludCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlc01hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5ieXRlc1JlZ2V4KTtcbiAgICAgICAgaWYgKGJ5dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgc2l6ZV0gPSBieXRlc01hdGNoO1xuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChzaXplKSAhPT0gKHZhbHVlLmxlbmd0aCAtIDIpIC8gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQnl0ZXNTaXplTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkU2l6ZTogTnVtYmVyLnBhcnNlSW50KHNpemUpLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSGV4LnBhZFJpZ2h0KHZhbHVlLCBpc0FycmF5ID8gMzIgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcnJheU1hdGNoID0gdHlwZS5tYXRjaChTb2xpZGl0eS5hcnJheVJlZ2V4KTtcbiAgICAgICAgaWYgKGFycmF5TWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfdHlwZSwgY2hpbGRUeXBlXSA9IGFycmF5TWF0Y2g7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKGVuY29kZShjaGlsZFR5cGUsIHZhbHVlW2ldLCB0cnVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCc7XG4gICAgICAgICAgICByZXR1cm4gSGV4LmNvbmNhdCguLi5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFR5cGVFcnJvcih0eXBlKTtcbiAgICB9XG4gICAgZW5jb2RlUGFja2VkLmVuY29kZSA9IGVuY29kZTtcbn0pKGVuY29kZVBhY2tlZCB8fCAoZW5jb2RlUGFja2VkID0ge30pKTtcbi8qKlxuICogRm9ybWF0cyB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfSBpbnRvICoqSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMqKi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBmb3JtYXR0ZWQgPSBBYmlQYXJhbWV0ZXJzLmZvcm1hdChbXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICB9LFxuICogICB7XG4gKiAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICB9LFxuICogXSlcbiAqXG4gKiBmb3JtYXR0ZWRcbiAqIC8vICAgIF4/XG4gKlxuICpcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gVGhlIEFCSSBQYXJhbWV0ZXJzIHRvIGZvcm1hdC5cbiAqIEByZXR1cm5zIFRoZSBmb3JtYXR0ZWQgQUJJIFBhcmFtZXRlcnMgIC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChwYXJhbWV0ZXJzKSB7XG4gICAgcmV0dXJuIGFiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbn1cbi8qKlxuICogUGFyc2VzIGFyYml0cmFyeSAqKkpTT04gQUJJIFBhcmFtZXRlcnMqKiBvciAqKkh1bWFuIFJlYWRhYmxlIEFCSSBQYXJhbWV0ZXJzKiogaW50byB0eXBlZCB7QGxpbmsgb3gjQWJpUGFyYW1ldGVycy5BYmlQYXJhbWV0ZXJzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEpTT04gUGFyYW1ldGVyc1xuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcGFyYW1ldGVycyA9IEFiaVBhcmFtZXRlcnMuZnJvbShbXG4gKiAgIHtcbiAqICAgICBuYW1lOiAnc3BlbmRlcicsXG4gKiAgICAgdHlwZTogJ2FkZHJlc3MnLFxuICogICB9LFxuICogICB7XG4gKiAgICAgbmFtZTogJ2Ftb3VudCcsXG4gKiAgICAgdHlwZTogJ3VpbnQyNTYnLFxuICogICB9LFxuICogXSlcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBIdW1hbiBSZWFkYWJsZSBQYXJhbWV0ZXJzXG4gKlxuICogSHVtYW4gUmVhZGFibGUgQUJJIFBhcmFtZXRlcnMgY2FuIGJlIHBhcnNlZCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0FiaVBhcmFtZXRlcnMuQWJpUGFyYW1ldGVyc306XG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwYXJhbWV0ZXJzID0gQWJpUGFyYW1ldGVycy5mcm9tKCdhZGRyZXNzIHNwZW5kZXIsIHVpbnQyNTYgYW1vdW50JylcbiAqXG4gKiBwYXJhbWV0ZXJzXG4gKiAvL14/XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHNwZWNpZnkgYHN0cnVjdGBzIGFsb25nIHdpdGggeW91ciBkZWZpbml0aW9uczpcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHBhcmFtZXRlcnMgPSBBYmlQYXJhbWV0ZXJzLmZyb20oW1xuICogICAnc3RydWN0IEZvbyB7IGFkZHJlc3Mgc3BlbmRlcjsgdWludDI1NiBhbW91bnQ7IH0nLCAvLyBbIWNvZGUgaGxdXG4gKiAgICdGb28gZm9vLCBhZGRyZXNzIGJhcicsXG4gKiBdKVxuICpcbiAqIHBhcmFtZXRlcnNcbiAqIC8vXj9cbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqXG4gKlxuICpcbiAqIGBgYFxuICpcbiAqXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMgLSBUaGUgQUJJIFBhcmFtZXRlcnMgdG8gcGFyc2UuXG4gKiBAcmV0dXJucyBUaGUgdHlwZWQgQUJJIFBhcmFtZXRlcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbWV0ZXJzKSAmJiB0eXBlb2YgcGFyYW1ldGVyc1swXSA9PT0gJ3N0cmluZycpXG4gICAgICAgIHJldHVybiBhYml0eXBlLnBhcnNlQWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICBpZiAodHlwZW9mIHBhcmFtZXRlcnMgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gYWJpdHlwZS5wYXJzZUFiaVBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHRoZSBkYXRhIHNpemUgaXMgdG9vIHNtYWxsIGZvciB0aGUgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIDIgYnl0ZXNcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3I6IERhdGEgc2l6ZSBvZiAyIGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqIC8vIEBlcnJvcjogUGFyYW1zOiAodWludDI1NilcbiAqIC8vIEBlcnJvcjogRGF0YTogICAweDAxMGYgKDIgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgdmFsaWQgZGF0YSBzaXplLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMGYnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4pyFIDMyIGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIERhdGFTaXplVG9vU21hbGxFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZGF0YSwgcGFyYW1ldGVycywgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgRGF0YSBzaXplIG9mICR7c2l6ZX0gYnl0ZXMgaXMgdG9vIHNtYWxsIGZvciBnaXZlbiBwYXJhbWV0ZXJzLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgIGBQYXJhbXM6ICgke2FiaXR5cGUuZm9ybWF0QWJpUGFyYW1ldGVycyhwYXJhbWV0ZXJzKX0pYCxcbiAgICAgICAgICAgICAgICBgRGF0YTogICAke2RhdGF9ICgke3NpemV9IGJ5dGVzKWAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuRGF0YVNpemVUb29TbWFsbEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHplcm8gZGF0YSBpcyBwcm92aWRlZCwgYnV0IGRhdGEgaXMgZXhwZWN0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKlxuICogQWJpUGFyYW1ldGVycy5kZWNvZGUoW3sgdHlwZTogJ3VpbnQyNTYnIH1dLCAnMHgnKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKdjCB6ZXJvIGRhdGFcbiAqIC8vIEBlcnJvcjogQWJpUGFyYW1ldGVycy5EYXRhU2l6ZVRvb1NtYWxsRXJyb3I6IERhdGEgc2l6ZSBvZiAyIGJ5dGVzIGlzIHRvbyBzbWFsbCBmb3IgZ2l2ZW4gcGFyYW1ldGVycy5cbiAqIC8vIEBlcnJvcjogUGFyYW1zOiAodWludDI1NilcbiAqIC8vIEBlcnJvcjogRGF0YTogICAweDAxMGYgKDIgYnl0ZXMpXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIHZhbGlkIGRhdGEuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAndWludDI1NicgfV0sICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwZicpXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIOKGkSDinIUgMzIgYnl0ZXNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgWmVyb0RhdGFFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcignQ2Fubm90IGRlY29kZSB6ZXJvIGRhdGEgKFwiMHhcIikgd2l0aCBBQkkgcGFyYW1ldGVycy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuWmVyb0RhdGFFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgbGVuZ3RoIHNwZWNpZmllZCBpbiB0aGUgY29ycmVzcG9uZGluZyBBQkkgcGFyYW1ldGVyLlxuICpcbiAqICMjIyBFeGFtcGxlXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQWJpUGFyYW1ldGVycyB9IGZyb20gJ294J1xuICogLy8gLS0tY3V0LS0tXG4gKiBBYmlQYXJhbWV0ZXJzLmVuY29kZShBYmlQYXJhbWV0ZXJzLmZyb20oJ3VpbnQyNTZbM10nKSwgW1s2OW4sIDQyMG5dXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEgZXhwZWN0ZWQ6IDMgIOKGkSDinYwgbGVuZ3RoOiAyXG4gKiAvLyBAZXJyb3I6IEFiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yOiBBQkkgZW5jb2RpbmcgYXJyYXkgbGVuZ3RoIG1pc21hdGNoXG4gKiAvLyBAZXJyb3I6IGZvciB0eXBlIGB1aW50MjU2WzNdYC4gRXhwZWN0ZWQ6IGAzYC4gR2l2ZW46IGAyYC5cbiAqIGBgYFxuICpcbiAqICMjIyBTb2x1dGlvblxuICpcbiAqIFBhc3MgYW4gYXJyYXkgb2YgdGhlIGNvcnJlY3QgbGVuZ3RoLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3VpbnQyNTZbM10nXSksIFtbNjluLCA0MjBuLCA2OW5dXSlcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSBsZW5ndGg6IDNcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBleHBlY3RlZExlbmd0aCwgZ2l2ZW5MZW5ndGgsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYEFycmF5IGxlbmd0aCBtaXNtYXRjaCBmb3IgdHlwZSBcXGAke3R5cGV9XFxgLiBFeHBlY3RlZDogXFxgJHtleHBlY3RlZExlbmd0aH1cXGAuIEdpdmVuOiBcXGAke2dpdmVuTGVuZ3RofVxcYC5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuQXJyYXlMZW5ndGhNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBzaXplIG9mIHRoZSBieXRlcyB2YWx1ZSBkb2VzIG5vdCBtYXRjaCB0aGUgc2l6ZSBzcGVjaWZpZWQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgQUJJIHBhcmFtZXRlci5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiAvLyBAbm9FcnJvcnNcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKCdieXRlczgnKSwgW1snMHhkZWFkYmVlZmRlYWRiZWVmZGVhZGJlZWYnXV0pXG4gKiAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIGV4cGVjdGVkOiA4IGJ5dGVzICDihpEg4p2MIHNpemU6IDEyIGJ5dGVzXG4gKiAvLyBAZXJyb3I6IEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3I6IFNpemUgb2YgYnl0ZXMgXCIweGRlYWRiZWVmZGVhZGJlZWZkZWFkYmVlZlwiXG4gKiAvLyBAZXJyb3I6IChieXRlczEyKSBkb2VzIG5vdCBtYXRjaCBleHBlY3RlZCBzaXplIChieXRlczgpLlxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyBhIGJ5dGVzIHZhbHVlIG9mIHRoZSBjb3JyZWN0IHNpemUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqIC8vIC0tLWN1dC0tLVxuICogQWJpUGFyYW1ldGVycy5lbmNvZGUoQWJpUGFyYW1ldGVycy5mcm9tKFsnYnl0ZXM4J10pLCBbJzB4ZGVhZGJlZWZkZWFkYmVlZiddKVxuICogLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg4oaRIOKchSBzaXplOiA4IGJ5dGVzXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJ5dGVzU2l6ZU1pc21hdGNoRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGV4cGVjdGVkU2l6ZSwgdmFsdWUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgb2YgYnl0ZXMgXCIke3ZhbHVlfVwiIChieXRlcyR7SGV4LnNpemUodmFsdWUpfSkgZG9lcyBub3QgbWF0Y2ggZXhwZWN0ZWQgc2l6ZSAoYnl0ZXMke2V4cGVjdGVkU2l6ZX0pLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWJpUGFyYW1ldGVycy5CeXRlc1NpemVNaXNtYXRjaEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBsZW5ndGggb2YgdGhlIHZhbHVlcyB0byBlbmNvZGUgZG9lcyBub3QgbWF0Y2ggdGhlIGxlbmd0aCBvZiB0aGUgQUJJIHBhcmFtZXRlcnMuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3N0cmluZycsICd1aW50MjU2J10pLCBbJ2hlbGxvJ10pXG4gKiAvLyBAZXJyb3I6IExlbmd0aE1pc21hdGNoRXJyb3I6IEFCSSBlbmNvZGluZyBwYXJhbXMvdmFsdWVzIGxlbmd0aCBtaXNtYXRjaC5cbiAqIC8vIEBlcnJvcjogRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbXMpOiAyXG4gKiAvLyBAZXJyb3I6IEdpdmVuIGxlbmd0aCAodmFsdWVzKTogMVxuICogYGBgXG4gKlxuICogIyMjIFNvbHV0aW9uXG4gKlxuICogUGFzcyB0aGUgY29ycmVjdCBudW1iZXIgb2YgdmFsdWVzIHRvIGVuY29kZS5cbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGEgW3ZhbGlkIEFCSSB0eXBlXShodHRwczovL2RvY3Muc29saWRpdHlsYW5nLm9yZy9lbi9kZXZlbG9wL2FiaS1zcGVjLmh0bWwjdHlwZXMpLlxuICovXG5leHBvcnQgY2xhc3MgTGVuZ3RoTWlzbWF0Y2hFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgZXhwZWN0ZWRMZW5ndGgsIGdpdmVuTGVuZ3RoLCB9KSB7XG4gICAgICAgIHN1cGVyKFtcbiAgICAgICAgICAgICdBQkkgZW5jb2RpbmcgcGFyYW1ldGVycy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoLicsXG4gICAgICAgICAgICBgRXhwZWN0ZWQgbGVuZ3RoIChwYXJhbWV0ZXJzKTogJHtleHBlY3RlZExlbmd0aH1gLFxuICAgICAgICAgICAgYEdpdmVuIGxlbmd0aCAodmFsdWVzKTogJHtnaXZlbkxlbmd0aH1gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0FiaVBhcmFtZXRlcnMuTGVuZ3RoTWlzbWF0Y2hFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaGUgdmFsdWUgcHJvdmlkZWQgaXMgbm90IGEgdmFsaWQgYXJyYXkgYXMgc3BlY2lmaWVkIGluIHRoZSBjb3JyZXNwb25kaW5nIEFCSSBwYXJhbWV0ZXIuXG4gKlxuICogIyMjIEV4YW1wbGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBBYmlQYXJhbWV0ZXJzIH0gZnJvbSAnb3gnXG4gKiAvLyAtLS1jdXQtLS1cbiAqIEFiaVBhcmFtZXRlcnMuZW5jb2RlKEFiaVBhcmFtZXRlcnMuZnJvbShbJ3VpbnQyNTZbM10nXSksIFs2OV0pXG4gKiBgYGBcbiAqXG4gKiAjIyMgU29sdXRpb25cbiAqXG4gKiBQYXNzIGFuIGFycmF5IHZhbHVlLlxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEFycmF5RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGEgdmFsaWQgYXJyYXkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93cyB3aGVuIHRoZSBBQkkgcGFyYW1ldGVyIHR5cGUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFiaVBhcmFtZXRlcnMgfSBmcm9tICdveCdcbiAqXG4gKiBBYmlQYXJhbWV0ZXJzLmRlY29kZShbeyB0eXBlOiAnbG9sJyB9XSwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTBmJylcbiAqIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICDihpEg4p2MIGludmFsaWQgdHlwZVxuICogLy8gQGVycm9yOiBBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3I6IFR5cGUgYGxvbGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHN1cGVyKGBUeXBlIFxcYCR7dHlwZX1cXGAgaXMgbm90IGEgdmFsaWQgQUJJIFR5cGUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBYmlQYXJhbWV0ZXJzLkludmFsaWRUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/AbiParameters.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Address.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Address.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidChecksumError: () => (/* binding */ InvalidChecksumError),\n/* harmony export */   InvalidInputError: () => (/* binding */ InvalidInputError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromPublicKey: () => (/* binding */ fromPublicKey),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Caches_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Caches.js */ \"(ssr)/../../node_modules/ox/_esm/core/Caches.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _PublicKey_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PublicKey.js */ \"(ssr)/../../node_modules/ox/_esm/core/PublicKey.js\");\n\n\n\n\n\nconst addressRegex = /*#__PURE__*/ /^0x[a-fA-F0-9]{40}$/;\n/**\n * Asserts that the given value is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.assert('0xdeadbeef')\n * // @error: InvalidAddressError: Address \"0xdeadbeef\" is invalid.\n * ```\n *\n * @param value - Value to assert if it is a valid address.\n * @param options - Assertion options.\n */\nfunction assert(value, options = {}) {\n    const { strict = true } = options;\n    if (!addressRegex.test(value))\n        throw new InvalidAddressError({\n            address: value,\n            cause: new InvalidInputError(),\n        });\n    if (strict) {\n        if (value.toLowerCase() === value)\n            return;\n        if (checksum(value) !== value)\n            throw new InvalidAddressError({\n                address: value,\n                cause: new InvalidChecksumError(),\n            });\n    }\n}\n/**\n * Computes the checksum address for the given {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.checksum('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @param address - The address to compute the checksum for.\n * @returns The checksummed address.\n */\nfunction checksum(address) {\n    if (_Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.has(address))\n        return _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.get(address);\n    assert(address, { strict: false });\n    const hexAddress = address.substring(2).toLowerCase();\n    const hash = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromString(hexAddress), { as: 'Bytes' });\n    const characters = hexAddress.split('');\n    for (let i = 0; i < 40; i += 2) {\n        if (hash[i >> 1] >> 4 >= 8 && characters[i]) {\n            characters[i] = characters[i].toUpperCase();\n        }\n        if ((hash[i >> 1] & 0x0f) >= 8 && characters[i + 1]) {\n            characters[i + 1] = characters[i + 1].toUpperCase();\n        }\n    }\n    const result = `0x${characters.join('')}`;\n    _Caches_js__WEBPACK_IMPORTED_MODULE_0__.checksum.set(address, result);\n    return result;\n}\n/**\n * Converts a stringified address to a typed (checksummed) {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e')\n * // @log: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0xa0cf798816d4b9b9866b5330eea46a18382f251e', {\n *   checksum: false\n * })\n * // @log: '0xa0cf798816d4b9b9866b5330eea46a18382f251e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('hello')\n * // @error: InvalidAddressError: Address \"0xa\" is invalid.\n * ```\n *\n * @param address - An address string to convert to a typed Address.\n * @param options - Conversion options.\n * @returns The typed Address.\n */\nfunction from(address, options = {}) {\n    const { checksum: checksumVal = false } = options;\n    assert(address);\n    if (checksumVal)\n        return checksum(address);\n    return address;\n}\n/**\n * Converts an ECDSA public key to an {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address, PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from(\n *   '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5',\n * )\n * const address = Address.fromPublicKey(publicKey)\n * // @log: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266'\n * ```\n *\n * @param publicKey - The ECDSA public key to convert to an {@link ox#Address.Address}.\n * @param options - Conversion options.\n * @returns The {@link ox#Address.Address} corresponding to the public key.\n */\nfunction fromPublicKey(publicKey, options = {}) {\n    const address = _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(`0x${_PublicKey_js__WEBPACK_IMPORTED_MODULE_3__.toHex(publicKey).slice(4)}`).substring(26);\n    return from(`0x${address}`, options);\n}\n/**\n * Checks if two {@link ox#Address.Address} are equal.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e'\n * )\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.isEqual(\n *   '0xa0cf798816d4b9b9866b5330eea46a18382f251e',\n *   '0xA0Cf798816D4b9b9866b5330EEa46a18382f251f'\n * )\n * // @log: false\n * ```\n *\n * @param addressA - The first address to compare.\n * @param addressB - The second address to compare.\n * @returns Whether the addresses are equal.\n */\nfunction isEqual(addressA, addressB) {\n    assert(addressA, { strict: false });\n    assert(addressB, { strict: false });\n    return addressA.toLowerCase() === addressB.toLowerCase();\n}\n/**\n * Checks if the given address is a valid {@link ox#Address.Address}.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xA0Cf798816D4b9b9866b5330EEa46a18382f251e')\n * // @log: true\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.validate('0xdeadbeef')\n * // @log: false\n * ```\n *\n * @param address - Value to check if it is a valid address.\n * @param options - Check options.\n * @returns Whether the address is a valid address.\n */\nfunction validate(address, options = {}) {\n    const { strict = true } = options ?? {};\n    try {\n        assert(address, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when an address is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Address } from 'ox'\n *\n * Address.from('0x123')\n * // @error: Address.InvalidAddressError: Address `0x123` is invalid.\n * ```\n */\nclass InvalidAddressError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ address, cause }) {\n        super(`Address \"${address}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidAddressError'\n        });\n    }\n}\n/** Thrown when an address is not a 20 byte (40 hexadecimal character) value. */\nclass InvalidInputError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address is not a 20 byte (40 hexadecimal character) value.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidInputError'\n        });\n    }\n}\n/** Thrown when an address does not match its checksum counterpart. */\nclass InvalidChecksumError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor() {\n        super('Address does not match its checksum counterpart.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Address.InvalidChecksumError'\n        });\n    }\n}\n//# sourceMappingURL=Address.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9BZGRyZXNzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDQTtBQUNKO0FBQ1U7QUFDNUMsbURBQW1ELEdBQUc7QUFDdEQ7QUFDQSw0Q0FBNEMseUJBQXlCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxRQUFRLGdEQUFlO0FBQ3ZCLGVBQWUsZ0RBQWU7QUFDOUIsc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxpQkFBaUIsK0NBQWMsQ0FBQyxpREFBZ0IsZ0JBQWdCLGFBQWE7QUFDN0U7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUMsSUFBSSxnREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQseUJBQXlCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlCQUF5QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELHlCQUF5QjtBQUN0RjtBQUNBLGlCQUFpQiwwQkFBMEI7QUFDM0M7QUFDTyw4Q0FBOEM7QUFDckQsb0JBQW9CLCtDQUFjLE1BQU0sZ0RBQWUscUJBQXFCO0FBQzVFLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHVCQUF1QixlQUFlO0FBQ3RDLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx5QkFBeUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLGdCQUFnQjtBQUNsQywwQkFBMEIsUUFBUTtBQUNsQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBZ0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sbUNBQW1DLGlEQUFnQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEFkZHJlc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBDYWNoZXMgZnJvbSAnLi9DYWNoZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIFB1YmxpY0tleSBmcm9tICcuL1B1YmxpY0tleS5qcyc7XG5jb25zdCBhZGRyZXNzUmVnZXggPSAvKiNfX1BVUkVfXyovIC9eMHhbYS1mQS1GMC05XXs0MH0kLztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuYXNzZXJ0KCcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5hc3NlcnQoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhkZWFkYmVlZlwiIGlzIGludmFsaWQuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBhc3NlcnQgaWYgaXQgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICogQHBhcmFtIG9wdGlvbnMgLSBBc3NlcnRpb24gb3B0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgIGlmICghYWRkcmVzc1JlZ2V4LnRlc3QodmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih7XG4gICAgICAgICAgICBhZGRyZXNzOiB2YWx1ZSxcbiAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZElucHV0RXJyb3IoKSxcbiAgICAgICAgfSk7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgICBpZiAodmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChjaGVja3N1bSh2YWx1ZSkgIT09IHZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHZhbHVlLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENoZWNrc3VtRXJyb3IoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNoZWNrc3VtIGFkZHJlc3MgZm9yIHRoZSBnaXZlbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmNoZWNrc3VtKCcweGEwY2Y3OTg4MTZkNGI5Yjk4NjZiNTMzMGVlYTQ2YTE4MzgyZjI1MWUnKVxuICogLy8gQGxvZzogJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gY29tcHV0ZSB0aGUgY2hlY2tzdW0gZm9yLlxuICogQHJldHVybnMgVGhlIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja3N1bShhZGRyZXNzKSB7XG4gICAgaWYgKENhY2hlcy5jaGVja3N1bS5oYXMoYWRkcmVzcykpXG4gICAgICAgIHJldHVybiBDYWNoZXMuY2hlY2tzdW0uZ2V0KGFkZHJlc3MpO1xuICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgY29uc3QgaGV4QWRkcmVzcyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgaGFzaCA9IEhhc2gua2VjY2FrMjU2KEJ5dGVzLmZyb21TdHJpbmcoaGV4QWRkcmVzcyksIHsgYXM6ICdCeXRlcycgfSk7XG4gICAgY29uc3QgY2hhcmFjdGVycyA9IGhleEFkZHJlc3Muc3BsaXQoJycpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoaGFzaFtpID4+IDFdID4+IDQgPj0gOCAmJiBjaGFyYWN0ZXJzW2ldKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gY2hhcmFjdGVyc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaGFzaFtpID4+IDFdICYgMHgwZikgPj0gOCAmJiBjaGFyYWN0ZXJzW2kgKyAxXSkge1xuICAgICAgICAgICAgY2hhcmFjdGVyc1tpICsgMV0gPSBjaGFyYWN0ZXJzW2kgKyAxXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IGAweCR7Y2hhcmFjdGVycy5qb2luKCcnKX1gO1xuICAgIENhY2hlcy5jaGVja3N1bS5zZXQoYWRkcmVzcywgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZ2lmaWVkIGFkZHJlc3MgdG8gYSB0eXBlZCAoY2hlY2tzdW1tZWQpIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJylcbiAqIC8vIEBsb2c6ICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWUnXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLmZyb20oJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsIHtcbiAqICAgY2hlY2tzdW06IGZhbHNlXG4gKiB9KVxuICogLy8gQGxvZzogJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnaGVsbG8nKVxuICogLy8gQGVycm9yOiBJbnZhbGlkQWRkcmVzc0Vycm9yOiBBZGRyZXNzIFwiMHhhXCIgaXMgaW52YWxpZC5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhZGRyZXNzIC0gQW4gYWRkcmVzcyBzdHJpbmcgdG8gY29udmVydCB0byBhIHR5cGVkIEFkZHJlc3MuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIENvbnZlcnNpb24gb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSB0eXBlZCBBZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShhZGRyZXNzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtOiBjaGVja3N1bVZhbCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGFzc2VydChhZGRyZXNzKTtcbiAgICBpZiAoY2hlY2tzdW1WYWwpXG4gICAgICAgIHJldHVybiBjaGVja3N1bShhZGRyZXNzKTtcbiAgICByZXR1cm4gYWRkcmVzcztcbn1cbi8qKlxuICogQ29udmVydHMgYW4gRUNEU0EgcHVibGljIGtleSB0byBhbiB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MsIFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKFxuICogICAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JyxcbiAqIClcbiAqIGNvbnN0IGFkZHJlc3MgPSBBZGRyZXNzLmZyb21QdWJsaWNLZXkocHVibGljS2V5KVxuICogLy8gQGxvZzogJzB4ZjM5ZmQ2ZTUxYWFkODhmNmY0Y2U2YWI4ODI3Mjc5Y2ZmZmI5MjI2NidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgRUNEU0EgcHVibGljIGtleSB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICogQHBhcmFtIG9wdGlvbnMgLSBDb252ZXJzaW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0FkZHJlc3MuQWRkcmVzc30gY29ycmVzcG9uZGluZyB0byB0aGUgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21QdWJsaWNLZXkocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBhZGRyZXNzID0gSGFzaC5rZWNjYWsyNTYoYDB4JHtQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KS5zbGljZSg0KX1gKS5zdWJzdHJpbmcoMjYpO1xuICAgIHJldHVybiBmcm9tKGAweCR7YWRkcmVzc31gLCBvcHRpb25zKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byB7QGxpbmsgb3gjQWRkcmVzcy5BZGRyZXNzfSBhcmUgZXF1YWwuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBZGRyZXNzIH0gZnJvbSAnb3gnXG4gKlxuICogQWRkcmVzcy5pc0VxdWFsKFxuICogICAnMHhhMGNmNzk4ODE2ZDRiOWI5ODY2YjUzMzBlZWE0NmExODM4MmYyNTFlJyxcbiAqICAgJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZSdcbiAqIClcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuaXNFcXVhbChcbiAqICAgJzB4YTBjZjc5ODgxNmQ0YjliOTg2NmI1MzMwZWVhNDZhMTgzODJmMjUxZScsXG4gKiAgICcweEEwQ2Y3OTg4MTZENGI5Yjk4NjZiNTMzMEVFYTQ2YTE4MzgyZjI1MWYnXG4gKiApXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFkZHJlc3NBIC0gVGhlIGZpcnN0IGFkZHJlc3MgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBhZGRyZXNzQiAtIFRoZSBzZWNvbmQgYWRkcmVzcyB0byBjb21wYXJlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgYWRkcmVzc2VzIGFyZSBlcXVhbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYWRkcmVzc0EsIGFkZHJlc3NCKSB7XG4gICAgYXNzZXJ0KGFkZHJlc3NBLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgYXNzZXJ0KGFkZHJlc3NCLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGFkZHJlc3NBLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3NCLnRvTG93ZXJDYXNlKCk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYWRkcmVzcyBpcyBhIHZhbGlkIHtAbGluayBveCNBZGRyZXNzLkFkZHJlc3N9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MudmFsaWRhdGUoJzB4QTBDZjc5ODgxNkQ0YjliOTg2NmI1MzMwRUVhNDZhMTgzODJmMjUxZScpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFkZHJlc3MgfSBmcm9tICdveCdcbiAqXG4gKiBBZGRyZXNzLnZhbGlkYXRlKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFZhbHVlIHRvIGNoZWNrIGlmIGl0IGlzIGEgdmFsaWQgYWRkcmVzcy5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQ2hlY2sgb3B0aW9ucy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBhZGRyZXNzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoYWRkcmVzcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzdHJpY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChhZGRyZXNzLCB7IHN0cmljdCB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQWRkcmVzcyB9IGZyb20gJ294J1xuICpcbiAqIEFkZHJlc3MuZnJvbSgnMHgxMjMnKVxuICogLy8gQGVycm9yOiBBZGRyZXNzLkludmFsaWRBZGRyZXNzRXJyb3I6IEFkZHJlc3MgYDB4MTIzYCBpcyBpbnZhbGlkLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQWRkcmVzc0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBhZGRyZXNzLCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBBZGRyZXNzIFwiJHthZGRyZXNzfVwiIGlzIGludmFsaWQuYCwge1xuICAgICAgICAgICAgY2F1c2UsXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQWRkcmVzc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBpcyBub3QgYSAyMCBieXRlICg0MCBoZXhhZGVjaW1hbCBjaGFyYWN0ZXIpIHZhbHVlLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRJbnB1dEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCdBZGRyZXNzIGlzIG5vdCBhIDIwIGJ5dGUgKDQwIGhleGFkZWNpbWFsIGNoYXJhY3RlcikgdmFsdWUuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBZGRyZXNzLkludmFsaWRJbnB1dEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gYW4gYWRkcmVzcyBkb2VzIG5vdCBtYXRjaCBpdHMgY2hlY2tzdW0gY291bnRlcnBhcnQuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZENoZWNrc3VtRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ0FkZHJlc3MgZG9lcyBub3QgbWF0Y2ggaXRzIGNoZWNrc3VtIGNvdW50ZXJwYXJ0LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQWRkcmVzcy5JbnZhbGlkQ2hlY2tzdW1FcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Address.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/BlockOverrides.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/BlockOverrides.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Withdrawal.js */ \"(ssr)/../../node_modules/ox/_esm/core/Withdrawal.js\");\n\n\n/**\n * Converts an {@link ox#BlockOverrides.Rpc} to an {@link ox#BlockOverrides.BlockOverrides}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.fromRpc({\n *   baseFeePerGas: '0x1',\n *   blobBaseFee: '0x2',\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: '0x4',\n *   number: '0x5',\n *   prevRandao: '0x6',\n *   time: '0x1234567890',\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: '0x1',\n *       index: '0x0',\n *       validatorIndex: '0x1',\n *     },\n *   ],\n * })\n * ```\n *\n * @param rpcBlockOverrides - The RPC block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.BlockOverrides}.\n */\nfunction fromRpc(rpcBlockOverrides) {\n    return {\n        ...(rpcBlockOverrides.baseFeePerGas && {\n            baseFeePerGas: BigInt(rpcBlockOverrides.baseFeePerGas),\n        }),\n        ...(rpcBlockOverrides.blobBaseFee && {\n            blobBaseFee: BigInt(rpcBlockOverrides.blobBaseFee),\n        }),\n        ...(rpcBlockOverrides.feeRecipient && {\n            feeRecipient: rpcBlockOverrides.feeRecipient,\n        }),\n        ...(rpcBlockOverrides.gasLimit && {\n            gasLimit: BigInt(rpcBlockOverrides.gasLimit),\n        }),\n        ...(rpcBlockOverrides.number && {\n            number: BigInt(rpcBlockOverrides.number),\n        }),\n        ...(rpcBlockOverrides.prevRandao && {\n            prevRandao: BigInt(rpcBlockOverrides.prevRandao),\n        }),\n        ...(rpcBlockOverrides.time && {\n            time: BigInt(rpcBlockOverrides.time),\n        }),\n        ...(rpcBlockOverrides.withdrawals && {\n            withdrawals: rpcBlockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.fromRpc),\n        }),\n    };\n}\n/**\n * Converts an {@link ox#BlockOverrides.BlockOverrides} to an {@link ox#BlockOverrides.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { BlockOverrides } from 'ox'\n *\n * const blockOverrides = BlockOverrides.toRpc({\n *   baseFeePerGas: 1n,\n *   blobBaseFee: 2n,\n *   feeRecipient: '0x0000000000000000000000000000000000000000',\n *   gasLimit: 4n,\n *   number: 5n,\n *   prevRandao: 6n,\n *   time: 78187493520n,\n *   withdrawals: [\n *     {\n *       address: '0x0000000000000000000000000000000000000000',\n *       amount: 1n,\n *       index: 0,\n *       validatorIndex: 1,\n *     },\n *   ],\n * })\n * ```\n *\n * @param blockOverrides - The block overrides to convert.\n * @returns An instantiated {@link ox#BlockOverrides.Rpc}.\n */\nfunction toRpc(blockOverrides) {\n    return {\n        ...(typeof blockOverrides.baseFeePerGas === 'bigint' && {\n            baseFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.baseFeePerGas),\n        }),\n        ...(typeof blockOverrides.blobBaseFee === 'bigint' && {\n            blobBaseFee: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.blobBaseFee),\n        }),\n        ...(typeof blockOverrides.feeRecipient === 'string' && {\n            feeRecipient: blockOverrides.feeRecipient,\n        }),\n        ...(typeof blockOverrides.gasLimit === 'bigint' && {\n            gasLimit: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.gasLimit),\n        }),\n        ...(typeof blockOverrides.number === 'bigint' && {\n            number: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.number),\n        }),\n        ...(typeof blockOverrides.prevRandao === 'bigint' && {\n            prevRandao: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.prevRandao),\n        }),\n        ...(typeof blockOverrides.time === 'bigint' && {\n            time: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(blockOverrides.time),\n        }),\n        ...(blockOverrides.withdrawals && {\n            withdrawals: blockOverrides.withdrawals.map(_Withdrawal_js__WEBPACK_IMPORTED_MODULE_0__.toRpc),\n        }),\n    };\n}\n//# sourceMappingURL=BlockOverrides.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CbG9ja092ZXJyaWRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWdDO0FBQ2M7QUFDOUM7QUFDQSxnQkFBZ0IsNkJBQTZCLE9BQU8sdUNBQXVDO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsdUNBQXVDO0FBQ3BFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwyREFBMkQsbURBQWtCO0FBQzdFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDLE9BQU8sNEJBQTRCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEJBQTRCO0FBQ3pEO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLCtDQUFjO0FBQ3pDLFNBQVM7QUFDVDtBQUNBLHlCQUF5QiwrQ0FBYztBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNCQUFzQiwrQ0FBYztBQUNwQyxTQUFTO0FBQ1Q7QUFDQSxvQkFBb0IsK0NBQWM7QUFDbEMsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLCtDQUFjO0FBQ3RDLFNBQVM7QUFDVDtBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQyxTQUFTO0FBQ1Q7QUFDQSx3REFBd0QsaURBQWdCO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEJsb2NrT3ZlcnJpZGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBXaXRoZHJhd2FsIGZyb20gJy4vV2l0aGRyYXdhbC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9IHRvIGFuIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5CbG9ja092ZXJyaWRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCbG9ja092ZXJyaWRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJsb2NrT3ZlcnJpZGVzID0gQmxvY2tPdmVycmlkZXMuZnJvbVJwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6ICcweDEnLFxuICogICBibG9iQmFzZUZlZTogJzB4MicsXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiAnMHg0JyxcbiAqICAgbnVtYmVyOiAnMHg1JyxcbiAqICAgcHJldlJhbmRhbzogJzB4NicsXG4gKiAgIHRpbWU6ICcweDEyMzQ1Njc4OTAnLFxuICogICB3aXRoZHJhd2FsczogW1xuICogICAgIHtcbiAqICAgICAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgICAgYW1vdW50OiAnMHgxJyxcbiAqICAgICAgIGluZGV4OiAnMHgwJyxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqICAgICB9LFxuICogICBdLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBycGNCbG9ja092ZXJyaWRlcyAtIFRoZSBSUEMgYmxvY2sgb3ZlcnJpZGVzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21ScGMocnBjQmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyAmJiB7XG4gICAgICAgICAgICBiYXNlRmVlUGVyR2FzOiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuYmFzZUZlZVBlckdhcyksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuYmxvYkJhc2VGZWUgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4ocnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ICYmIHtcbiAgICAgICAgICAgIGZlZVJlY2lwaWVudDogcnBjQmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50LFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLmdhc0xpbWl0ICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBCaWdJbnQocnBjQmxvY2tPdmVycmlkZXMuZ2FzTGltaXQpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLm51bWJlciAmJiB7XG4gICAgICAgICAgICBudW1iZXI6IEJpZ0ludChycGNCbG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8gJiYge1xuICAgICAgICAgICAgcHJldlJhbmRhbzogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnByZXZSYW5kYW8pLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUgJiYge1xuICAgICAgICAgICAgdGltZTogQmlnSW50KHJwY0Jsb2NrT3ZlcnJpZGVzLnRpbWUpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHJwY0Jsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzICYmIHtcbiAgICAgICAgICAgIHdpdGhkcmF3YWxzOiBycGNCbG9ja092ZXJyaWRlcy53aXRoZHJhd2Fscy5tYXAoV2l0aGRyYXdhbC5mcm9tUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0Jsb2NrT3ZlcnJpZGVzLkJsb2NrT3ZlcnJpZGVzfSB0byBhbiB7QGxpbmsgb3gjQmxvY2tPdmVycmlkZXMuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJsb2NrT3ZlcnJpZGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYmxvY2tPdmVycmlkZXMgPSBCbG9ja092ZXJyaWRlcy50b1JwYyh7XG4gKiAgIGJhc2VGZWVQZXJHYXM6IDFuLFxuICogICBibG9iQmFzZUZlZTogMm4sXG4gKiAgIGZlZVJlY2lwaWVudDogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGdhc0xpbWl0OiA0bixcbiAqICAgbnVtYmVyOiA1bixcbiAqICAgcHJldlJhbmRhbzogNm4sXG4gKiAgIHRpbWU6IDc4MTg3NDkzNTIwbixcbiAqICAgd2l0aGRyYXdhbHM6IFtcbiAqICAgICB7XG4gKiAgICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICAgIGFtb3VudDogMW4sXG4gKiAgICAgICBpbmRleDogMCxcbiAqICAgICAgIHZhbGlkYXRvckluZGV4OiAxLFxuICogICAgIH0sXG4gKiAgIF0sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJsb2NrT3ZlcnJpZGVzIC0gVGhlIGJsb2NrIG92ZXJyaWRlcyB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gaW5zdGFudGlhdGVkIHtAbGluayBveCNCbG9ja092ZXJyaWRlcy5ScGN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoYmxvY2tPdmVycmlkZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGJhc2VGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJhc2VGZWVQZXJHYXMpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5ibG9iQmFzZUZlZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgYmxvYkJhc2VGZWU6IEhleC5mcm9tTnVtYmVyKGJsb2NrT3ZlcnJpZGVzLmJsb2JCYXNlRmVlKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZmVlUmVjaXBpZW50ID09PSAnc3RyaW5nJyAmJiB7XG4gICAgICAgICAgICBmZWVSZWNpcGllbnQ6IGJsb2NrT3ZlcnJpZGVzLmZlZVJlY2lwaWVudCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMuZ2FzTGltaXQgPT09ICdiaWdpbnQnICYmIHtcbiAgICAgICAgICAgIGdhc0xpbWl0OiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5nYXNMaW1pdCksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4odHlwZW9mIGJsb2NrT3ZlcnJpZGVzLm51bWJlciA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgbnVtYmVyOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5udW1iZXIpLFxuICAgICAgICB9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvID09PSAnYmlnaW50JyAmJiB7XG4gICAgICAgICAgICBwcmV2UmFuZGFvOiBIZXguZnJvbU51bWJlcihibG9ja092ZXJyaWRlcy5wcmV2UmFuZGFvKSxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLih0eXBlb2YgYmxvY2tPdmVycmlkZXMudGltZSA9PT0gJ2JpZ2ludCcgJiYge1xuICAgICAgICAgICAgdGltZTogSGV4LmZyb21OdW1iZXIoYmxvY2tPdmVycmlkZXMudGltZSksXG4gICAgICAgIH0pLFxuICAgICAgICAuLi4oYmxvY2tPdmVycmlkZXMud2l0aGRyYXdhbHMgJiYge1xuICAgICAgICAgICAgd2l0aGRyYXdhbHM6IGJsb2NrT3ZlcnJpZGVzLndpdGhkcmF3YWxzLm1hcChXaXRoZHJhd2FsLnRvUnBjKSxcbiAgICAgICAgfSksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJsb2NrT3ZlcnJpZGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/BlockOverrides.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Bytes.js":
/*!************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Bytes.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidBytesBooleanError: () => (/* binding */ InvalidBytesBooleanError),\n/* harmony export */   InvalidBytesTypeError: () => (/* binding */ InvalidBytesTypeError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromArray: () => (/* binding */ fromArray),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/ox/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst decoder = /*#__PURE__*/ new TextDecoder();\nconst encoder = /*#__PURE__*/ new TextEncoder();\n/**\n * Asserts if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.assert('abc')\n * // @error: Bytes.InvalidBytesTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid Bytes value.\n * // @error: Bytes values must be of type `Uint8Array`.\n * ```\n *\n * @param value - Value to assert.\n */\nfunction assert(value) {\n    if (value instanceof Uint8Array)\n        return;\n    if (!value)\n        throw new InvalidBytesTypeError(value);\n    if (typeof value !== 'object')\n        throw new InvalidBytesTypeError(value);\n    if (!('BYTES_PER_ELEMENT' in value))\n        throw new InvalidBytesTypeError(value);\n    if (value.BYTES_PER_ELEMENT !== 1 || value.constructor.name !== 'Uint8Array')\n        throw new InvalidBytesTypeError(value);\n}\n/**\n * Concatenates two or more {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.concat(\n *   Bytes.from([1]),\n *   Bytes.from([69]),\n *   Bytes.from([420, 69]),\n * )\n * // @log: Uint8Array [ 1, 69, 420, 69 ]\n * ```\n *\n * @param values - Values to concatenate.\n * @returns Concatenated {@link ox#Bytes.Bytes}.\n */\nfunction concat(...values) {\n    let length = 0;\n    for (const arr of values) {\n        length += arr.length;\n    }\n    const result = new Uint8Array(length);\n    for (let i = 0, index = 0; i < values.length; i++) {\n        const arr = values[i];\n        result.set(arr, index);\n        index += arr.length;\n    }\n    return result;\n}\n/**\n * Instantiates a {@link ox#Bytes.Bytes} value from a `Uint8Array`, a hex string, or an array of unsigned 8-bit integers.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Bytes.fromBoolean`\n *\n * - `Bytes.fromString`\n *\n * - `Bytes.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.from([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n *\n * const data = Bytes.from('0xdeadbeef')\n * // @log: Uint8Array([222, 173, 190, 239])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return value;\n    if (typeof value === 'string')\n        return fromHex(value);\n    return fromArray(value);\n}\n/**\n * Converts an array of unsigned 8-bit integers into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromArray([255, 124, 5, 4])\n * // @log: Uint8Array([255, 124, 5, 4])\n * ```\n *\n * @param value - Value to convert.\n * @returns A {@link ox#Bytes.Bytes} instance.\n */\nfunction fromArray(value) {\n    return value instanceof Uint8Array ? value : new Uint8Array(value);\n}\n/**\n * Encodes a boolean value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true)\n * // @log: Uint8Array([1])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromBoolean(true, { size: 32 })\n * // @log: Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])\n * ```\n *\n * @param value - Boolean value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromBoolean(value, options = {}) {\n    const { size } = options;\n    const bytes = new Uint8Array(1);\n    bytes[0] = Number(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padLeft(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromHex('0x48656c6c6f20776f726c6421', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Hex.Hex} value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromHex(value, options = {}) {\n    const { size } = options;\n    let hex = value;\n    if (size) {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_1__.assertSize(value, size);\n        hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value, size);\n    }\n    let hexString = hex.slice(2);\n    if (hexString.length % 2)\n        hexString = `0${hexString}`;\n    const length = hexString.length / 2;\n    const bytes = new Uint8Array(length);\n    for (let index = 0, j = 0; index < length; index++) {\n        const nibbleLeft = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        const nibbleRight = _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToBase16(hexString.charCodeAt(j++));\n        if (nibbleLeft === undefined || nibbleRight === undefined) {\n            throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError(`Invalid byte sequence (\"${hexString[j - 2]}${hexString[j - 1]}\" in \"${hexString}\").`);\n        }\n        bytes[index] = nibbleLeft * 16 + nibbleRight;\n    }\n    return bytes;\n}\n/**\n * Encodes a number value into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420)\n * // @log: Uint8Array([1, 164])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromNumber(420, { size: 4 })\n * // @log: Uint8Array([0, 0, 1, 164])\n * ```\n *\n * @param value - Number value to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromNumber(value, options) {\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, options);\n    return fromHex(hex);\n}\n/**\n * Encodes a string into {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33])\n * ```\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.fromString('Hello world!', { size: 32 })\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n * ```\n *\n * @param value - String to encode.\n * @param options - Encoding options.\n * @returns Encoded {@link ox#Bytes.Bytes}.\n */\nfunction fromString(value, options = {}) {\n    const { size } = options;\n    const bytes = encoder.encode(value);\n    if (typeof size === 'number') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n        return padRight(bytes, size);\n    }\n    return bytes;\n}\n/**\n * Checks if two {@link ox#Bytes.Bytes} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([1]))\n * // @log: true\n *\n * Bytes.isEqual(Bytes.from([1]), Bytes.from([2]))\n * // @log: false\n * ```\n *\n * @param bytesA - First {@link ox#Bytes.Bytes} value.\n * @param bytesB - Second {@link ox#Bytes.Bytes} value.\n * @returns `true` if the two values are equal, otherwise `false`.\n */\nfunction isEqual(bytesA, bytesB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_4__.equalBytes)(bytesA, bytesB);\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.from([1]), 4)\n * // @log: Uint8Array([0, 0, 0, 1])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padLeft(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Bytes.Bytes} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padRight(Bytes.from([1]), 4)\n * // @log: Uint8Array([1, 0, 0, 0])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value to pad.\n * @param size - Size to pad the {@link ox#Bytes.Bytes} value to.\n * @returns Padded {@link ox#Bytes.Bytes} value.\n */\nfunction padRight(value, size) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates random {@link ox#Bytes.Bytes} of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const bytes = Bytes.random(32)\n * // @log: Uint8Array([... x32])\n * ```\n *\n * @param length - Length of the random {@link ox#Bytes.Bytes} to generate.\n * @returns Random {@link ox#Bytes.Bytes} of the specified length.\n */\nfunction random(length) {\n    return crypto.getRandomValues(new Uint8Array(length));\n}\n/**\n * Retrieves the size of a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.size(Bytes.from([1, 2, 3, 4]))\n * // @log: 4\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Size of the {@link ox#Bytes.Bytes} value.\n */\nfunction size(value) {\n    return value.length;\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(\n *   Bytes.from([1, 2, 3, 4, 5, 6, 7, 8, 9]),\n *   1,\n *   4,\n * )\n * // @log: Uint8Array([2, 3, 4])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value.\n * @param start - Start offset.\n * @param end - End offset.\n * @param options - Slice options.\n * @returns Sliced {@link ox#Bytes.Bytes} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = value.slice(start, end);\n    if (strict)\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a bigint.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBigInt(Bytes.from([1, 164]))\n * // @log: 420n\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded bigint.\n */\nfunction toBigInt(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toBigInt(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a boolean.\n *\n * @example\n * ```ts\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([1]))\n * // @log: true\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Decoding options.\n * @returns Decoded boolean.\n */\nfunction toBoolean(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimLeft(bytes_);\n    }\n    if (bytes_.length > 1 || bytes_[0] > 1)\n        throw new InvalidBytesBooleanError(bytes_);\n    return Boolean(bytes_[0]);\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toHex(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value, options = {}) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(value, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a number.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toNumber(Bytes.from([1, 164]))\n * // @log: 420\n * ```\n */\nfunction toNumber(bytes, options = {}) {\n    const { size } = options;\n    if (typeof size !== 'undefined')\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes, size);\n    const hex = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes, options);\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.toNumber(hex, options);\n}\n/**\n * Decodes a {@link ox#Bytes.Bytes} into a string.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * const data = Bytes.toString(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: 'Hello world'\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} to decode.\n * @param options - Options.\n * @returns Decoded string.\n */\nfunction toString(bytes, options = {}) {\n    const { size } = options;\n    let bytes_ = bytes;\n    if (typeof size !== 'undefined') {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(bytes_, size);\n        bytes_ = trimRight(bytes_);\n    }\n    return decoder.decode(bytes_);\n}\n/**\n * Trims leading zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimLeft(Bytes.from([0, 0, 0, 0, 1, 2, 3]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimLeft(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.trimRight(Bytes.from([1, 2, 3, 0, 0, 0, 0]))\n * // @log: Uint8Array([1, 2, 3])\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} value.\n * @returns Trimmed {@link ox#Bytes.Bytes} value.\n */\nfunction trimRight(value) {\n    return _internal_bytes_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Checks if the given value is {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.validate('0x')\n * // @log: false\n *\n * Bytes.validate(Bytes.from([1, 2, 3]))\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns `true` if the value is {@link ox#Bytes.Bytes}, otherwise `false`.\n */\nfunction validate(value) {\n    try {\n        assert(value);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the bytes value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.toBoolean(Bytes.from([5]))\n * // @error: Bytes.InvalidBytesBooleanError: Bytes value `[5]` is not a valid boolean.\n * // @error: The bytes array must contain a single byte of either a `0` or `1` value.\n * ```\n */\nclass InvalidBytesBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(bytes) {\n        super(`Bytes value \\`${bytes}\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The bytes array must contain a single byte of either a `0` or `1` value.',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesBooleanError'\n        });\n    }\n}\n/**\n * Thrown when a value cannot be converted to bytes.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Bytes } from 'ox'\n *\n * Bytes.from('foo')\n * // @error: Bytes.InvalidBytesTypeError: Value `foo` of type `string` is an invalid Bytes value.\n * ```\n */\nclass InvalidBytesTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid Bytes value.`, {\n            metaMessages: ['Bytes values must be of type `Bytes`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.InvalidBytesTypeError'\n        });\n    }\n}\n/**\n * Thrown when a size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromString('Hello World!', { size: 8 })\n * // @error: Bytes.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when a slice offset is out-of-bounds.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.slice(Bytes.from([1, 2, 3]), 4)\n * // @error: Bytes.SliceOffsetOutOfBoundsError: Slice starting at offset `4` is out-of-bounds (size: `3`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when a the padding size exceeds the maximum allowed size.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.padLeft(Bytes.fromString('Hello World!'), 8)\n * // @error: [Bytes.SizeExceedsPaddingSizeError: Bytes size (`12`) exceeds padding size (`8`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Bytes.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9CeXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDcEI7QUFDTjtBQUNFO0FBQ2M7QUFDRTtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFCQUFxQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscUJB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UTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLDRCQUE0QixVQUFVLEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEJ5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVxdWFsQnl0ZXMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgSnNvbiBmcm9tICcuL0pzb24uanMnO1xuaW1wb3J0ICogYXMgaW50ZXJuYWwgZnJvbSAnLi9pbnRlcm5hbC9ieXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9oZXggZnJvbSAnLi9pbnRlcm5hbC9oZXguanMnO1xuY29uc3QgZGVjb2RlciA9IC8qI19fUFVSRV9fKi8gbmV3IFRleHREZWNvZGVyKCk7XG5jb25zdCBlbmNvZGVyID0gLyojX19QVVJFX18qLyBuZXcgVGV4dEVuY29kZXIoKTtcbi8qKlxuICogQXNzZXJ0cyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuXG4gKiAvLyBAZXJyb3I6IEJ5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYFVpbnQ4QXJyYXlgLlxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVmFsdWUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzVHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAoISgnQllURVNfUEVSX0VMRU1FTlQnIGluIHZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG4gICAgaWYgKHZhbHVlLkJZVEVTX1BFUl9FTEVNRU5UICE9PSAxIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgIT09ICdVaW50OEFycmF5JylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCeXRlc1R5cGVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBieXRlcyA9IEJ5dGVzLmNvbmNhdChcbiAqICAgQnl0ZXMuZnJvbShbMV0pLFxuICogICBCeXRlcy5mcm9tKFs2OV0pLFxuICogICBCeXRlcy5mcm9tKFs0MjAsIDY5XSksXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsgMSwgNjksIDQyMCwgNjkgXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlcyAtIFZhbHVlcyB0byBjb25jYXRlbmF0ZS5cbiAqIEByZXR1cm5zIENvbmNhdGVuYXRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0KC4uLnZhbHVlcykge1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgYXJyIG9mIHZhbHVlcykge1xuICAgICAgICBsZW5ndGggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaW5kZXggPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlc1tpXTtcbiAgICAgICAgcmVzdWx0LnNldChhcnIsIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBmcm9tIGEgYFVpbnQ4QXJyYXlgLCBhIGhleCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHVuc2lnbmVkIDgtYml0IGludGVnZXJzLlxuICpcbiAqIDo6OnRpcFxuICpcbiAqIFRvIGluc3RhbnRpYXRlIGZyb20gYSAqKkJvb2xlYW4qKiwgKipTdHJpbmcqKiwgb3IgKipOdW1iZXIqKiwgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIC0gYEJ5dGVzLmZyb21Cb29sZWFuYFxuICpcbiAqIC0gYEJ5dGVzLmZyb21TdHJpbmdgXG4gKlxuICogLSBgQnl0ZXMuZnJvbU51bWJlcmBcbiAqXG4gKiA6OjpcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbShbMjU1LCAxMjQsIDUsIDRdKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMjU1LCAxMjQsIDUsIDRdKVxuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tKCcweGRlYWRiZWVmJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzIyMiwgMTczLCAxOTAsIDIzOV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBWYWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGluc3RhbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgIHJldHVybiBmcm9tQXJyYXkodmFsdWUpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiBhcnJheSBvZiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VycyBpbnRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tQXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzI1NSwgMTI0LCA1LCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gdmFsdWUgOiBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21Cb29sZWFuKHRydWUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMV0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBCb29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICBieXRlc1swXSA9IE51bWJlcih2YWx1ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIEVuY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbUhleCgnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21IZXgodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgaGV4ID0gdmFsdWU7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfaGV4LmFzc2VydFNpemUodmFsdWUsIHNpemUpO1xuICAgICAgICBoZXggPSBIZXgucGFkUmlnaHQodmFsdWUsIHNpemUpO1xuICAgIH1cbiAgICBsZXQgaGV4U3RyaW5nID0gaGV4LnNsaWNlKDIpO1xuICAgIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMilcbiAgICAgICAgaGV4U3RyaW5nID0gYDAke2hleFN0cmluZ31gO1xuICAgIGNvbnN0IGxlbmd0aCA9IGhleFN0cmluZy5sZW5ndGggLyAyO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGogPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb25zdCBuaWJibGVMZWZ0ID0gaW50ZXJuYWwuY2hhckNvZGVUb0Jhc2UxNihoZXhTdHJpbmcuY2hhckNvZGVBdChqKyspKTtcbiAgICAgICAgY29uc3QgbmliYmxlUmlnaHQgPSBpbnRlcm5hbC5jaGFyQ29kZVRvQmFzZTE2KGhleFN0cmluZy5jaGFyQ29kZUF0KGorKykpO1xuICAgICAgICBpZiAobmliYmxlTGVmdCA9PT0gdW5kZWZpbmVkIHx8IG5pYmJsZVJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKGBJbnZhbGlkIGJ5dGUgc2VxdWVuY2UgKFwiJHtoZXhTdHJpbmdbaiAtIDJdfSR7aGV4U3RyaW5nW2ogLSAxXX1cIiBpbiBcIiR7aGV4U3RyaW5nfVwiKS5gKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlc1tpbmRleF0gPSBuaWJibGVMZWZ0ICogMTYgKyBuaWJibGVSaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgbnVtYmVyIHZhbHVlIGludG8ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZGF0YSA9IEJ5dGVzLmZyb21OdW1iZXIoNDIwKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogNCB9KVxuICogLy8gQGxvZzogVWludDhBcnJheShbMCwgMCwgMSwgMTY0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIE51bWJlciB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEVuY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBFbmNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21OdW1iZXIodmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmcm9tSGV4KGhleCk7XG59XG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgaW50byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gd29ybGQhJylcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyB3b3JsZCEnLCB7IHNpemU6IDMyIH0pXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gU3RyaW5nIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRW5jb2Rpbmcgb3B0aW9ucy5cbiAqIEByZXR1cm5zIEVuY29kZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgICAgICByZXR1cm4gcGFkUmlnaHQoYnl0ZXMsIHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5pc0VxdWFsKEJ5dGVzLmZyb20oWzFdKSwgQnl0ZXMuZnJvbShbMV0pKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEJ5dGVzLmlzRXF1YWwoQnl0ZXMuZnJvbShbMV0pLCBCeXRlcy5mcm9tKFsyXSkpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzQSAtIEZpcnN0IHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcGFyYW0gYnl0ZXNCIC0gU2Vjb25kIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHR3byB2YWx1ZXMgYXJlIGVxdWFsLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoYnl0ZXNBLCBieXRlc0IpIHtcbiAgICByZXR1cm4gZXF1YWxCeXRlcyhieXRlc0EsIGJ5dGVzQik7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMucGFkTGVmdChCeXRlcy5mcm9tKFsxXSksIDQpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFswLCAwLCAwLCAxXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gcGFkLlxuICogQHBhcmFtIHNpemUgLSBTaXplIHRvIHBhZCB0aGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0by5cbiAqIEByZXR1cm5zIFBhZGRlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIHRoZSByaWdodCB3aXRoIHplcm8gYnl0ZXMgdW50aWwgaXQgcmVhY2hlcyB0aGUgZ2l2ZW4gYHNpemVgIChkZWZhdWx0OiAzMiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZFJpZ2h0KEJ5dGVzLmZyb20oWzFdKSwgNClcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDAsIDAsIDBdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFNpemUgdG8gcGFkIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvLlxuICogQHJldHVybnMgUGFkZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWRSaWdodCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAncmlnaHQnLCBzaXplIH0pO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBveCNCeXRlcy5CeXRlc30gb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGJ5dGVzID0gQnl0ZXMucmFuZG9tKDMyKVxuICogLy8gQGxvZzogVWludDhBcnJheShbLi4uIHgzMl0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gTGVuZ3RoIG9mIHRoZSByYW5kb20ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBnZW5lcmF0ZS5cbiAqIEByZXR1cm5zIFJhbmRvbSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9mIHRoZSBzcGVjaWZpZWQgbGVuZ3RoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tKGxlbmd0aCkge1xuICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGxlbmd0aCkpO1xufVxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNpemUgb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5zaXplKEJ5dGVzLmZyb20oWzEsIDIsIDMsIDRdKSlcbiAqIC8vIEBsb2c6IDRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKiBAcmV0dXJucyBTaXplIG9mIHRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2l6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG59XG4vKipcbiAqIFJldHVybnMgYSBzZWN0aW9uIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBnaXZlbiBhIHN0YXJ0L2VuZCBieXRlcyBvZmZzZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKFxuICogICBCeXRlcy5mcm9tKFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XSksXG4gKiAgIDEsXG4gKiAgIDQsXG4gKiApXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsyLCAzLCA0XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHBhcmFtIHN0YXJ0IC0gU3RhcnQgb2Zmc2V0LlxuICogQHBhcmFtIGVuZCAtIEVuZCBvZmZzZXQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFNsaWNlIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBTbGljZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKHZhbHVlLCBzdGFydCwgZW5kLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCB9ID0gb3B0aW9ucztcbiAgICBpbnRlcm5hbC5hc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpO1xuICAgIGNvbnN0IHZhbHVlXyA9IHZhbHVlLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIGlmIChzdHJpY3QpXG4gICAgICAgIGludGVybmFsLmFzc2VydEVuZE9mZnNldCh2YWx1ZV8sIHN0YXJ0LCBlbmQpO1xuICAgIHJldHVybiB2YWx1ZV87XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBiaWdpbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQmlnSW50KEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGJ5dGVzIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBEZWNvZGluZyBvcHRpb25zLlxuICogQHJldHVybnMgRGVjb2RlZCBiaWdpbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0JpZ0ludChieXRlcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIGludGVybmFsLmFzc2VydFNpemUoYnl0ZXMsIHNpemUpO1xuICAgIGNvbnN0IGhleCA9IEhleC5mcm9tQnl0ZXMoYnl0ZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBIZXgudG9CaWdJbnQoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gaW50byBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFsxXSkpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIERlY29kaW5nIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXNfID0gYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGJ5dGVzXywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzXyA9IHRyaW1MZWZ0KGJ5dGVzXyk7XG4gICAgfVxuICAgIGlmIChieXRlc18ubGVuZ3RoID4gMSB8fCBieXRlc19bMF0gPiAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJ5dGVzQm9vbGVhbkVycm9yKGJ5dGVzXyk7XG4gICAgcmV0dXJuIEJvb2xlYW4oYnl0ZXNfWzBdKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMudG9IZXgoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyAnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyh2YWx1ZSwgb3B0aW9ucyk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IGludG8gYSBudW1iZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvTnVtYmVyKEJ5dGVzLmZyb20oWzEsIDE2NF0pKVxuICogLy8gQGxvZzogNDIwXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVtYmVyKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHR5cGVvZiBzaXplICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgY29uc3QgaGV4ID0gSGV4LmZyb21CeXRlcyhieXRlcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEhleC50b051bWJlcihoZXgsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBkYXRhID0gQnl0ZXMudG9TdHJpbmcoQnl0ZXMuZnJvbShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSkpXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBEZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGJ5dGVzXyA9IGJ5dGVzO1xuICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShieXRlc18sIHNpemUpO1xuICAgICAgICBieXRlc18gPSB0cmltUmlnaHQoYnl0ZXNfKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ5dGVzXyk7XG59XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRyaW1MZWZ0KEJ5dGVzLmZyb20oWzAsIDAsIDAsIDAsIDEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEsIDIsIDNdKVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqIEByZXR1cm5zIFRyaW1tZWQge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy50cmltUmlnaHQoQnl0ZXMuZnJvbShbMSwgMiwgMywgMCwgMCwgMCwgMF0pKVxuICogLy8gQGxvZzogVWludDhBcnJheShbMSwgMiwgM10pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICogQHJldHVybnMgVHJpbW1lZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbVJpZ2h0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAncmlnaHQnIH0pO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKCcweCcpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICpcbiAqIEJ5dGVzLnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvdGhlcndpc2UgYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXNzZXJ0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIGJ5dGVzIHZhbHVlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGJvb2xlYW4uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnRvQm9vbGVhbihCeXRlcy5mcm9tKFs1XSkpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc0Jvb2xlYW5FcnJvcjogQnl0ZXMgdmFsdWUgYFs1XWAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGJ5dGVzIGFycmF5IG11c3QgY29udGFpbiBhIHNpbmdsZSBieXRlIG9mIGVpdGhlciBhIGAwYCBvciBgMWAgdmFsdWUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRCeXRlc0Jvb2xlYW5FcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGJ5dGVzKSB7XG4gICAgICAgIHN1cGVyKGBCeXRlcyB2YWx1ZSBcXGAke2J5dGVzfVxcYCBpcyBub3QgYSB2YWxpZCBib29sZWFuLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdUaGUgYnl0ZXMgYXJyYXkgbXVzdCBjb250YWluIGEgc2luZ2xlIGJ5dGUgb2YgZWl0aGVyIGEgYDBgIG9yIGAxYCB2YWx1ZS4nLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNCb29sZWFuRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkIHRvIGJ5dGVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLmZyb20oJ2ZvbycpXG4gKiAvLyBAZXJyb3I6IEJ5dGVzLkludmFsaWRCeXRlc1R5cGVFcnJvcjogVmFsdWUgYGZvb2Agb2YgdHlwZSBgc3RyaW5nYCBpcyBhbiBpbnZhbGlkIEJ5dGVzIHZhbHVlLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkQnl0ZXNUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgQnl0ZXMgdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0J5dGVzIHZhbHVlcyBtdXN0IGJlIG9mIHR5cGUgYEJ5dGVzYC4nXSxcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdCeXRlcy5JbnZhbGlkQnl0ZXNUeXBlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBzaXplIGV4Y2VlZHMgdGhlIG1heGltdW0gYWxsb3dlZCBzaXplLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICdveCdcbiAqXG4gKiBCeXRlcy5mcm9tU3RyaW5nKCdIZWxsbyBXb3JsZCEnLCB7IHNpemU6IDggfSlcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3I6IFNpemUgY2Fubm90IGV4Y2VlZCBgOGAgYnl0ZXMuIEdpdmVuIHNpemU6IGAxMmAgYnl0ZXMuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNpemVPdmVyZmxvd0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnaXZlblNpemUsIG1heFNpemUgfSkge1xuICAgICAgICBzdXBlcihgU2l6ZSBjYW5ub3QgZXhjZWVkIFxcYCR7bWF4U2l6ZX1cXGAgYnl0ZXMuIEdpdmVuIHNpemU6IFxcYCR7Z2l2ZW5TaXplfVxcYCBieXRlcy5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2xpY2Ugb2Zmc2V0IGlzIG91dC1vZi1ib3VuZHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnNsaWNlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSwgNClcbiAqIC8vIEBlcnJvcjogQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yOiBTbGljZSBzdGFydGluZyBhdCBvZmZzZXQgYDRgIGlzIG91dC1vZi1ib3VuZHMgKHNpemU6IGAzYCkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIFNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgb2Zmc2V0LCBwb3NpdGlvbiwgc2l6ZSwgfSkge1xuICAgICAgICBzdXBlcihgU2xpY2UgJHtwb3NpdGlvbiA9PT0gJ3N0YXJ0JyA/ICdzdGFydGluZycgOiAnZW5kaW5nJ30gYXQgb2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBcXGAke3NpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHRoZSBwYWRkaW5nIHNpemUgZXhjZWVkcyB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcyB9IGZyb20gJ294J1xuICpcbiAqIEJ5dGVzLnBhZExlZnQoQnl0ZXMuZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJyksIDgpXG4gKiAvLyBAZXJyb3I6IFtCeXRlcy5TaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3I6IEJ5dGVzIHNpemUgKGAxMmApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgOGApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTaXplRXhjZWVkc1BhZGRpbmdTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpemUsIHRhcmdldFNpemUsIHR5cGUsIH0pIHtcbiAgICAgICAgc3VwZXIoYCR7dHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3R5cGVcbiAgICAgICAgICAgIC5zbGljZSgxKVxuICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9IHNpemUgKFxcYCR7c2l6ZX1cXGApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChcXGAke3RhcmdldFNpemV9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0J5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qnl0ZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Caches.js":
/*!*************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Caches.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   checksum: () => (/* binding */ checksum),\n/* harmony export */   clear: () => (/* binding */ clear)\n/* harmony export */ });\n/* harmony import */ var _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/lru.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/lru.js\");\n\nconst caches = {\n    checksum: /*#__PURE__*/ new _internal_lru_js__WEBPACK_IMPORTED_MODULE_0__.LruMap(8192),\n};\nconst checksum = caches.checksum;\n/**\n * Clears all global caches.\n *\n * @example\n * ```ts\n * import { Caches } from 'ox'\n * Caches.clear()\n * ```\n */\nfunction clear() {\n    for (const cache of Object.values(caches))\n        cache.clear();\n}\n//# sourceMappingURL=Caches.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9DYWNoZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBQzNDO0FBQ0EsZ0NBQWdDLG9EQUFNO0FBQ3RDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXENhY2hlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBMcnVNYXAgfSBmcm9tICcuL2ludGVybmFsL2xydS5qcyc7XG5jb25zdCBjYWNoZXMgPSB7XG4gICAgY2hlY2tzdW06IC8qI19fUFVSRV9fKi8gbmV3IExydU1hcCg4MTkyKSxcbn07XG5leHBvcnQgY29uc3QgY2hlY2tzdW0gPSBjYWNoZXMuY2hlY2tzdW07XG4vKipcbiAqIENsZWFycyBhbGwgZ2xvYmFsIGNhY2hlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENhY2hlcyB9IGZyb20gJ294J1xuICogQ2FjaGVzLmNsZWFyKClcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjYWNoZSBvZiBPYmplY3QudmFsdWVzKGNhY2hlcykpXG4gICAgICAgIGNhY2hlLmNsZWFyKCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWNoZXMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Caches.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Ens.js":
/*!**********************************************!*\
  !*** ../../node_modules/ox/_esm/core/Ens.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   labelhash: () => (/* binding */ labelhash),\n/* harmony export */   namehash: () => (/* binding */ namehash),\n/* harmony export */   normalize: () => (/* binding */ normalize)\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"(ssr)/../../node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hash.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/ens.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/ens.js\");\n\n\n\n\n\n/**\n * Hashes ENS label.\n *\n * Since ENS labels prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS labels](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `labelhash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.labelhash('eth')\n * '0x4f5b812789fc606be1b3b16908db13fc7a9adf7ca72641f84d75b47069d3d7f0'\n * ```\n *\n * @param label - ENS label.\n * @returns ENS labelhash.\n */\nfunction labelhash(label) {\n    const result = new Uint8Array(32).fill(0);\n    if (!label)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    return (_internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(label) || _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromString(label)));\n}\n/**\n * Hashes ENS name.\n *\n * Since ENS names prohibit certain forbidden characters (e.g. underscore) and have other validation rules, you likely want to [normalize ENS names](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) with [UTS-46 normalization](https://unicode.org/reports/tr46) before passing them to `namehash`. You can use the built-in {@link ox#Ens.(normalize:function)} function for this.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.namehash('wevm.eth')\n * // @log: '0xf246651c1b9a6b141d19c2604e9a58f567973833990f830d882534a747801359'\n * ```\n *\n * @param name - ENS name.\n * @returns ENS namehash.\n */\nfunction namehash(name) {\n    let result = new Uint8Array(32).fill(0);\n    if (!name)\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n    const labels = name.split('.');\n    // Iterate in reverse order building up hash\n    for (let i = labels.length - 1; i >= 0; i -= 1) {\n        const hashFromEncodedLabel = _internal_ens_js__WEBPACK_IMPORTED_MODULE_2__.unwrapLabelhash(labels[i]);\n        const hashed = hashFromEncodedLabel\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromHex(hashFromEncodedLabel)\n            : _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.fromString(labels[i]), { as: 'Bytes' });\n        result = _Hash_js__WEBPACK_IMPORTED_MODULE_3__.keccak256(_Bytes_js__WEBPACK_IMPORTED_MODULE_4__.concat(result, hashed), { as: 'Bytes' });\n    }\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(result);\n}\n/**\n * Normalizes ENS name according to [ENSIP-15](https://github.com/ensdomains/docs/blob/9edf9443de4333a0ea7ec658a870672d5d180d53/ens-improvement-proposals/ensip-15-normalization-standard.md).\n *\n * For more info see [ENS documentation](https://docs.ens.domains/contract-api-reference/name-processing#normalising-names) on name processing.\n *\n * @example\n * ```ts twoslash\n * import { Ens } from 'ox'\n * Ens.normalize('wevm.eth')\n * // @log: 'wevm.eth'\n * ```\n *\n * @param name - ENS name.\n * @returns Normalized ENS name.\n */\nfunction normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n}\n//# sourceMappingURL=Ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9FbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBdUQ7QUFDbkI7QUFDRjtBQUNGO0FBQ2M7QUFDOUM7QUFDQTtBQUNBO0FBQ0Esc1dBQXNXLG1DQUFtQztBQUN6WTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxlQUFlLDhDQUFhO0FBQzVCLFlBQVksNkRBQXdCLFdBQVcsK0NBQWMsQ0FBQywrQ0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1XQUFtVyxtQ0FBbUM7QUFDdFk7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsZUFBZSw4Q0FBYTtBQUM1QjtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUMscUNBQXFDLDZEQUF3QjtBQUM3RDtBQUNBLGNBQWMsOENBQWE7QUFDM0IsY0FBYywrQ0FBYyxDQUFDLGlEQUFnQixlQUFlLGFBQWE7QUFDekUsaUJBQWlCLCtDQUFjLENBQUMsNkNBQVksb0JBQW9CLGFBQWE7QUFDN0U7QUFDQSxXQUFXLDhDQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcscUVBQWE7QUFDeEI7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcRW5zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVuc19ub3JtYWxpemUgfSBmcm9tICdAYWRyYWZmeS9lbnMtbm9ybWFsaXplJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvZW5zLmpzJztcbi8qKlxuICogSGFzaGVzIEVOUyBsYWJlbC5cbiAqXG4gKiBTaW5jZSBFTlMgbGFiZWxzIHByb2hpYml0IGNlcnRhaW4gZm9yYmlkZGVuIGNoYXJhY3RlcnMgKGUuZy4gdW5kZXJzY29yZSkgYW5kIGhhdmUgb3RoZXIgdmFsaWRhdGlvbiBydWxlcywgeW91IGxpa2VseSB3YW50IHRvIFtub3JtYWxpemUgRU5TIGxhYmVsc10oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL2NvbnRyYWN0LWFwaS1yZWZlcmVuY2UvbmFtZS1wcm9jZXNzaW5nI25vcm1hbGlzaW5nLW5hbWVzKSB3aXRoIFtVVFMtNDYgbm9ybWFsaXphdGlvbl0oaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYpIGJlZm9yZSBwYXNzaW5nIHRoZW0gdG8gYGxhYmVsaGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLmxhYmVsaGFzaCgnZXRoJylcbiAqICcweDRmNWI4MTI3ODlmYzYwNmJlMWIzYjE2OTA4ZGIxM2ZjN2E5YWRmN2NhNzI2NDFmODRkNzViNDcwNjlkM2Q3ZjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGFiZWwgLSBFTlMgbGFiZWwuXG4gKiBAcmV0dXJucyBFTlMgbGFiZWxoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFiZWxoYXNoKGxhYmVsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFsYWJlbClcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMocmVzdWx0KTtcbiAgICByZXR1cm4gKGludGVybmFsLnVud3JhcExhYmVsaGFzaChsYWJlbCkgfHwgSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcobGFiZWwpKSk7XG59XG4vKipcbiAqIEhhc2hlcyBFTlMgbmFtZS5cbiAqXG4gKiBTaW5jZSBFTlMgbmFtZXMgcHJvaGliaXQgY2VydGFpbiBmb3JiaWRkZW4gY2hhcmFjdGVycyAoZS5nLiB1bmRlcnNjb3JlKSBhbmQgaGF2ZSBvdGhlciB2YWxpZGF0aW9uIHJ1bGVzLCB5b3UgbGlrZWx5IHdhbnQgdG8gW25vcm1hbGl6ZSBFTlMgbmFtZXNdKGh0dHBzOi8vZG9jcy5lbnMuZG9tYWlucy9jb250cmFjdC1hcGktcmVmZXJlbmNlL25hbWUtcHJvY2Vzc2luZyNub3JtYWxpc2luZy1uYW1lcykgd2l0aCBbVVRTLTQ2IG5vcm1hbGl6YXRpb25dKGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2KSBiZWZvcmUgcGFzc2luZyB0aGVtIHRvIGBuYW1laGFzaGAuIFlvdSBjYW4gdXNlIHRoZSBidWlsdC1pbiB7QGxpbmsgb3gjRW5zLihub3JtYWxpemU6ZnVuY3Rpb24pfSBmdW5jdGlvbiBmb3IgdGhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5hbWVoYXNoKCd3ZXZtLmV0aCcpXG4gKiAvLyBAbG9nOiAnMHhmMjQ2NjUxYzFiOWE2YjE0MWQxOWMyNjA0ZTlhNThmNTY3OTczODMzOTkwZjgzMGQ4ODI1MzRhNzQ3ODAxMzU5J1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIEVOUyBuYW1laGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hbWVoYXNoKG5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMCk7XG4gICAgaWYgKCFuYW1lKVxuICAgICAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xuICAgIGNvbnN0IGxhYmVscyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAvLyBJdGVyYXRlIGluIHJldmVyc2Ugb3JkZXIgYnVpbGRpbmcgdXAgaGFzaFxuICAgIGZvciAobGV0IGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgaGFzaEZyb21FbmNvZGVkTGFiZWwgPSBpbnRlcm5hbC51bndyYXBMYWJlbGhhc2gobGFiZWxzW2ldKTtcbiAgICAgICAgY29uc3QgaGFzaGVkID0gaGFzaEZyb21FbmNvZGVkTGFiZWxcbiAgICAgICAgICAgID8gQnl0ZXMuZnJvbUhleChoYXNoRnJvbUVuY29kZWRMYWJlbClcbiAgICAgICAgICAgIDogSGFzaC5rZWNjYWsyNTYoQnl0ZXMuZnJvbVN0cmluZyhsYWJlbHNbaV0pLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgICAgICByZXN1bHQgPSBIYXNoLmtlY2NhazI1NihCeXRlcy5jb25jYXQocmVzdWx0LCBoYXNoZWQpLCB7IGFzOiAnQnl0ZXMnIH0pO1xuICAgIH1cbiAgICByZXR1cm4gSGV4LmZyb21CeXRlcyhyZXN1bHQpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIEVOUyBuYW1lIGFjY29yZGluZyB0byBbRU5TSVAtMTVdKGh0dHBzOi8vZ2l0aHViLmNvbS9lbnNkb21haW5zL2RvY3MvYmxvYi85ZWRmOTQ0M2RlNDMzM2EwZWE3ZWM2NThhODcwNjcyZDVkMTgwZDUzL2Vucy1pbXByb3ZlbWVudC1wcm9wb3NhbHMvZW5zaXAtMTUtbm9ybWFsaXphdGlvbi1zdGFuZGFyZC5tZCkuXG4gKlxuICogRm9yIG1vcmUgaW5mbyBzZWUgW0VOUyBkb2N1bWVudGF0aW9uXShodHRwczovL2RvY3MuZW5zLmRvbWFpbnMvY29udHJhY3QtYXBpLXJlZmVyZW5jZS9uYW1lLXByb2Nlc3Npbmcjbm9ybWFsaXNpbmctbmFtZXMpIG9uIG5hbWUgcHJvY2Vzc2luZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEVucyB9IGZyb20gJ294J1xuICogRW5zLm5vcm1hbGl6ZSgnd2V2bS5ldGgnKVxuICogLy8gQGxvZzogJ3dldm0uZXRoJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIG5hbWUgLSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgRU5TIG5hbWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUobmFtZSkge1xuICAgIHJldHVybiBlbnNfbm9ybWFsaXplKG5hbWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Ens.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Errors.js":
/*!*************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Errors.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError)\n/* harmony export */ });\n/* harmony import */ var _internal_errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/errors.js\");\n\n/**\n * Base error class inherited by all errors thrown by ox.\n *\n * @example\n * ```ts\n * import { Errors } from 'ox'\n * throw new Errors.BaseError('An error occurred')\n * ```\n */\nclass BaseError extends Error {\n    constructor(shortMessage, options = {}) {\n        const details = (() => {\n            if (options.cause instanceof BaseError) {\n                if (options.cause.details)\n                    return options.cause.details;\n                if (options.cause.shortMessage)\n                    return options.cause.shortMessage;\n            }\n            if (options.cause &&\n                'details' in options.cause &&\n                typeof options.cause.details === 'string')\n                return options.cause.details;\n            if (options.cause?.message)\n                return options.cause.message;\n            return options.details;\n        })();\n        const docsPath = (() => {\n            if (options.cause instanceof BaseError)\n                return options.cause.docsPath || options.docsPath;\n            return options.docsPath;\n        })();\n        const docsBaseUrl = 'https://oxlib.sh';\n        const docs = `${docsBaseUrl}${docsPath ?? ''}`;\n        const message = [\n            shortMessage || 'An error occurred.',\n            ...(options.metaMessages ? ['', ...options.metaMessages] : []),\n            ...(details || docsPath\n                ? [\n                    '',\n                    details ? `Details: ${details}` : undefined,\n                    docsPath ? `See: ${docs}` : undefined,\n                ]\n                : []),\n        ]\n            .filter((x) => typeof x === 'string')\n            .join('\\n');\n        super(message, options.cause ? { cause: options.cause } : undefined);\n        Object.defineProperty(this, \"details\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"docsPath\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"shortMessage\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"cause\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'BaseError'\n        });\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: `ox@${(0,_internal_errors_js__WEBPACK_IMPORTED_MODULE_0__.getVersion)()}`\n        });\n        this.cause = options.cause;\n        this.details = details;\n        this.docs = docs;\n        this.docsPath = docsPath;\n        this.shortMessage = shortMessage;\n    }\n    walk(fn) {\n        return walk(this, fn);\n    }\n}\n/** @internal */\nfunction walk(err, fn) {\n    if (fn?.(err))\n        return err;\n    if (err && typeof err === 'object' && 'cause' in err && err.cause)\n        return walk(err.cause, fn);\n    return fn ? null : err;\n}\n//# sourceMappingURL=Errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9FcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDTztBQUNQLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLFlBQVksRUFBRSxlQUFlO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xELHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsdUJBQXVCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLCtEQUFVLEdBQUc7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxFcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VmVyc2lvbiB9IGZyb20gJy4vaW50ZXJuYWwvZXJyb3JzLmpzJztcbi8qKlxuICogQmFzZSBlcnJvciBjbGFzcyBpbmhlcml0ZWQgYnkgYWxsIGVycm9ycyB0aHJvd24gYnkgb3guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBFcnJvcnMgfSBmcm9tICdveCdcbiAqIHRocm93IG5ldyBFcnJvcnMuQmFzZUVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCcpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzaG9ydE1lc3NhZ2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBkZXRhaWxzID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2UuZGV0YWlscylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UuZGV0YWlscztcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jYXVzZS5zaG9ydE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlICYmXG4gICAgICAgICAgICAgICAgJ2RldGFpbHMnIGluIG9wdGlvbnMuY2F1c2UgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2Ygb3B0aW9ucy5jYXVzZS5kZXRhaWxzID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5jYXVzZS5kZXRhaWxzO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2F1c2U/Lm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2F1c2UubWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRldGFpbHM7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGRvY3NQYXRoID0gKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhdXNlIGluc3RhbmNlb2YgQmFzZUVycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmNhdXNlLmRvY3NQYXRoIHx8IG9wdGlvbnMuZG9jc1BhdGg7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5kb2NzUGF0aDtcbiAgICAgICAgfSkoKTtcbiAgICAgICAgY29uc3QgZG9jc0Jhc2VVcmwgPSAnaHR0cHM6Ly9veGxpYi5zaCc7XG4gICAgICAgIGNvbnN0IGRvY3MgPSBgJHtkb2NzQmFzZVVybH0ke2RvY3NQYXRoID8/ICcnfWA7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICBzaG9ydE1lc3NhZ2UgfHwgJ0FuIGVycm9yIG9jY3VycmVkLicsXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5tZXRhTWVzc2FnZXMgPyBbJycsIC4uLm9wdGlvbnMubWV0YU1lc3NhZ2VzXSA6IFtdKSxcbiAgICAgICAgICAgIC4uLihkZXRhaWxzIHx8IGRvY3NQYXRoXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID8gYERldGFpbHM6ICR7ZGV0YWlsc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICBkb2NzUGF0aCA/IGBTZWU6ICR7ZG9jc31gIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICA6IFtdKSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zLmNhdXNlID8geyBjYXVzZTogb3B0aW9ucy5jYXVzZSB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRvY3NQYXRoXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNob3J0TWVzc2FnZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQmFzZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogYG94QCR7Z2V0VmVyc2lvbigpfWBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zLmNhdXNlO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLmRvY3MgPSBkb2NzO1xuICAgICAgICB0aGlzLmRvY3NQYXRoID0gZG9jc1BhdGg7XG4gICAgICAgIHRoaXMuc2hvcnRNZXNzYWdlID0gc2hvcnRNZXNzYWdlO1xuICAgIH1cbiAgICB3YWxrKGZuKSB7XG4gICAgICAgIHJldHVybiB3YWxrKHRoaXMsIGZuKTtcbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB3YWxrKGVyciwgZm4pIHtcbiAgICBpZiAoZm4/LihlcnIpKVxuICAgICAgICByZXR1cm4gZXJyO1xuICAgIGlmIChlcnIgJiYgdHlwZW9mIGVyciA9PT0gJ29iamVjdCcgJiYgJ2NhdXNlJyBpbiBlcnIgJiYgZXJyLmNhdXNlKVxuICAgICAgICByZXR1cm4gd2FsayhlcnIuY2F1c2UsIGZuKTtcbiAgICByZXR1cm4gZm4gPyBudWxsIDogZXJyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Hash.js":
/*!***********************************************!*\
  !*** ../../node_modules/ox/_esm/core/Hash.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keccak256: () => (/* binding */ keccak256),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/ripemd160 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n\n/**\n * Calculates the [Keccak256](https://en.wikipedia.org/wiki/SHA-3) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `keccak_256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef')\n * // @log: '0xd4fd4e189132273036449fc9e11198c739161b4c0116a9a2dccdfa1c492006f1'\n * ```\n *\n * @example\n * ### Calculate Hash of a String\n *\n * ```ts twoslash\n * import { Hash, Hex } from 'ox'\n *\n * Hash.keccak256(Hex.fromString('hello world'))\n * // @log: '0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0'\n * ```\n *\n * @example\n * ### Configure Return Type\n *\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.keccak256('0xdeadbeef', { as: 'Bytes' })\n * // @log: Uint8Array [...]\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Keccak256 hash.\n */\nfunction keccak256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_0__.keccak_256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Ripemd160](https://en.wikipedia.org/wiki/RIPEMD) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `ripemd160` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.ripemd160('0xdeadbeef')\n * // '0x226821c2f5423e11fe9af68bd285c249db2e4b5a'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Ripemd160 hash.\n */\nfunction ripemd160(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_ripemd160__WEBPACK_IMPORTED_MODULE_3__.ripemd160)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Calculates the [Sha256](https://en.wikipedia.org/wiki/SHA-256) hash of a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n *\n * This function is a re-export of `sha256` from [`@noble/hashes`](https://github.com/paulmillr/noble-hashes), an audited & minimal JS hashing library.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.sha256('0xdeadbeef')\n * // '0x5f78c33274e43fa9de5659265c1d917e25c03722dcb0b8d27db8d5feaa813953'\n * ```\n *\n * @param value - {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value.\n * @param options - Options.\n * @returns Sha256 hash.\n */\nfunction sha256(value, options = {}) {\n    const { as = typeof value === 'string' ? 'Hex' : 'Bytes' } = options;\n    const bytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_4__.sha256)(_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.from(value));\n    if (as === 'Bytes')\n        return bytes;\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(bytes);\n}\n/**\n * Checks if a string is a valid hash value.\n *\n * @example\n * ```ts twoslash\n * import { Hash } from 'ox'\n *\n * Hash.validate('0x')\n * // @log: false\n *\n * Hash.validate('0x3ea2f1d0abf3fc66cf29eebb70cbd4e7fe762ef8a09bcc06c8edf641230afec0')\n * // @log: true\n * ```\n *\n * @param value - Value to check.\n * @returns Whether the value is a valid hash.\n */\nfunction validate(value) {\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(value) && _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value) === 32;\n}\n//# sourceMappingURL=Hash.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IYXNoLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF1RTtBQUNKO0FBQ0w7QUFDMUI7QUFDSjtBQUNoQztBQUNBLDhFQUE4RSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0Esa0NBQWtDLGFBQWE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLDhEQUFlLENBQUMsMkNBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLCtFQUErRSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxzQ0FBc0M7QUFDN0MsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLGtFQUFlLENBQUMsMkNBQVU7QUFDNUM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLDZFQUE2RSxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQixJQUFJLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUM7QUFDMUMsWUFBWSxtREFBbUQ7QUFDL0Qsa0JBQWtCLDREQUFZLENBQUMsMkNBQVU7QUFDekM7QUFDQTtBQUNBLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsNkNBQVksV0FBVyx5Q0FBUTtBQUMxQztBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxIYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJpcGVtZDE2MCBhcyBub2JsZV9yaXBlbWQxNjAgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3JpcGVtZDE2MCc7XG5pbXBvcnQgeyBrZWNjYWtfMjU2IGFzIG5vYmxlX2tlY2NhazI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzaGEyNTYgYXMgbm9ibGVfc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyNTYnO1xuaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbS2VjY2FrMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMykgaGFzaCBvZiBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gb3Ige0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSByZS1leHBvcnQgb2YgYGtlY2Nha18yNTZgIGZyb20gW2BAbm9ibGUvaGFzaGVzYF0oaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9ub2JsZS1oYXNoZXMpLCBhbiBhdWRpdGVkICYgbWluaW1hbCBKUyBoYXNoaW5nIGxpYnJhcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIYXNoIH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoJzB4ZGVhZGJlZWYnKVxuICogLy8gQGxvZzogJzB4ZDRmZDRlMTg5MTMyMjczMDM2NDQ5ZmM5ZTExMTk4YzczOTE2MWI0YzAxMTZhOWEyZGNjZGZhMWM0OTIwMDZmMSdcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQ2FsY3VsYXRlIEhhc2ggb2YgYSBTdHJpbmdcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCwgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGFzaC5rZWNjYWsyNTYoSGV4LmZyb21TdHJpbmcoJ2hlbGxvIHdvcmxkJykpXG4gKiAvLyBAbG9nOiAnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJ1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBDb25maWd1cmUgUmV0dXJuIFR5cGVcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gua2VjY2FrMjU2KCcweGRlYWRiZWVmJywgeyBhczogJ0J5dGVzJyB9KVxuICogLy8gQGxvZzogVWludDhBcnJheSBbLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0ge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBLZWNjYWsyNTYgaGFzaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGtlY2NhazI1Nih2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhcyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyAnSGV4JyA6ICdCeXRlcycgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYnl0ZXMgPSBub2JsZV9rZWNjYWsyNTYoQnl0ZXMuZnJvbSh2YWx1ZSkpO1xuICAgIGlmIChhcyA9PT0gJ0J5dGVzJylcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIHJldHVybiBIZXguZnJvbUJ5dGVzKGJ5dGVzKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgW1JpcGVtZDE2MF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUklQRU1EKSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgcmlwZW1kMTYwYCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gucmlwZW1kMTYwKCcweGRlYWRiZWVmJylcbiAqIC8vICcweDIyNjgyMWMyZjU0MjNlMTFmZTlhZjY4YmQyODVjMjQ5ZGIyZTRiNWEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFJpcGVtZDE2MCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmlwZW1kMTYwKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3JpcGVtZDE2MChCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBbU2hhMjU2XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TSEEtMjU2KSBoYXNoIG9mIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHJlLWV4cG9ydCBvZiBgc2hhMjU2YCBmcm9tIFtgQG5vYmxlL2hhc2hlc2BdKGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtaGFzaGVzKSwgYW4gYXVkaXRlZCAmIG1pbmltYWwgSlMgaGFzaGluZyBsaWJyYXJ5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2guc2hhMjU2KCcweGRlYWRiZWVmJylcbiAqIC8vICcweDVmNzhjMzMyNzRlNDNmYTlkZTU2NTkyNjVjMWQ5MTdlMjVjMDM3MjJkY2IwYjhkMjdkYjhkNWZlYWE4MTM5NTMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFNoYTI1NiBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBieXRlcyA9IG5vYmxlX3NoYTI1NihCeXRlcy5mcm9tKHZhbHVlKSk7XG4gICAgaWYgKGFzID09PSAnQnl0ZXMnKVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoYnl0ZXMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdHJpbmcgaXMgYSB2YWxpZCBoYXNoIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGFzaCB9IGZyb20gJ294J1xuICpcbiAqIEhhc2gudmFsaWRhdGUoJzB4JylcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKlxuICogSGFzaC52YWxpZGF0ZSgnMHgzZWEyZjFkMGFiZjNmYzY2Y2YyOWVlYmI3MGNiZDRlN2ZlNzYyZWY4YTA5YmNjMDZjOGVkZjY0MTIzMGFmZWMwJylcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgdmFsdWUgaXMgYSB2YWxpZCBoYXNoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiBIZXguc2l6ZSh2YWx1ZSkgPT09IDMyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFzaC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Hash.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Hex.js":
/*!**********************************************!*\
  !*** ../../node_modules/ox/_esm/core/Hex.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegerOutOfRangeError: () => (/* binding */ IntegerOutOfRangeError),\n/* harmony export */   InvalidHexBooleanError: () => (/* binding */ InvalidHexBooleanError),\n/* harmony export */   InvalidHexTypeError: () => (/* binding */ InvalidHexTypeError),\n/* harmony export */   InvalidHexValueError: () => (/* binding */ InvalidHexValueError),\n/* harmony export */   InvalidLengthError: () => (/* binding */ InvalidLengthError),\n/* harmony export */   SizeExceedsPaddingSizeError: () => (/* binding */ SizeExceedsPaddingSizeError),\n/* harmony export */   SizeOverflowError: () => (/* binding */ SizeOverflowError),\n/* harmony export */   SliceOffsetOutOfBoundsError: () => (/* binding */ SliceOffsetOutOfBoundsError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   concat: () => (/* binding */ concat),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBoolean: () => (/* binding */ fromBoolean),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromNumber: () => (/* binding */ fromNumber),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   isEqual: () => (/* binding */ isEqual),\n/* harmony export */   padLeft: () => (/* binding */ padLeft),\n/* harmony export */   padRight: () => (/* binding */ padRight),\n/* harmony export */   random: () => (/* binding */ random),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   slice: () => (/* binding */ slice),\n/* harmony export */   toBigInt: () => (/* binding */ toBigInt),\n/* harmony export */   toBoolean: () => (/* binding */ toBoolean),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toNumber: () => (/* binding */ toNumber),\n/* harmony export */   toString: () => (/* binding */ toString),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/abstract/utils */ \"(ssr)/../../node_modules/ox/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./internal/bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/bytes.js\");\n/* harmony import */ var _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal/hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/internal/hex.js\");\n\n\n\n\n\n\nconst encoder = /*#__PURE__*/ new TextEncoder();\nconst hexes = /*#__PURE__*/ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));\n/**\n * Asserts if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('abc')\n * // @error: InvalidHexValueTypeError:\n * // @error: Value `\"abc\"` of type `string` is an invalid hex type.\n * // @error: Hex types must be represented as `\"0x\\${string}\"`.\n * ```\n *\n * @param value - The value to assert.\n * @param options - Options.\n */\nfunction assert(value, options = {}) {\n    const { strict = false } = options;\n    if (!value)\n        throw new InvalidHexTypeError(value);\n    if (typeof value !== 'string')\n        throw new InvalidHexTypeError(value);\n    if (strict) {\n        if (!/^0x[0-9a-fA-F]*$/.test(value))\n            throw new InvalidHexValueError(value);\n    }\n    if (!value.startsWith('0x'))\n        throw new InvalidHexValueError(value);\n}\n/**\n * Concatenates two or more {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.concat('0x123', '0x456')\n * // @log: '0x123456'\n * ```\n *\n * @param values - The {@link ox#Hex.Hex} values to concatenate.\n * @returns The concatenated {@link ox#Hex.Hex} value.\n */\nfunction concat(...values) {\n    return `0x${values.reduce((acc, x) => acc + x.replace('0x', ''), '')}`;\n}\n/**\n * Instantiates a {@link ox#Hex.Hex} value from a hex string or {@link ox#Bytes.Bytes} value.\n *\n * :::tip\n *\n * To instantiate from a **Boolean**, **String**, or **Number**, use one of the following:\n *\n * - `Hex.fromBoolean`\n *\n * - `Hex.fromString`\n *\n * - `Hex.fromNumber`\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.from('0x48656c6c6f20576f726c6421')\n * // @log: '0x48656c6c6f20576f726c6421'\n *\n * Hex.from(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction from(value) {\n    if (value instanceof Uint8Array)\n        return fromBytes(value);\n    if (Array.isArray(value))\n        return fromBytes(new Uint8Array(value));\n    return value;\n}\n/**\n * Encodes a boolean into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromBoolean(true)\n * // @log: '0x1'\n *\n * Hex.fromBoolean(false)\n * // @log: '0x0'\n *\n * Hex.fromBoolean(true, { size: 32 })\n * // @log: '0x0000000000000000000000000000000000000000000000000000000000000001'\n * ```\n *\n * @param value - The boolean value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBoolean(value, options = {}) {\n    const hex = `0x${Number(value)}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padLeft(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.fromBytes(Bytes.from([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33]))\n * // @log: '0x48656c6c6f20576f726c6421'\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromBytes(value, options = {}) {\n    let string = '';\n    for (let i = 0; i < value.length; i++)\n        string += hexes[value[i]];\n    const hex = `0x${string}`;\n    if (typeof options.size === 'number') {\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n        return padRight(hex, options.size);\n    }\n    return hex;\n}\n/**\n * Encodes a number or bigint into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420)\n * // @log: '0x1a4'\n *\n * Hex.fromNumber(420, { size: 32 })\n * // @log: '0x00000000000000000000000000000000000000000000000000000000000001a4'\n * ```\n *\n * @param value - The number or bigint value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromNumber(value, options = {}) {\n    const { signed, size } = options;\n    const value_ = BigInt(value);\n    let maxValue;\n    if (size) {\n        if (signed)\n            maxValue = (1n << (BigInt(size) * 8n - 1n)) - 1n;\n        else\n            maxValue = 2n ** (BigInt(size) * 8n) - 1n;\n    }\n    else if (typeof value === 'number') {\n        maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n    }\n    const minValue = typeof maxValue === 'bigint' && signed ? -maxValue - 1n : 0;\n    if ((maxValue && value_ > maxValue) || value_ < minValue) {\n        const suffix = typeof value === 'bigint' ? 'n' : '';\n        throw new IntegerOutOfRangeError({\n            max: maxValue ? `${maxValue}${suffix}` : undefined,\n            min: `${minValue}${suffix}`,\n            signed,\n            size,\n            value: `${value}${suffix}`,\n        });\n    }\n    const stringValue = (signed && value_ < 0 ? (1n << BigInt(size * 8)) + BigInt(value_) : value_).toString(16);\n    const hex = `0x${stringValue}`;\n    if (size)\n        return padLeft(hex, size);\n    return hex;\n}\n/**\n * Encodes a string into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n * Hex.fromString('Hello World!')\n * // '0x48656c6c6f20576f726c6421'\n *\n * Hex.fromString('Hello World!', { size: 32 })\n * // '0x48656c6c6f20576f726c64210000000000000000000000000000000000000000'\n * ```\n *\n * @param value - The string value to encode.\n * @param options - Options.\n * @returns The encoded {@link ox#Hex.Hex} value.\n */\nfunction fromString(value, options = {}) {\n    return fromBytes(encoder.encode(value), options);\n}\n/**\n * Checks if two {@link ox#Hex.Hex} values are equal.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.isEqual('0xdeadbeef', '0xdeadbeef')\n * // @log: true\n *\n * Hex.isEqual('0xda', '0xba')\n * // @log: false\n * ```\n *\n * @param hexA - The first {@link ox#Hex.Hex} value.\n * @param hexB - The second {@link ox#Hex.Hex} value.\n * @returns `true` if the two {@link ox#Hex.Hex} values are equal, `false` otherwise.\n */\nfunction isEqual(hexA, hexB) {\n    return (0,_noble_curves_abstract_utils__WEBPACK_IMPORTED_MODULE_1__.equalBytes)(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexA), _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hexB));\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the left with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1234', 4)\n * // @log: '0x00001234'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padLeft(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'left', size });\n}\n/**\n * Pads a {@link ox#Hex.Hex} value to the right with zero bytes until it reaches the given `size` (default: 32 bytes).\n *\n * @example\n * ```ts\n * import { Hex } from 'ox'\n *\n * Hex.padRight('0x1234', 4)\n * // @log: '0x12340000'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to pad.\n * @param size - The size (in bytes) of the output hex value.\n * @returns The padded {@link ox#Hex.Hex} value.\n */\nfunction padRight(value, size) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.pad(value, { dir: 'right', size });\n}\n/**\n * Generates a random {@link ox#Hex.Hex} value of the specified length.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const hex = Hex.random(32)\n * // @log: '0x...'\n * ```\n *\n * @returns Random {@link ox#Hex.Hex} value.\n */\nfunction random(length) {\n    return fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_2__.random(length));\n}\n/**\n * Returns a section of a {@link ox#Bytes.Bytes} value given a start/end bytes offset.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 1, 4)\n * // @log: '0x234567'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to slice.\n * @param start - The start offset (in bytes).\n * @param end - The end offset (in bytes).\n * @param options - Options.\n * @returns The sliced {@link ox#Hex.Hex} value.\n */\nfunction slice(value, start, end, options = {}) {\n    const { strict } = options;\n    _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertStartOffset(value, start);\n    const value_ = `0x${value\n        .replace('0x', '')\n        .slice((start ?? 0) * 2, (end ?? value.length) * 2)}`;\n    if (strict)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertEndOffset(value_, start, end);\n    return value_;\n}\n/**\n * Retrieves the size of a {@link ox#Hex.Hex} value (in bytes).\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.size('0xdeadbeef')\n * // @log: 4\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to get the size of.\n * @returns The size of the {@link ox#Hex.Hex} value (in bytes).\n */\nfunction size(value) {\n    return Math.ceil((value.length - 2) / 2);\n}\n/**\n * Trims leading zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimLeft('0x00000000deadbeef')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimLeft(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'left' });\n}\n/**\n * Trims trailing zeros from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.trimRight('0xdeadbeef00000000')\n * // @log: '0xdeadbeef'\n * ```\n *\n * @param value - The {@link ox#Hex.Hex} value to trim.\n * @returns The trimmed {@link ox#Hex.Hex} value.\n */\nfunction trimRight(value) {\n    return _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.trim(value, { dir: 'right' });\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a BigInt.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBigInt('0x1a4')\n * // @log: 420n\n *\n * Hex.toBigInt('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420n\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded BigInt.\n */\nfunction toBigInt(hex, options = {}) {\n    const { signed } = options;\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const value = BigInt(hex);\n    if (!signed)\n        return value;\n    const size = (hex.length - 2) / 2;\n    const max_unsigned = (1n << (BigInt(size) * 8n)) - 1n;\n    const max_signed = max_unsigned >> 1n;\n    if (value <= max_signed)\n        return value;\n    return value - max_unsigned - 1n;\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0x01')\n * // @log: true\n *\n * Hex.toBoolean('0x0000000000000000000000000000000000000000000000000000000000000001', { size: 32 })\n * // @log: true\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded boolean.\n */\nfunction toBoolean(hex, options = {}) {\n    if (options.size)\n        _internal_hex_js__WEBPACK_IMPORTED_MODULE_0__.assertSize(hex, options.size);\n    const hex_ = trimLeft(hex);\n    if (hex_ === '0x')\n        return false;\n    if (hex_ === '0x1')\n        return true;\n    throw new InvalidHexBooleanError(hex);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * const data = Hex.toBytes('0x48656c6c6f20776f726c6421')\n * // @log: Uint8Array([72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33])\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded {@link ox#Bytes.Bytes}.\n */\nfunction toBytes(hex, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex, options);\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a number.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toNumber('0x1a4')\n * // @log: 420\n *\n * Hex.toNumber('0x00000000000000000000000000000000000000000000000000000000000001a4', { size: 32 })\n * // @log: 420\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded number.\n */\nfunction toNumber(hex, options = {}) {\n    const { signed, size } = options;\n    if (!signed && !size)\n        return Number(hex);\n    return Number(toBigInt(hex, options));\n}\n/**\n * Decodes a {@link ox#Hex.Hex} value into a string.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toString('0x48656c6c6f20576f726c6421')\n * // @log: 'Hello world!'\n *\n * Hex.toString('0x48656c6c6f20576f726c64210000000000000000000000000000000000000000', {\n *  size: 32,\n * })\n * // @log: 'Hello world'\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to decode.\n * @param options - Options.\n * @returns The decoded string.\n */\nfunction toString(hex, options = {}) {\n    const { size } = options;\n    let bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(hex);\n    if (size) {\n        _internal_bytes_js__WEBPACK_IMPORTED_MODULE_3__.assertSize(bytes, size);\n        bytes = _Bytes_js__WEBPACK_IMPORTED_MODULE_2__.trimRight(bytes);\n    }\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Checks if the given value is {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Hex } from 'ox'\n *\n * Hex.validate('0xdeadbeef')\n * // @log: true\n *\n * Hex.validate(Bytes.from([1, 2, 3]))\n * // @log: false\n * ```\n *\n * @param value - The value to check.\n * @param options - Options.\n * @returns `true` if the value is a {@link ox#Hex.Hex}, `false` otherwise.\n */\nfunction validate(value, options = {}) {\n    const { strict = false } = options;\n    try {\n        assert(value, { strict });\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Thrown when the provided integer is out of range, and cannot be represented as a hex value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromNumber(420182738912731283712937129)\n * // @error: Hex.IntegerOutOfRangeError: Number \\`4.2018273891273126e+26\\` is not in safe unsigned integer range (`0` to `9007199254740991`)\n * ```\n */\nclass IntegerOutOfRangeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ max, min, signed, size, value, }) {\n        super(`Number \\`${value}\\` is not in safe${size ? ` ${size * 8}-bit` : ''}${signed ? ' signed' : ' unsigned'} integer range ${max ? `(\\`${min}\\` to \\`${max}\\`)` : `(above \\`${min}\\`)`}`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.IntegerOutOfRangeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value cannot be represented as a boolean.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.toBoolean('0xa')\n * // @error: Hex.InvalidHexBooleanError: Hex value `\"0xa\"` is not a valid boolean.\n * // @error: The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).\n * ```\n */\nclass InvalidHexBooleanError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(hex) {\n        super(`Hex value \\`\"${hex}\"\\` is not a valid boolean.`, {\n            metaMessages: [\n                'The hex value must be `\"0x0\"` (false) or `\"0x1\"` (true).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexBooleanError'\n        });\n    }\n}\n/**\n * Thrown when the provided value is not a valid hex type.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert(1)\n * // @error: Hex.InvalidHexTypeError: Value `1` of type `number` is an invalid hex type.\n * ```\n */\nclass InvalidHexTypeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${typeof value === 'object' ? _Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(value) : value}\\` of type \\`${typeof value}\\` is an invalid hex type.`, {\n            metaMessages: ['Hex types must be represented as `\"0x${string}\"`.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexTypeError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is invalid.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.assert('0x0123456789abcdefg')\n * // @error: Hex.InvalidHexValueError: Value `0x0123456789abcdefg` is an invalid hex value.\n * // @error: Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).\n * ```\n */\nclass InvalidHexValueError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Value \\`${value}\\` is an invalid hex value.`, {\n            metaMessages: [\n                'Hex values must start with `\"0x\"` and contain only hexadecimal characters (0-9, a-f, A-F).',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidHexValueError'\n        });\n    }\n}\n/**\n * Thrown when the provided hex value is an odd length.\n *\n * @example\n * ```ts twoslash\n * import { Bytes } from 'ox'\n *\n * Bytes.fromHex('0xabcde')\n * // @error: Hex.InvalidLengthError: Hex value `\"0xabcde\"` is an odd length (5 nibbles).\n * ```\n */\nclass InvalidLengthError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor(value) {\n        super(`Hex value \\`\"${value}\"\\` is an odd length (${value.length - 2} nibbles).`, {\n            metaMessages: ['It must be an even length.'],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.InvalidLengthError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the expected max size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.fromString('Hello World!', { size: 8 })\n * // @error: Hex.SizeOverflowError: Size cannot exceed `8` bytes. Given size: `12` bytes.\n * ```\n */\nclass SizeOverflowError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ givenSize, maxSize }) {\n        super(`Size cannot exceed \\`${maxSize}\\` bytes. Given size: \\`${givenSize}\\` bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeOverflowError'\n        });\n    }\n}\n/**\n * Thrown when the slice offset exceeds the bounds of the value.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.slice('0x0123456789', 6)\n * // @error: Hex.SliceOffsetOutOfBoundsError: Slice starting at offset `6` is out-of-bounds (size: `5`).\n * ```\n */\nclass SliceOffsetOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ offset, position, size, }) {\n        super(`Slice ${position === 'start' ? 'starting' : 'ending'} at offset \\`${offset}\\` is out-of-bounds (size: \\`${size}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SliceOffsetOutOfBoundsError'\n        });\n    }\n}\n/**\n * Thrown when the size of the value exceeds the pad size.\n *\n * @example\n * ```ts twoslash\n * import { Hex } from 'ox'\n *\n * Hex.padLeft('0x1a4e12a45a21323123aaa87a897a897a898a6567a578a867a98778a667a85a875a87a6a787a65a675a6a9', 32)\n * // @error: Hex.SizeExceedsPaddingSizeError: Hex size (`43`) exceeds padding size (`32`).\n * ```\n */\nclass SizeExceedsPaddingSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ size, targetSize, type, }) {\n        super(`${type.charAt(0).toUpperCase()}${type\n            .slice(1)\n            .toLowerCase()} size (\\`${size}\\`) exceeds padding size (\\`${targetSize}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Hex.SizeExceedsPaddingSizeError'\n        });\n    }\n}\n//# sourceMappingURL=Hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9IZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEQ7QUFDdEI7QUFDRTtBQUNKO0FBQ29CO0FBQ1I7QUFDOUM7QUFDQSx5Q0FBeUMsYUFBYTtBQUN0RDtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQztBQUMxQyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQyw4QkFBOEIsa0JBQWtCO0FBQ2hEO0FBQ087QUFDUCxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCLDRCQUE0QixzQkFBc0I7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztB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O0FBQ08saUNBQWlDLGlEQUFnQjtBQUN4RDtBQUNBLDhCQUE4QixNQUFNLHdCQUF3QixrQkFBa0I7QUFDOUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBLG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLGdDQUFnQyxpREFBZ0I7QUFDdkQsa0JBQWtCLG9CQUFvQjtBQUN0QyxzQ0FBc0MsUUFBUSwwQkFBMEIsVUFBVTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywwQ0FBMEMsaURBQWdCO0FBQ2pFLGtCQUFrQix5QkFBeUI7QUFDM0MsdUJBQXVCLDhDQUE4QyxjQUFjLE9BQU8sK0JBQStCLEtBQUs7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sMENBQTBDLGlEQUFnQjtBQUNqRSxrQkFBa0IseUJBQXlCO0FBQzNDLGlCQUFpQiw2QkFBNkIsRUFBRTtBQUNoRDtBQUNBLDRCQUE0QixVQUFVLEtBQUssOEJBQThCLFdBQVc7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEhleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlcXVhbEJ5dGVzIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC91dGlscyc7XG5pbXBvcnQgKiBhcyBCeXRlcyBmcm9tICcuL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuL0Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBpbnRlcm5hbF9ieXRlcyBmcm9tICcuL2ludGVybmFsL2J5dGVzLmpzJztcbmltcG9ydCAqIGFzIGludGVybmFsIGZyb20gJy4vaW50ZXJuYWwvaGV4LmpzJztcbmNvbnN0IGVuY29kZXIgPSAvKiNfX1BVUkVfXyovIG5ldyBUZXh0RW5jb2RlcigpO1xuY29uc3QgaGV4ZXMgPSAvKiNfX1BVUkVfXyovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBBc3NlcnRzIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguYXNzZXJ0KCdhYmMnKVxuICogLy8gQGVycm9yOiBJbnZhbGlkSGV4VmFsdWVUeXBlRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGBcImFiY1wiYCBvZiB0eXBlIGBzdHJpbmdgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiAvLyBAZXJyb3I6IEhleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4XFwke3N0cmluZ31cImAuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzZXJ0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGlmICghdmFsdWUpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VHlwZUVycm9yKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhUeXBlRXJyb3IodmFsdWUpO1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgaWYgKCEvXjB4WzAtOWEtZkEtRl0qJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFZhbHVlRXJyb3IodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoJzB4JykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4VmFsdWVFcnJvcih2YWx1ZSk7XG59XG4vKipcbiAqIENvbmNhdGVuYXRlcyB0d28gb3IgbW9yZSB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguY29uY2F0KCcweDEyMycsICcweDQ1NicpXG4gKiAvLyBAbG9nOiAnMHgxMjM0NTYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWVzIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBUaGUgY29uY2F0ZW5hdGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdCguLi52YWx1ZXMpIHtcbiAgICByZXR1cm4gYDB4JHt2YWx1ZXMucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgucmVwbGFjZSgnMHgnLCAnJyksICcnKX1gO1xufVxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgZnJvbSBhIGhleCBzdHJpbmcgb3Ige0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZS5cbiAqXG4gKiA6Ojp0aXBcbiAqXG4gKiBUbyBpbnN0YW50aWF0ZSBmcm9tIGEgKipCb29sZWFuKiosICoqU3RyaW5nKiosIG9yICoqTnVtYmVyKiosIHVzZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBIZXguZnJvbUJvb2xlYW5gXG4gKlxuICogLSBgSGV4LmZyb21TdHJpbmdgXG4gKlxuICogLSBgSGV4LmZyb21OdW1iZXJgXG4gKlxuICogOjo6XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmZyb20oJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJylcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbShCeXRlcy5mcm9tKFs3MiwgMTAxLCAxMDgsIDEwOCwgMTExLCAzMiwgODcsIDExMSwgMTE0LCAxMDgsIDEwMCwgMzNdKSlcbiAqIC8vIEBsb2c6ICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIHRvIGVuY29kZS5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20odmFsdWUpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHZhbHVlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiBmcm9tQnl0ZXMobmV3IFVpbnQ4QXJyYXkodmFsdWUpKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZXMgYSBib29sZWFuIGludG8gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSlcbiAqIC8vIEBsb2c6ICcweDEnXG4gKlxuICogSGV4LmZyb21Cb29sZWFuKGZhbHNlKVxuICogLy8gQGxvZzogJzB4MCdcbiAqXG4gKiBIZXguZnJvbUJvb2xlYW4odHJ1ZSwgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBib29sZWFuIHZhbHVlIHRvIGVuY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBlbmNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Cb29sZWFuKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBoZXggPSBgMHgke051bWJlcih2YWx1ZSl9YDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0U2l6ZShoZXgsIG9wdGlvbnMuc2l6ZSk7XG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzLCBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbUJ5dGVzKEJ5dGVzLmZyb20oWzcyLCAxMDEsIDEwOCwgMTA4LCAxMTEsIDMyLCA4NywgMTExLCAxMTQsIDEwOCwgMTAwLCAzM10pKVxuICogLy8gQGxvZzogJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyaW5nICs9IGhleGVzW3ZhbHVlW2ldXTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ31gO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5zaXplID09PSAnbnVtYmVyJykge1xuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgcmV0dXJuIHBhZFJpZ2h0KGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIG51bWJlciBvciBiaWdpbnQgaW50byBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMClcbiAqIC8vIEBsb2c6ICcweDFhNCdcbiAqXG4gKiBIZXguZnJvbU51bWJlcig0MjAsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxYTQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbnVtYmVyIG9yIGJpZ2ludCB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZW5jb2RlZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB2YWx1ZV8gPSBCaWdJbnQodmFsdWUpO1xuICAgIGxldCBtYXhWYWx1ZTtcbiAgICBpZiAoc2l6ZSkge1xuICAgICAgICBpZiAoc2lnbmVkKVxuICAgICAgICAgICAgbWF4VmFsdWUgPSAoMW4gPDwgKEJpZ0ludChzaXplKSAqIDhuIC0gMW4pKSAtIDFuO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBtYXhWYWx1ZSA9IDJuICoqIChCaWdJbnQoc2l6ZSkgKiA4bikgLSAxbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBtYXhWYWx1ZSA9IEJpZ0ludChOdW1iZXIuTUFYX1NBRkVfSU5URUdFUik7XG4gICAgfVxuICAgIGNvbnN0IG1pblZhbHVlID0gdHlwZW9mIG1heFZhbHVlID09PSAnYmlnaW50JyAmJiBzaWduZWQgPyAtbWF4VmFsdWUgLSAxbiA6IDA7XG4gICAgaWYgKChtYXhWYWx1ZSAmJiB2YWx1ZV8gPiBtYXhWYWx1ZSkgfHwgdmFsdWVfIDwgbWluVmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JyA/ICduJyA6ICcnO1xuICAgICAgICB0aHJvdyBuZXcgSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICBtYXg6IG1heFZhbHVlID8gYCR7bWF4VmFsdWV9JHtzdWZmaXh9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1pbjogYCR7bWluVmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICB2YWx1ZTogYCR7dmFsdWV9JHtzdWZmaXh9YCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ1ZhbHVlID0gKHNpZ25lZCAmJiB2YWx1ZV8gPCAwID8gKDFuIDw8IEJpZ0ludChzaXplICogOCkpICsgQmlnSW50KHZhbHVlXykgOiB2YWx1ZV8pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBoZXggPSBgMHgke3N0cmluZ1ZhbHVlfWA7XG4gICAgaWYgKHNpemUpXG4gICAgICAgIHJldHVybiBwYWRMZWZ0KGhleCwgc2l6ZSk7XG4gICAgcmV0dXJuIGhleDtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHN0cmluZyBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJylcbiAqIC8vICcweDQ4NjU2YzZjNmYyMDU3NmY3MjZjNjQyMSdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiAzMiB9KVxuICogLy8gJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgdmFsdWUgdG8gZW5jb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGVuY29kZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGZyb21CeXRlcyhlbmNvZGVyLmVuY29kZSh2YWx1ZSksIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGVhZGJlZWYnLCAnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LmlzRXF1YWwoJzB4ZGEnLCAnMHhiYScpXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleEEgLSBUaGUgZmlyc3Qge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICogQHBhcmFtIGhleEIgLSBUaGUgc2Vjb25kIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgdHdvIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwoaGV4QSwgaGV4Qikge1xuICAgIHJldHVybiBlcXVhbEJ5dGVzKEJ5dGVzLmZyb21IZXgoaGV4QSksIEJ5dGVzLmZyb21IZXgoaGV4QikpO1xufVxuLyoqXG4gKiBQYWRzIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRoZSBsZWZ0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDEyMzQnLCA0KVxuICogLy8gQGxvZzogJzB4MDAwMDEyMzQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHBhZC5cbiAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgKGluIGJ5dGVzKSBvZiB0aGUgb3V0cHV0IGhleCB2YWx1ZS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFkTGVmdCh2YWx1ZSwgc2l6ZSkge1xuICAgIHJldHVybiBpbnRlcm5hbC5wYWQodmFsdWUsIHsgZGlyOiAnbGVmdCcsIHNpemUgfSk7XG59XG4vKipcbiAqIFBhZHMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdGhlIHJpZ2h0IHdpdGggemVybyBieXRlcyB1bnRpbCBpdCByZWFjaGVzIHRoZSBnaXZlbiBgc2l6ZWAgKGRlZmF1bHQ6IDMyIGJ5dGVzKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRSaWdodCgnMHgxMjM0JywgNClcbiAqIC8vIEBsb2c6ICcweDEyMzQwMDAwJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBwYWQuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIChpbiBieXRlcykgb2YgdGhlIG91dHB1dCBoZXggdmFsdWUuXG4gKiBAcmV0dXJucyBUaGUgcGFkZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZFJpZ2h0KHZhbHVlLCBzaXplKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnBhZCh2YWx1ZSwgeyBkaXI6ICdyaWdodCcsIHNpemUgfSk7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBsZW5ndGguXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBoZXggPSBIZXgucmFuZG9tKDMyKVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICogYGBgXG4gKlxuICogQHJldHVybnMgUmFuZG9tIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbShsZW5ndGgpIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVzKEJ5dGVzLnJhbmRvbShsZW5ndGgpKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNlY3Rpb24gb2YgYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlIGdpdmVuIGEgc3RhcnQvZW5kIGJ5dGVzIG9mZnNldC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgMSwgNClcbiAqIC8vIEBsb2c6ICcweDIzNDU2NydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gc2xpY2UuXG4gKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgb2Zmc2V0IChpbiBieXRlcykuXG4gKiBAcGFyYW0gZW5kIC0gVGhlIGVuZCBvZmZzZXQgKGluIGJ5dGVzKS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzbGljZWQge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2UodmFsdWUsIHN0YXJ0LCBlbmQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc3RyaWN0IH0gPSBvcHRpb25zO1xuICAgIGludGVybmFsLmFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCk7XG4gICAgY29uc3QgdmFsdWVfID0gYDB4JHt2YWx1ZVxuICAgICAgICAucmVwbGFjZSgnMHgnLCAnJylcbiAgICAgICAgLnNsaWNlKChzdGFydCA/PyAwKSAqIDIsIChlbmQgPz8gdmFsdWUubGVuZ3RoKSAqIDIpfWA7XG4gICAgaWYgKHN0cmljdClcbiAgICAgICAgaW50ZXJuYWwuYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlXywgc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIHZhbHVlXztcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzaXplIG9mIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIChpbiBieXRlcykuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguc2l6ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiA0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGdldCB0aGUgc2l6ZSBvZi5cbiAqIEByZXR1cm5zIFRoZSBzaXplIG9mIHRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgKGluIGJ5dGVzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIpO1xufVxuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbUxlZnQoJzB4MDAwMDAwMDBkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiAnMHhkZWFkYmVlZidcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gdHJpbS5cbiAqIEByZXR1cm5zIFRoZSB0cmltbWVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1MZWZ0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGludGVybmFsLnRyaW0odmFsdWUsIHsgZGlyOiAnbGVmdCcgfSk7XG59XG4vKipcbiAqIFRyaW1zIHRyYWlsaW5nIHplcm9zIGZyb20gYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXgudHJpbVJpZ2h0KCcweGRlYWRiZWVmMDAwMDAwMDAnKVxuICogLy8gQGxvZzogJzB4ZGVhZGJlZWYnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIHRyaW0uXG4gKiBAcmV0dXJucyBUaGUgdHJpbW1lZCB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltUmlnaHQodmFsdWUpIHtcbiAgICByZXR1cm4gaW50ZXJuYWwudHJpbSh2YWx1ZSwgeyBkaXI6ICdyaWdodCcgfSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIEJpZ0ludC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0JpZ0ludCgnMHgxYTQnKVxuICogLy8gQGxvZzogNDIwblxuICpcbiAqIEhleC50b0JpZ0ludCgnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMWE0JywgeyBzaXplOiAzMiB9KVxuICogLy8gQGxvZzogNDIwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgQmlnSW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CaWdJbnQoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCB9ID0gb3B0aW9ucztcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludChoZXgpO1xuICAgIGlmICghc2lnbmVkKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgY29uc3Qgc2l6ZSA9IChoZXgubGVuZ3RoIC0gMikgLyAyO1xuICAgIGNvbnN0IG1heF91bnNpZ25lZCA9ICgxbiA8PCAoQmlnSW50KHNpemUpICogOG4pKSAtIDFuO1xuICAgIGNvbnN0IG1heF9zaWduZWQgPSBtYXhfdW5zaWduZWQgPj4gMW47XG4gICAgaWYgKHZhbHVlIDw9IG1heF9zaWduZWQpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWUgLSBtYXhfdW5zaWduZWQgLSAxbjtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgYm9vbGVhbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDEnKVxuICogLy8gQGxvZzogdHJ1ZVxuICpcbiAqIEhleC50b0Jvb2xlYW4oJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IHRydWVcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIGJvb2xlYW4uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Jvb2xlYW4oaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAob3B0aW9ucy5zaXplKVxuICAgICAgICBpbnRlcm5hbC5hc3NlcnRTaXplKGhleCwgb3B0aW9ucy5zaXplKTtcbiAgICBjb25zdCBoZXhfID0gdHJpbUxlZnQoaGV4KTtcbiAgICBpZiAoaGV4XyA9PT0gJzB4JylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChoZXhfID09PSAnMHgxJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgdGhyb3cgbmV3IEludmFsaWRIZXhCb29sZWFuRXJyb3IoaGV4KTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGRhdGEgPSBIZXgudG9CeXRlcygnMHg0ODY1NmM2YzZmMjA3NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogVWludDhBcnJheShbNzIsIDEwMSwgMTA4LCAxMDgsIDExMSwgMzIsIDg3LCAxMTEsIDExNCwgMTA4LCAxMDAsIDMzXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlIHRvIGRlY29kZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGhleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgoaGV4LCBvcHRpb25zKTtcbn1cbi8qKlxuICogRGVjb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgbnVtYmVyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvTnVtYmVyKCcweDFhNCcpXG4gKiAvLyBAbG9nOiA0MjBcbiAqXG4gKiBIZXgudG9OdW1iZXIoJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDFhNCcsIHsgc2l6ZTogMzIgfSlcbiAqIC8vIEBsb2c6IDQyMFxuICogYGBgXG4gKlxuICogQHBhcmFtIGhleCAtIFRoZSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgdG8gZGVjb2RlLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGRlY29kZWQgbnVtYmVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9OdW1iZXIoaGV4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHNpZ25lZCwgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXNpZ25lZCAmJiAhc2l6ZSlcbiAgICAgICAgcmV0dXJuIE51bWJlcihoZXgpO1xuICAgIHJldHVybiBOdW1iZXIodG9CaWdJbnQoaGV4LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIERlY29kZXMgYSB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIHN0cmluZy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC50b1N0cmluZygnMHg0ODY1NmM2YzZmMjA1NzZmNzI2YzY0MjEnKVxuICogLy8gQGxvZzogJ0hlbGxvIHdvcmxkISdcbiAqXG4gKiBIZXgudG9TdHJpbmcoJzB4NDg2NTZjNmM2ZjIwNTc2ZjcyNmM2NDIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIHtcbiAqICBzaXplOiAzMixcbiAqIH0pXG4gKiAvLyBAbG9nOiAnSGVsbG8gd29ybGQnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1N0cmluZyhoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2l6ZSB9ID0gb3B0aW9ucztcbiAgICBsZXQgYnl0ZXMgPSBCeXRlcy5mcm9tSGV4KGhleCk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgICAgaW50ZXJuYWxfYnl0ZXMuYXNzZXJ0U2l6ZShieXRlcywgc2l6ZSk7XG4gICAgICAgIGJ5dGVzID0gQnl0ZXMudHJpbVJpZ2h0KGJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC52YWxpZGF0ZSgnMHhkZWFkYmVlZicpXG4gKiAvLyBAbG9nOiB0cnVlXG4gKlxuICogSGV4LnZhbGlkYXRlKEJ5dGVzLmZyb20oWzEsIDIsIDNdKSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEge0BsaW5rIG94I0hleC5IZXh9LCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHN0cmljdCA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydCh2YWx1ZSwgeyBzdHJpY3QgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBpbnRlZ2VyIGlzIG91dCBvZiByYW5nZSwgYW5kIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhcyBhIGhleCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5mcm9tTnVtYmVyKDQyMDE4MjczODkxMjczMTI4MzcxMjkzNzEyOSlcbiAqIC8vIEBlcnJvcjogSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3I6IE51bWJlciBcXGA0LjIwMTgyNzM4OTEyNzMxMjZlKzI2XFxgIGlzIG5vdCBpbiBzYWZlIHVuc2lnbmVkIGludGVnZXIgcmFuZ2UgKGAwYCB0byBgOTAwNzE5OTI1NDc0MDk5MWApXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludGVnZXJPdXRPZlJhbmdlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG1heCwgbWluLCBzaWduZWQsIHNpemUsIHZhbHVlLCB9KSB7XG4gICAgICAgIHN1cGVyKGBOdW1iZXIgXFxgJHt2YWx1ZX1cXGAgaXMgbm90IGluIHNhZmUke3NpemUgPyBgICR7c2l6ZSAqIDh9LWJpdGAgOiAnJ30ke3NpZ25lZCA/ICcgc2lnbmVkJyA6ICcgdW5zaWduZWQnfSBpbnRlZ2VyIHJhbmdlICR7bWF4ID8gYChcXGAke21pbn1cXGAgdG8gXFxgJHttYXh9XFxgKWAgOiBgKGFib3ZlIFxcYCR7bWlufVxcYClgfWApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludGVnZXJPdXRPZlJhbmdlRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdGhlIHByb3ZpZGVkIGhleCB2YWx1ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBib29sZWFuLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSGV4IH0gZnJvbSAnb3gnXG4gKlxuICogSGV4LnRvQm9vbGVhbignMHhhJylcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhCb29sZWFuRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFcImAgaXMgbm90IGEgdmFsaWQgYm9vbGVhbi5cbiAqIC8vIEBlcnJvcjogVGhlIGhleCB2YWx1ZSBtdXN0IGJlIGBcIjB4MFwiYCAoZmFsc2UpIG9yIGBcIjB4MVwiYCAodHJ1ZSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhCb29sZWFuRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihoZXgpIHtcbiAgICAgICAgc3VwZXIoYEhleCB2YWx1ZSBcXGBcIiR7aGV4fVwiXFxgIGlzIG5vdCBhIHZhbGlkIGJvb2xlYW4uYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ1RoZSBoZXggdmFsdWUgbXVzdCBiZSBgXCIweDBcImAgKGZhbHNlKSBvciBgXCIweDFcImAgKHRydWUpLicsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4Qm9vbGVhbkVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBub3QgYSB2YWxpZCBoZXggdHlwZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoMSlcbiAqIC8vIEBlcnJvcjogSGV4LkludmFsaWRIZXhUeXBlRXJyb3I6IFZhbHVlIGAxYCBvZiB0eXBlIGBudW1iZXJgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRIZXhUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gSnNvbi5zdHJpbmdpZnkodmFsdWUpIDogdmFsdWV9XFxgIG9mIHR5cGUgXFxgJHt0eXBlb2YgdmFsdWV9XFxgIGlzIGFuIGludmFsaWQgaGV4IHR5cGUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0hleCB0eXBlcyBtdXN0IGJlIHJlcHJlc2VudGVkIGFzIGBcIjB4JHtzdHJpbmd9XCJgLiddLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0hleC5JbnZhbGlkSGV4VHlwZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5hc3NlcnQoJzB4MDEyMzQ1Njc4OWFiY2RlZmcnKVxuICogLy8gQGVycm9yOiBIZXguSW52YWxpZEhleFZhbHVlRXJyb3I6IFZhbHVlIGAweDAxMjM0NTY3ODlhYmNkZWZnYCBpcyBhbiBpbnZhbGlkIGhleCB2YWx1ZS5cbiAqIC8vIEBlcnJvcjogSGV4IHZhbHVlcyBtdXN0IHN0YXJ0IHdpdGggYFwiMHhcImAgYW5kIGNvbnRhaW4gb25seSBoZXhhZGVjaW1hbCBjaGFyYWN0ZXJzICgwLTksIGEtZiwgQS1GKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZEhleFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCBoZXggdmFsdWUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0hleCB2YWx1ZXMgbXVzdCBzdGFydCB3aXRoIGBcIjB4XCJgIGFuZCBjb250YWluIG9ubHkgaGV4YWRlY2ltYWwgY2hhcmFjdGVycyAoMC05LCBhLWYsIEEtRikuJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRIZXhWYWx1ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBwcm92aWRlZCBoZXggdmFsdWUgaXMgYW4gb2RkIGxlbmd0aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEJ5dGVzIH0gZnJvbSAnb3gnXG4gKlxuICogQnl0ZXMuZnJvbUhleCgnMHhhYmNkZScpXG4gKiAvLyBAZXJyb3I6IEhleC5JbnZhbGlkTGVuZ3RoRXJyb3I6IEhleCB2YWx1ZSBgXCIweGFiY2RlXCJgIGlzIGFuIG9kZCBsZW5ndGggKDUgbmliYmxlcykuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRMZW5ndGhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKGBIZXggdmFsdWUgXFxgXCIke3ZhbHVlfVwiXFxgIGlzIGFuIG9kZCBsZW5ndGggKCR7dmFsdWUubGVuZ3RoIC0gMn0gbmliYmxlcykuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbJ0l0IG11c3QgYmUgYW4gZXZlbiBsZW5ndGguJ10sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LkludmFsaWRMZW5ndGhFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiB0aGUgc2l6ZSBvZiB0aGUgdmFsdWUgZXhjZWVkcyB0aGUgZXhwZWN0ZWQgbWF4IHNpemUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBIZXggfSBmcm9tICdveCdcbiAqXG4gKiBIZXguZnJvbVN0cmluZygnSGVsbG8gV29ybGQhJywgeyBzaXplOiA4IH0pXG4gKiAvLyBAZXJyb3I6IEhleC5TaXplT3ZlcmZsb3dFcnJvcjogU2l6ZSBjYW5ub3QgZXhjZWVkIGA4YCBieXRlcy4gR2l2ZW4gc2l6ZTogYDEyYCBieXRlcy5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZU92ZXJmbG93RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGdpdmVuU2l6ZSwgbWF4U2l6ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaXplIGNhbm5vdCBleGNlZWQgXFxgJHttYXhTaXplfVxcYCBieXRlcy4gR2l2ZW4gc2l6ZTogXFxgJHtnaXZlblNpemV9XFxgIGJ5dGVzLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnSGV4LlNpemVPdmVyZmxvd0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzbGljZSBvZmZzZXQgZXhjZWVkcyB0aGUgYm91bmRzIG9mIHRoZSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5zbGljZSgnMHgwMTIzNDU2Nzg5JywgNilcbiAqIC8vIEBlcnJvcjogSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcjogU2xpY2Ugc3RhcnRpbmcgYXQgb2Zmc2V0IGA2YCBpcyBvdXQtb2YtYm91bmRzIChzaXplOiBgNWApLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9mZnNldCwgcG9zaXRpb24sIHNpemUsIH0pIHtcbiAgICAgICAgc3VwZXIoYFNsaWNlICR7cG9zaXRpb24gPT09ICdzdGFydCcgPyAnc3RhcnRpbmcnIDogJ2VuZGluZyd9IGF0IG9mZnNldCBcXGAke29mZnNldH1cXGAgaXMgb3V0LW9mLWJvdW5kcyAoc2l6ZTogXFxgJHtzaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIHRoZSBzaXplIG9mIHRoZSB2YWx1ZSBleGNlZWRzIHRoZSBwYWQgc2l6ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEhleCB9IGZyb20gJ294J1xuICpcbiAqIEhleC5wYWRMZWZ0KCcweDFhNGUxMmE0NWEyMTMyMzEyM2FhYTg3YTg5N2E4OTdhODk4YTY1NjdhNTc4YTg2N2E5ODc3OGE2NjdhODVhODc1YTg3YTZhNzg3YTY1YTY3NWE2YTknLCAzMilcbiAqIC8vIEBlcnJvcjogSGV4LlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcjogSGV4IHNpemUgKGA0M2ApIGV4Y2VlZHMgcGFkZGluZyBzaXplIChgMzJgKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzaXplLCB0YXJnZXRTaXplLCB0eXBlLCB9KSB7XG4gICAgICAgIHN1cGVyKGAke3R5cGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0eXBlXG4gICAgICAgICAgICAuc2xpY2UoMSlcbiAgICAgICAgICAgIC50b0xvd2VyQ2FzZSgpfSBzaXplIChcXGAke3NpemV9XFxgKSBleGNlZWRzIHBhZGRpbmcgc2l6ZSAoXFxgJHt0YXJnZXRTaXplfVxcYCkuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IZXguanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Hex.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Json.js":
/*!***********************************************!*\
  !*** ../../node_modules/ox/_esm/core/Json.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   stringify: () => (/* binding */ stringify)\n/* harmony export */ });\nconst bigIntSuffix = '#__bigint';\n/**\n * Parses a JSON string, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.parse('{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}')\n * // @log: {\n * // @log:   foo: 'bar',\n * // @log:   baz: 69420694206942069420694206942069420694206942069420n\n * // @log: }\n * ```\n *\n * @param string - The value to parse.\n * @param reviver - A function that transforms the results.\n * @returns The parsed value.\n */\nfunction parse(string, reviver) {\n    return JSON.parse(string, (key, value_) => {\n        const value = value_;\n        if (typeof value === 'string' && value.endsWith(bigIntSuffix))\n            return BigInt(value.slice(0, -bigIntSuffix.length));\n        return typeof reviver === 'function' ? reviver(key, value) : value;\n    });\n}\n/**\n * Stringifies a value to its JSON representation, with support for `bigint`.\n *\n * @example\n * ```ts twoslash\n * import { Json } from 'ox'\n *\n * const json = Json.stringify({\n *   foo: 'bar',\n *   baz: 69420694206942069420694206942069420694206942069420n,\n * })\n * // @log: '{\"foo\":\"bar\",\"baz\":\"69420694206942069420694206942069420694206942069420#__bigint\"}'\n * ```\n *\n * @param value - The value to stringify.\n * @param replacer - A function that transforms the results. It is passed the key and value of the property, and must return the value to be used in the JSON string. If this function returns `undefined`, the property is not included in the resulting JSON string.\n * @param space - A string or number that determines the indentation of the JSON string. If it is a number, it indicates the number of spaces to use as indentation; if it is a string (e.g. `'\\t'`), it uses the string as the indentation character.\n * @returns The JSON string.\n */\nfunction stringify(value, replacer, space) {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof replacer === 'function')\n            return replacer(key, value);\n        if (typeof value === 'bigint')\n            return value.toString() + bigIntSuffix;\n        return value;\n    }, space);\n}\n//# sourceMappingURL=Json.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Kc29uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsNkJBQTZCLGdGQUFnRjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osY0FBYyxnRkFBZ0Y7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxS0FBcUs7QUFDcks7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXEpzb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYmlnSW50U3VmZml4ID0gJyNfX2JpZ2ludCc7XG4vKipcbiAqIFBhcnNlcyBhIEpTT04gc3RyaW5nLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnBhcnNlKCd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGZvbzogJ2JhcicsXG4gKiAvLyBAbG9nOiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RyaW5nIC0gVGhlIHZhbHVlIHRvIHBhcnNlLlxuICogQHBhcmFtIHJldml2ZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy5cbiAqIEByZXR1cm5zIFRoZSBwYXJzZWQgdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShzdHJpbmcsIHJldml2ZXIpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShzdHJpbmcsIChrZXksIHZhbHVlXykgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlXztcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoYmlnSW50U3VmZml4KSlcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodmFsdWUuc2xpY2UoMCwgLWJpZ0ludFN1ZmZpeC5sZW5ndGgpKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gcmV2aXZlcihrZXksIHZhbHVlKSA6IHZhbHVlO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTdHJpbmdpZmllcyBhIHZhbHVlIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLCB3aXRoIHN1cHBvcnQgZm9yIGBiaWdpbnRgLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgSnNvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGpzb24gPSBKc29uLnN0cmluZ2lmeSh7XG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIGJhejogNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjBuLFxuICogfSlcbiAqIC8vIEBsb2c6ICd7XCJmb29cIjpcImJhclwiLFwiYmF6XCI6XCI2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMDY5NDIwNjk0MjA2OTQyMCNfX2JpZ2ludFwifSdcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBzdHJpbmdpZnkuXG4gKiBAcGFyYW0gcmVwbGFjZXIgLSBBIGZ1bmN0aW9uIHRoYXQgdHJhbnNmb3JtcyB0aGUgcmVzdWx0cy4gSXQgaXMgcGFzc2VkIHRoZSBrZXkgYW5kIHZhbHVlIG9mIHRoZSBwcm9wZXJ0eSwgYW5kIG11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0byBiZSB1c2VkIGluIHRoZSBKU09OIHN0cmluZy4gSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLCB0aGUgcHJvcGVydHkgaXMgbm90IGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgSlNPTiBzdHJpbmcuXG4gKiBAcGFyYW0gc3BhY2UgLSBBIHN0cmluZyBvciBudW1iZXIgdGhhdCBkZXRlcm1pbmVzIHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgSlNPTiBzdHJpbmcuIElmIGl0IGlzIGEgbnVtYmVyLCBpdCBpbmRpY2F0ZXMgdGhlIG51bWJlciBvZiBzcGFjZXMgdG8gdXNlIGFzIGluZGVudGF0aW9uOyBpZiBpdCBpcyBhIHN0cmluZyAoZS5nLiBgJ1xcdCdgKSwgaXQgdXNlcyB0aGUgc3RyaW5nIGFzIHRoZSBpbmRlbnRhdGlvbiBjaGFyYWN0ZXIuXG4gKiBAcmV0dXJucyBUaGUgSlNPTiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlcihrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIGJpZ0ludFN1ZmZpeDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIHNwYWNlKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUpzb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Json.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/PublicKey.js":
/*!****************************************************!*\
  !*** ../../node_modules/ox/_esm/core/PublicKey.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidCompressedPrefixError: () => (/* binding */ InvalidCompressedPrefixError),\n/* harmony export */   InvalidError: () => (/* binding */ InvalidError),\n/* harmony export */   InvalidPrefixError: () => (/* binding */ InvalidPrefixError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidUncompressedPrefixError: () => (/* binding */ InvalidUncompressedPrefixError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   compress: () => (/* binding */ compress),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Json.js */ \"(ssr)/../../node_modules/ox/_esm/core/Json.js\");\n\n\n\n\n/**\n * Asserts that a {@link ox#PublicKey.PublicKey} is valid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @error: PublicKey.InvalidError: Value \\`{\"y\":\"1\"}\\` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction assert(publicKey, options = {}) {\n    const { compressed } = options;\n    const { prefix, x, y } = publicKey;\n    // Uncompressed\n    if (compressed === false ||\n        (typeof x === 'bigint' && typeof y === 'bigint')) {\n        if (prefix !== 4)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidUncompressedPrefixError(),\n            });\n        return;\n    }\n    // Compressed\n    if (compressed === true ||\n        (typeof x === 'bigint' && typeof y === 'undefined')) {\n        if (prefix !== 3 && prefix !== 2)\n            throw new InvalidPrefixError({\n                prefix,\n                cause: new InvalidCompressedPrefixError(),\n            });\n        return;\n    }\n    // Unknown/invalid\n    throw new InvalidError({ publicKey });\n}\n/**\n * Compresses a {@link ox#PublicKey.PublicKey}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const compressed = PublicKey.compress(publicKey) // [!code focus]\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The public key to compress.\n * @returns The compressed public key.\n */\nfunction compress(publicKey) {\n    const { x, y } = publicKey;\n    return {\n        prefix: y % 2n === 0n ? 2 : 3,\n        x,\n    };\n}\n/**\n * Instantiates a typed {@link ox#PublicKey.PublicKey} object from a {@link ox#PublicKey.PublicKey}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from('0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param value - The public key value to instantiate.\n * @returns The instantiated {@link ox#PublicKey.PublicKey}.\n */\nfunction from(value) {\n    const publicKey = (() => {\n        if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.validate(value))\n            return fromHex(value);\n        if (_Bytes_js__WEBPACK_IMPORTED_MODULE_1__.validate(value))\n            return fromBytes(value);\n        const { prefix, x, y } = value;\n        if (typeof x === 'bigint' && typeof y === 'bigint')\n            return { prefix: prefix ?? 0x04, x, y };\n        return { prefix, x };\n    })();\n    assert(publicKey);\n    return publicKey;\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromBytes(publicKey) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(publicKey));\n}\n/**\n * Deserializes a {@link ox#PublicKey.PublicKey} from a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5')\n * // @log: {\n * // @log:   prefix: 4,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log:   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * // @log: }\n * ```\n *\n * @example\n * ### Deserializing a Compressed Public Key\n *\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.fromHex('0x038318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed75')\n * // @log: {\n * // @log:   prefix: 3,\n * // @log:   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n * // @log: }\n * ```\n *\n * @param publicKey - The serialized public key.\n * @returns The deserialized public key.\n */\nfunction fromHex(publicKey) {\n    if (publicKey.length !== 132 &&\n        publicKey.length !== 130 &&\n        publicKey.length !== 68)\n        throw new InvalidSerializedSizeError({ publicKey });\n    if (publicKey.length === 130) {\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 32));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 32, 64));\n        return {\n            prefix: 4,\n            x,\n            y,\n        };\n    }\n    if (publicKey.length === 132) {\n        const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n        const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n        const y = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 33, 65));\n        return {\n            prefix,\n            x,\n            y,\n        };\n    }\n    const prefix = Number(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 0, 1));\n    const x = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.slice(publicKey, 1, 33));\n    return {\n        prefix,\n        x,\n    };\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const bytes = PublicKey.toBytes(publicKey) // [!code focus]\n * // @log: Uint8Array [128, 3, 131, ...]\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toBytes(publicKey, options = {}) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(toHex(publicKey, options));\n}\n/**\n * Serializes a {@link ox#PublicKey.PublicKey} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const publicKey = PublicKey.from({\n *   prefix: 4,\n *   x: 59295962801117472859457908919941473389380284132224861839820747729565200149877n,\n *   y: 24099691209996290925259367678540227198235484593389470330605641003500238088869n,\n * })\n *\n * const hex = PublicKey.toHex(publicKey) // [!code focus]\n * // @log: '0x048318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5'\n * ```\n *\n * @param publicKey - The public key to serialize.\n * @returns The serialized public key.\n */\nfunction toHex(publicKey, options = {}) {\n    assert(publicKey);\n    const { prefix, x, y } = publicKey;\n    const { includePrefix = true } = options;\n    const publicKey_ = _Hex_js__WEBPACK_IMPORTED_MODULE_0__.concat(includePrefix ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(prefix, { size: 1 }) : '0x', _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(x, { size: 32 }), \n    // If the public key is not compressed, add the y coordinate.\n    typeof y === 'bigint' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(y, { size: 32 }) : '0x');\n    return publicKey_;\n}\n/**\n * Validates a {@link ox#PublicKey.PublicKey}. Returns `true` if valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * const valid = PublicKey.validate({\n *   prefix: 4,\n *   y: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * })\n * // @log: false\n * ```\n *\n * @param publicKey - The public key object to assert.\n */\nfunction validate(publicKey, options = {}) {\n    try {\n        assert(publicKey, options);\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Thrown when a public key is invalid.\n *\n * @example\n * ```ts twoslash\n * import { PublicKey } from 'ox'\n *\n * PublicKey.assert({ y: 1n })\n * // @error: PublicKey.InvalidError: Value `{\"y\":1n}` is not a valid public key.\n * // @error: Public key must contain:\n * // @error: - an `x` and `prefix` value (compressed)\n * // @error: - an `x`, `y`, and `prefix` value (uncompressed)\n * ```\n */\nclass InvalidError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${_Json_js__WEBPACK_IMPORTED_MODULE_3__.stringify(publicKey)}\\` is not a valid public key.`, {\n            metaMessages: [\n                'Public key must contain:',\n                '- an `x` and `prefix` value (compressed)',\n                '- an `x`, `y`, and `prefix` value (uncompressed)',\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidError'\n        });\n    }\n}\n/** Thrown when a public key has an invalid prefix. */\nclass InvalidPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ prefix, cause }) {\n        super(`Prefix \"${prefix}\" is invalid.`, {\n            cause,\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for a compressed public key. */\nclass InvalidCompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 2 or 3 for compressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidCompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid prefix for an uncompressed public key. */\nclass InvalidUncompressedPrefixError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor() {\n        super('Prefix must be 4 for uncompressed public keys.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidUncompressedPrefixError'\n        });\n    }\n}\n/** Thrown when the public key has an invalid serialized size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_2__.BaseError {\n    constructor({ publicKey }) {\n        super(`Value \\`${publicKey}\\` is an invalid public key size.`, {\n            metaMessages: [\n                'Expected: 33 bytes (compressed + prefix), 64 bytes (uncompressed) or 65 bytes (uncompressed + prefix).',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_0__.from(publicKey))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'PublicKey.InvalidSerializedSizeError'\n        });\n    }\n}\n//# sourceMappingURL=PublicKey.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9QdWJsaWNLZXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ0U7QUFDbEM7QUFDQSxtQkFBbUIsOEJBQThCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHVDQUF1QztBQUM5QyxZQUFZLGFBQWE7QUFDekIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDhCQUE4QixlQUFlLDZCQUE2QixHQUFHLHFCQUFxQixNQUFNLGlCQUFpQjtBQUNsSjtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThC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QUEyQyxpREFBZ0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNkNBQTZDLGlEQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUMsaURBQWdCO0FBQ2hFLGtCQUFrQixXQUFXO0FBQzdCLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQSw0QkFBNEIseUNBQVEsQ0FBQyx5Q0FBUSxjQUFjO0FBQzNEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxQdWJsaWNLZXkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQnl0ZXMgZnJvbSAnLi9CeXRlcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIEpzb24gZnJvbSAnLi9Kc29uLmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogUHVibGljS2V5LmFzc2VydCh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeTogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogfSlcbiAqIC8vIEBlcnJvcjogUHVibGljS2V5LkludmFsaWRFcnJvcjogVmFsdWUgXFxge1wieVwiOlwiMVwifVxcYCBpcyBub3QgYSB2YWxpZCBwdWJsaWMga2V5LlxuICogLy8gQGVycm9yOiBQdWJsaWMga2V5IG11c3QgY29udGFpbjpcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKVxuICogLy8gQGVycm9yOiAtIGFuIGB4YCwgYHlgLCBhbmQgYHByZWZpeGAgdmFsdWUgKHVuY29tcHJlc3NlZClcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjb21wcmVzc2VkIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgLy8gVW5jb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IGZhbHNlIHx8XG4gICAgICAgICh0eXBlb2YgeCA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHkgPT09ICdiaWdpbnQnKSkge1xuICAgICAgICBpZiAocHJlZml4ICE9PSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZFVuY29tcHJlc3NlZFByZWZpeEVycm9yKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2VkXG4gICAgaWYgKGNvbXByZXNzZWQgPT09IHRydWUgfHxcbiAgICAgICAgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgIGlmIChwcmVmaXggIT09IDMgJiYgcHJlZml4ICE9PSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQcmVmaXhFcnJvcih7XG4gICAgICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgICAgIGNhdXNlOiBuZXcgSW52YWxpZENvbXByZXNzZWRQcmVmaXhFcnJvcigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVW5rbm93bi9pbnZhbGlkXG4gICAgdGhyb3cgbmV3IEludmFsaWRFcnJvcih7IHB1YmxpY0tleSB9KTtcbn1cbi8qKlxuICogQ29tcHJlc3NlcyBhIHtAbGluayBveCNQdWJsaWNLZXkuUHVibGljS2V5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgY29tcHJlc3NlZCA9IFB1YmxpY0tleS5jb21wcmVzcyhwdWJsaWNLZXkpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiAzLFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHB1YmxpYyBrZXkgdG8gY29tcHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHJlc3MocHVibGljS2V5KSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlZml4OiB5ICUgMm4gPT09IDBuID8gMiA6IDMsXG4gICAgICAgIHgsXG4gICAgfTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LCBvciB7QGxpbmsgb3gjSGV4LkhleH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDQsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6ICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oJzB4MDQ4MzE4NTM1YjU0MTA1ZDRhN2FhZTYwYzA4ZmM0NWY5Njg3MTgxYjRmZGZjNjI1YmQxYTc1M2ZhNzM5N2ZlZDc1MzU0N2YxMWNhODY5NjY0NmYyZjNhY2IwOGUzMTAxNmFmYWMyM2U2MzBjNWQxMWY1OWY2MWZlZjU3YjBkMmFhNScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgcHVibGljIGtleSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChIZXgudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgodmFsdWUpO1xuICAgICAgICBpZiAoQnl0ZXMudmFsaWRhdGUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21CeXRlcyh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiB0eXBlb2YgeSA9PT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCA/PyAweDA0LCB4LCB5IH07XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgeCB9O1xuICAgIH0pKCk7XG4gICAgYXNzZXJ0KHB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHB1YmxpY0tleTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IGZyb20gYSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHByZWZpeDogNCxcbiAqIC8vIEBsb2c6ICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogLy8gQGxvZzogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gcHVibGljS2V5IC0gVGhlIHNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqIEByZXR1cm5zIFRoZSBkZXNlcmlhbGl6ZWQgcHVibGljIGtleS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21CeXRlcyhwdWJsaWNLZXkpIHtcbiAgICByZXR1cm4gZnJvbUhleChIZXguZnJvbUJ5dGVzKHB1YmxpY0tleSkpO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gZnJvbSBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHB1YmxpY0tleSA9IFB1YmxpY0tleS5mcm9tSGV4KCcweDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1JylcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcHJlZml4OiA0LFxuICogLy8gQGxvZzogICB4OiA1OTI5NTk2MjgwMTExNzQ3Mjg1OTQ1NzkwODkxOTk0MTQ3MzM4OTM4MDI4NDEzMjIyNDg2MTgzOTgyMDc0NzcyOTU2NTIwMDE0OTg3N24sXG4gKiAvLyBAbG9nOiAgIHk6IDI0MDk5NjkxMjA5OTk2MjkwOTI1MjU5MzY3Njc4NTQwMjI3MTk4MjM1NDg0NTkzMzg5NDcwMzMwNjA1NjQxMDAzNTAwMjM4MDg4ODY5bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRGVzZXJpYWxpemluZyBhIENvbXByZXNzZWQgUHVibGljIEtleVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbUhleCgnMHgwMzgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBwcmVmaXg6IDMsXG4gKiAvLyBAbG9nOiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCBwdWJsaWMga2V5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMTMyICYmXG4gICAgICAgIHB1YmxpY0tleS5sZW5ndGggIT09IDEzMCAmJlxuICAgICAgICBwdWJsaWNLZXkubGVuZ3RoICE9PSA2OClcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yKHsgcHVibGljS2V5IH0pO1xuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzApIHtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAwLCAzMikpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMyLCA2NCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4OiA0LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSAxMzIpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gTnVtYmVyKEhleC5zbGljZShwdWJsaWNLZXksIDAsIDEpKTtcbiAgICAgICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgICAgICBjb25zdCB5ID0gQmlnSW50KEhleC5zbGljZShwdWJsaWNLZXksIDMzLCA2NSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHJlZml4LFxuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IE51bWJlcihIZXguc2xpY2UocHVibGljS2V5LCAwLCAxKSk7XG4gICAgY29uc3QgeCA9IEJpZ0ludChIZXguc2xpY2UocHVibGljS2V5LCAxLCAzMykpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgeCxcbiAgICB9O1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1B1YmxpY0tleS5QdWJsaWNLZXl9IHRvIHtAbGluayBveCNCeXRlcy5CeXRlc30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBQdWJsaWNLZXkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBwdWJsaWNLZXkgPSBQdWJsaWNLZXkuZnJvbSh7XG4gKiAgIHByZWZpeDogNCxcbiAqICAgeDogNTkyOTU5NjI4MDExMTc0NzI4NTk0NTc5MDg5MTk5NDE0NzMzODkzODAyODQxMzIyMjQ4NjE4Mzk4MjA3NDc3Mjk1NjUyMDAxNDk4NzduLFxuICogICB5OiAyNDA5OTY5MTIwOTk5NjI5MDkyNTI1OTM2NzY3ODU0MDIyNzE5ODIzNTQ4NDU5MzM4OTQ3MDMzMDYwNTY0MTAwMzUwMDIzODA4ODg2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IGJ5dGVzID0gUHVibGljS2V5LnRvQnl0ZXMocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMjgsIDMsIDEzMSwgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHB1YmxpY0tleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIEJ5dGVzLmZyb21IZXgodG9IZXgocHVibGljS2V5LCBvcHRpb25zKSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0gdG8ge0BsaW5rIG94I0hleC5IZXh9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUHVibGljS2V5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgcHVibGljS2V5ID0gUHVibGljS2V5LmZyb20oe1xuICogICBwcmVmaXg6IDQsXG4gKiAgIHg6IDU5Mjk1OTYyODAxMTE3NDcyODU5NDU3OTA4OTE5OTQxNDczMzg5MzgwMjg0MTMyMjI0ODYxODM5ODIwNzQ3NzI5NTY1MjAwMTQ5ODc3bixcbiAqICAgeTogMjQwOTk2OTEyMDk5OTYyOTA5MjUyNTkzNjc2Nzg1NDAyMjcxOTgyMzU0ODQ1OTMzODk0NzAzMzA2MDU2NDEwMDM1MDAyMzgwODg4NjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoZXggPSBQdWJsaWNLZXkudG9IZXgocHVibGljS2V5KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHgwNDgzMTg1MzViNTQxMDVkNGE3YWFlNjBjMDhmYzQ1Zjk2ODcxODFiNGZkZmM2MjViZDFhNzUzZmE3Mzk3ZmVkNzUzNTQ3ZjExY2E4Njk2NjQ2ZjJmM2FjYjA4ZTMxMDE2YWZhYzIzZTYzMGM1ZDExZjU5ZjYxZmVmNTdiMGQyYWE1J1xuICogYGBgXG4gKlxuICogQHBhcmFtIHB1YmxpY0tleSAtIFRoZSBwdWJsaWMga2V5IHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHB1YmxpYyBrZXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0hleChwdWJsaWNLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgIGFzc2VydChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHsgcHJlZml4LCB4LCB5IH0gPSBwdWJsaWNLZXk7XG4gICAgY29uc3QgeyBpbmNsdWRlUHJlZml4ID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBwdWJsaWNLZXlfID0gSGV4LmNvbmNhdChpbmNsdWRlUHJlZml4ID8gSGV4LmZyb21OdW1iZXIocHJlZml4LCB7IHNpemU6IDEgfSkgOiAnMHgnLCBIZXguZnJvbU51bWJlcih4LCB7IHNpemU6IDMyIH0pLCBcbiAgICAvLyBJZiB0aGUgcHVibGljIGtleSBpcyBub3QgY29tcHJlc3NlZCwgYWRkIHRoZSB5IGNvb3JkaW5hdGUuXG4gICAgdHlwZW9mIHkgPT09ICdiaWdpbnQnID8gSGV4LmZyb21OdW1iZXIoeSwgeyBzaXplOiAzMiB9KSA6ICcweCcpO1xuICAgIHJldHVybiBwdWJsaWNLZXlfO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjUHVibGljS2V5LlB1YmxpY0tleX0uIFJldHVybnMgYHRydWVgIGlmIHZhbGlkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHZhbGlkID0gUHVibGljS2V5LnZhbGlkYXRlKHtcbiAqICAgcHJlZml4OiA0LFxuICogICB5OiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwdWJsaWNLZXkgLSBUaGUgcHVibGljIGtleSBvYmplY3QgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUocHVibGljS2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQocHVibGljS2V5LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaXMgaW52YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ294J1xuICpcbiAqIFB1YmxpY0tleS5hc3NlcnQoeyB5OiAxbiB9KVxuICogLy8gQGVycm9yOiBQdWJsaWNLZXkuSW52YWxpZEVycm9yOiBWYWx1ZSBge1wieVwiOjFufWAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5cbiAqIC8vIEBlcnJvcjogUHVibGljIGtleSBtdXN0IGNvbnRhaW46XG4gKiAvLyBAZXJyb3I6IC0gYW4gYHhgIGFuZCBgcHJlZml4YCB2YWx1ZSAoY29tcHJlc3NlZClcbiAqIC8vIEBlcnJvcjogLSBhbiBgeGAsIGB5YCwgYW5kIGBwcmVmaXhgIHZhbHVlICh1bmNvbXByZXNzZWQpXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHVibGljS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7SnNvbi5zdHJpbmdpZnkocHVibGljS2V5KX1cXGAgaXMgbm90IGEgdmFsaWQgcHVibGljIGtleS5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICAnUHVibGljIGtleSBtdXN0IGNvbnRhaW46JyxcbiAgICAgICAgICAgICAgICAnLSBhbiBgeGAgYW5kIGBwcmVmaXhgIHZhbHVlIChjb21wcmVzc2VkKScsXG4gICAgICAgICAgICAgICAgJy0gYW4gYHhgLCBgeWAsIGFuZCBgcHJlZml4YCB2YWx1ZSAodW5jb21wcmVzc2VkKScsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiBhIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRQcmVmaXhFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgcHJlZml4LCBjYXVzZSB9KSB7XG4gICAgICAgIHN1cGVyKGBQcmVmaXggXCIke3ByZWZpeH1cIiBpcyBpbnZhbGlkLmAsIHtcbiAgICAgICAgICAgIGNhdXNlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBwcmVmaXggZm9yIGEgY29tcHJlc3NlZCBwdWJsaWMga2V5LiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRDb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDIgb3IgMyBmb3IgY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkQ29tcHJlc3NlZFByZWZpeEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHB1YmxpYyBrZXkgaGFzIGFuIGludmFsaWQgcHJlZml4IGZvciBhbiB1bmNvbXByZXNzZWQgcHVibGljIGtleS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJ1ByZWZpeCBtdXN0IGJlIDQgZm9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cy4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkVW5jb21wcmVzc2VkUHJlZml4RXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgcHVibGljIGtleSBoYXMgYW4gaW52YWxpZCBzZXJpYWxpemVkIHNpemUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHB1YmxpY0tleSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3B1YmxpY0tleX1cXGAgaXMgYW4gaW52YWxpZCBwdWJsaWMga2V5IHNpemUuYCwge1xuICAgICAgICAgICAgbWV0YU1lc3NhZ2VzOiBbXG4gICAgICAgICAgICAgICAgJ0V4cGVjdGVkOiAzMyBieXRlcyAoY29tcHJlc3NlZCArIHByZWZpeCksIDY0IGJ5dGVzICh1bmNvbXByZXNzZWQpIG9yIDY1IGJ5dGVzICh1bmNvbXByZXNzZWQgKyBwcmVmaXgpLicsXG4gICAgICAgICAgICAgICAgYFJlY2VpdmVkICR7SGV4LnNpemUoSGV4LmZyb20ocHVibGljS2V5KSl9IGJ5dGVzLmAsXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1B1YmxpY0tleS5JbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHVibGljS2V5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/PublicKey.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Solidity.js":
/*!***************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Solidity.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayRegex: () => (/* binding */ arrayRegex),\n/* harmony export */   bytesRegex: () => (/* binding */ bytesRegex),\n/* harmony export */   integerRegex: () => (/* binding */ integerRegex),\n/* harmony export */   maxInt104: () => (/* binding */ maxInt104),\n/* harmony export */   maxInt112: () => (/* binding */ maxInt112),\n/* harmony export */   maxInt120: () => (/* binding */ maxInt120),\n/* harmony export */   maxInt128: () => (/* binding */ maxInt128),\n/* harmony export */   maxInt136: () => (/* binding */ maxInt136),\n/* harmony export */   maxInt144: () => (/* binding */ maxInt144),\n/* harmony export */   maxInt152: () => (/* binding */ maxInt152),\n/* harmony export */   maxInt16: () => (/* binding */ maxInt16),\n/* harmony export */   maxInt160: () => (/* binding */ maxInt160),\n/* harmony export */   maxInt168: () => (/* binding */ maxInt168),\n/* harmony export */   maxInt176: () => (/* binding */ maxInt176),\n/* harmony export */   maxInt184: () => (/* binding */ maxInt184),\n/* harmony export */   maxInt192: () => (/* binding */ maxInt192),\n/* harmony export */   maxInt200: () => (/* binding */ maxInt200),\n/* harmony export */   maxInt208: () => (/* binding */ maxInt208),\n/* harmony export */   maxInt216: () => (/* binding */ maxInt216),\n/* harmony export */   maxInt224: () => (/* binding */ maxInt224),\n/* harmony export */   maxInt232: () => (/* binding */ maxInt232),\n/* harmony export */   maxInt24: () => (/* binding */ maxInt24),\n/* harmony export */   maxInt240: () => (/* binding */ maxInt240),\n/* harmony export */   maxInt248: () => (/* binding */ maxInt248),\n/* harmony export */   maxInt256: () => (/* binding */ maxInt256),\n/* harmony export */   maxInt32: () => (/* binding */ maxInt32),\n/* harmony export */   maxInt40: () => (/* binding */ maxInt40),\n/* harmony export */   maxInt48: () => (/* binding */ maxInt48),\n/* harmony export */   maxInt56: () => (/* binding */ maxInt56),\n/* harmony export */   maxInt64: () => (/* binding */ maxInt64),\n/* harmony export */   maxInt72: () => (/* binding */ maxInt72),\n/* harmony export */   maxInt8: () => (/* binding */ maxInt8),\n/* harmony export */   maxInt80: () => (/* binding */ maxInt80),\n/* harmony export */   maxInt88: () => (/* binding */ maxInt88),\n/* harmony export */   maxInt96: () => (/* binding */ maxInt96),\n/* harmony export */   maxUint104: () => (/* binding */ maxUint104),\n/* harmony export */   maxUint112: () => (/* binding */ maxUint112),\n/* harmony export */   maxUint120: () => (/* binding */ maxUint120),\n/* harmony export */   maxUint128: () => (/* binding */ maxUint128),\n/* harmony export */   maxUint136: () => (/* binding */ maxUint136),\n/* harmony export */   maxUint144: () => (/* binding */ maxUint144),\n/* harmony export */   maxUint152: () => (/* binding */ maxUint152),\n/* harmony export */   maxUint16: () => (/* binding */ maxUint16),\n/* harmony export */   maxUint160: () => (/* binding */ maxUint160),\n/* harmony export */   maxUint168: () => (/* binding */ maxUint168),\n/* harmony export */   maxUint176: () => (/* binding */ maxUint176),\n/* harmony export */   maxUint184: () => (/* binding */ maxUint184),\n/* harmony export */   maxUint192: () => (/* binding */ maxUint192),\n/* harmony export */   maxUint200: () => (/* binding */ maxUint200),\n/* harmony export */   maxUint208: () => (/* binding */ maxUint208),\n/* harmony export */   maxUint216: () => (/* binding */ maxUint216),\n/* harmony export */   maxUint224: () => (/* binding */ maxUint224),\n/* harmony export */   maxUint232: () => (/* binding */ maxUint232),\n/* harmony export */   maxUint24: () => (/* binding */ maxUint24),\n/* harmony export */   maxUint240: () => (/* binding */ maxUint240),\n/* harmony export */   maxUint248: () => (/* binding */ maxUint248),\n/* harmony export */   maxUint256: () => (/* binding */ maxUint256),\n/* harmony export */   maxUint32: () => (/* binding */ maxUint32),\n/* harmony export */   maxUint40: () => (/* binding */ maxUint40),\n/* harmony export */   maxUint48: () => (/* binding */ maxUint48),\n/* harmony export */   maxUint56: () => (/* binding */ maxUint56),\n/* harmony export */   maxUint64: () => (/* binding */ maxUint64),\n/* harmony export */   maxUint72: () => (/* binding */ maxUint72),\n/* harmony export */   maxUint8: () => (/* binding */ maxUint8),\n/* harmony export */   maxUint80: () => (/* binding */ maxUint80),\n/* harmony export */   maxUint88: () => (/* binding */ maxUint88),\n/* harmony export */   maxUint96: () => (/* binding */ maxUint96),\n/* harmony export */   minInt104: () => (/* binding */ minInt104),\n/* harmony export */   minInt112: () => (/* binding */ minInt112),\n/* harmony export */   minInt120: () => (/* binding */ minInt120),\n/* harmony export */   minInt128: () => (/* binding */ minInt128),\n/* harmony export */   minInt136: () => (/* binding */ minInt136),\n/* harmony export */   minInt144: () => (/* binding */ minInt144),\n/* harmony export */   minInt152: () => (/* binding */ minInt152),\n/* harmony export */   minInt16: () => (/* binding */ minInt16),\n/* harmony export */   minInt160: () => (/* binding */ minInt160),\n/* harmony export */   minInt168: () => (/* binding */ minInt168),\n/* harmony export */   minInt176: () => (/* binding */ minInt176),\n/* harmony export */   minInt184: () => (/* binding */ minInt184),\n/* harmony export */   minInt192: () => (/* binding */ minInt192),\n/* harmony export */   minInt200: () => (/* binding */ minInt200),\n/* harmony export */   minInt208: () => (/* binding */ minInt208),\n/* harmony export */   minInt216: () => (/* binding */ minInt216),\n/* harmony export */   minInt224: () => (/* binding */ minInt224),\n/* harmony export */   minInt232: () => (/* binding */ minInt232),\n/* harmony export */   minInt24: () => (/* binding */ minInt24),\n/* harmony export */   minInt240: () => (/* binding */ minInt240),\n/* harmony export */   minInt248: () => (/* binding */ minInt248),\n/* harmony export */   minInt256: () => (/* binding */ minInt256),\n/* harmony export */   minInt32: () => (/* binding */ minInt32),\n/* harmony export */   minInt40: () => (/* binding */ minInt40),\n/* harmony export */   minInt48: () => (/* binding */ minInt48),\n/* harmony export */   minInt56: () => (/* binding */ minInt56),\n/* harmony export */   minInt64: () => (/* binding */ minInt64),\n/* harmony export */   minInt72: () => (/* binding */ minInt72),\n/* harmony export */   minInt8: () => (/* binding */ minInt8),\n/* harmony export */   minInt80: () => (/* binding */ minInt80),\n/* harmony export */   minInt88: () => (/* binding */ minInt88),\n/* harmony export */   minInt96: () => (/* binding */ minInt96)\n/* harmony export */ });\nconst arrayRegex = /^(.*)\\[([0-9]*)\\]$/;\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nconst bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nconst integerRegex = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;\nconst maxInt8 = 2n ** (8n - 1n) - 1n;\nconst maxInt16 = 2n ** (16n - 1n) - 1n;\nconst maxInt24 = 2n ** (24n - 1n) - 1n;\nconst maxInt32 = 2n ** (32n - 1n) - 1n;\nconst maxInt40 = 2n ** (40n - 1n) - 1n;\nconst maxInt48 = 2n ** (48n - 1n) - 1n;\nconst maxInt56 = 2n ** (56n - 1n) - 1n;\nconst maxInt64 = 2n ** (64n - 1n) - 1n;\nconst maxInt72 = 2n ** (72n - 1n) - 1n;\nconst maxInt80 = 2n ** (80n - 1n) - 1n;\nconst maxInt88 = 2n ** (88n - 1n) - 1n;\nconst maxInt96 = 2n ** (96n - 1n) - 1n;\nconst maxInt104 = 2n ** (104n - 1n) - 1n;\nconst maxInt112 = 2n ** (112n - 1n) - 1n;\nconst maxInt120 = 2n ** (120n - 1n) - 1n;\nconst maxInt128 = 2n ** (128n - 1n) - 1n;\nconst maxInt136 = 2n ** (136n - 1n) - 1n;\nconst maxInt144 = 2n ** (144n - 1n) - 1n;\nconst maxInt152 = 2n ** (152n - 1n) - 1n;\nconst maxInt160 = 2n ** (160n - 1n) - 1n;\nconst maxInt168 = 2n ** (168n - 1n) - 1n;\nconst maxInt176 = 2n ** (176n - 1n) - 1n;\nconst maxInt184 = 2n ** (184n - 1n) - 1n;\nconst maxInt192 = 2n ** (192n - 1n) - 1n;\nconst maxInt200 = 2n ** (200n - 1n) - 1n;\nconst maxInt208 = 2n ** (208n - 1n) - 1n;\nconst maxInt216 = 2n ** (216n - 1n) - 1n;\nconst maxInt224 = 2n ** (224n - 1n) - 1n;\nconst maxInt232 = 2n ** (232n - 1n) - 1n;\nconst maxInt240 = 2n ** (240n - 1n) - 1n;\nconst maxInt248 = 2n ** (248n - 1n) - 1n;\nconst maxInt256 = 2n ** (256n - 1n) - 1n;\nconst minInt8 = -(2n ** (8n - 1n));\nconst minInt16 = -(2n ** (16n - 1n));\nconst minInt24 = -(2n ** (24n - 1n));\nconst minInt32 = -(2n ** (32n - 1n));\nconst minInt40 = -(2n ** (40n - 1n));\nconst minInt48 = -(2n ** (48n - 1n));\nconst minInt56 = -(2n ** (56n - 1n));\nconst minInt64 = -(2n ** (64n - 1n));\nconst minInt72 = -(2n ** (72n - 1n));\nconst minInt80 = -(2n ** (80n - 1n));\nconst minInt88 = -(2n ** (88n - 1n));\nconst minInt96 = -(2n ** (96n - 1n));\nconst minInt104 = -(2n ** (104n - 1n));\nconst minInt112 = -(2n ** (112n - 1n));\nconst minInt120 = -(2n ** (120n - 1n));\nconst minInt128 = -(2n ** (128n - 1n));\nconst minInt136 = -(2n ** (136n - 1n));\nconst minInt144 = -(2n ** (144n - 1n));\nconst minInt152 = -(2n ** (152n - 1n));\nconst minInt160 = -(2n ** (160n - 1n));\nconst minInt168 = -(2n ** (168n - 1n));\nconst minInt176 = -(2n ** (176n - 1n));\nconst minInt184 = -(2n ** (184n - 1n));\nconst minInt192 = -(2n ** (192n - 1n));\nconst minInt200 = -(2n ** (200n - 1n));\nconst minInt208 = -(2n ** (208n - 1n));\nconst minInt216 = -(2n ** (216n - 1n));\nconst minInt224 = -(2n ** (224n - 1n));\nconst minInt232 = -(2n ** (232n - 1n));\nconst minInt240 = -(2n ** (240n - 1n));\nconst minInt248 = -(2n ** (248n - 1n));\nconst minInt256 = -(2n ** (256n - 1n));\nconst maxUint8 = 2n ** 8n - 1n;\nconst maxUint16 = 2n ** 16n - 1n;\nconst maxUint24 = 2n ** 24n - 1n;\nconst maxUint32 = 2n ** 32n - 1n;\nconst maxUint40 = 2n ** 40n - 1n;\nconst maxUint48 = 2n ** 48n - 1n;\nconst maxUint56 = 2n ** 56n - 1n;\nconst maxUint64 = 2n ** 64n - 1n;\nconst maxUint72 = 2n ** 72n - 1n;\nconst maxUint80 = 2n ** 80n - 1n;\nconst maxUint88 = 2n ** 88n - 1n;\nconst maxUint96 = 2n ** 96n - 1n;\nconst maxUint104 = 2n ** 104n - 1n;\nconst maxUint112 = 2n ** 112n - 1n;\nconst maxUint120 = 2n ** 120n - 1n;\nconst maxUint128 = 2n ** 128n - 1n;\nconst maxUint136 = 2n ** 136n - 1n;\nconst maxUint144 = 2n ** 144n - 1n;\nconst maxUint152 = 2n ** 152n - 1n;\nconst maxUint160 = 2n ** 160n - 1n;\nconst maxUint168 = 2n ** 168n - 1n;\nconst maxUint176 = 2n ** 176n - 1n;\nconst maxUint184 = 2n ** 184n - 1n;\nconst maxUint192 = 2n ** 192n - 1n;\nconst maxUint200 = 2n ** 200n - 1n;\nconst maxUint208 = 2n ** 208n - 1n;\nconst maxUint216 = 2n ** 216n - 1n;\nconst maxUint224 = 2n ** 224n - 1n;\nconst maxUint232 = 2n ** 232n - 1n;\nconst maxUint240 = 2n ** 240n - 1n;\nconst maxUint248 = 2n ** 248n - 1n;\nconst maxUint256 = 2n ** 256n - 1n;\n//# sourceMappingURL=Solidity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9Tb2xpZGl0eS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxTb2xpZGl0eS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgYXJyYXlSZWdleCA9IC9eKC4qKVxcWyhbMC05XSopXFxdJC87XG4vLyBgYnl0ZXM8TT5gOiBiaW5hcnkgdHlwZSBvZiBgTWAgYnl0ZXMsIGAwIDwgTSA8PSAzMmBcbi8vIGh0dHBzOi8vcmVnZXhyLmNvbS82dmE1NVxuZXhwb3J0IGNvbnN0IGJ5dGVzUmVnZXggPSAvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLztcbi8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG5leHBvcnQgY29uc3QgaW50ZWdlclJlZ2V4ID0gL14odT9pbnQpKDh8MTZ8MjR8MzJ8NDB8NDh8NTZ8NjR8NzJ8ODB8ODh8OTZ8MTA0fDExMnwxMjB8MTI4fDEzNnwxNDR8MTUyfDE2MHwxNjh8MTc2fDE4NHwxOTJ8MjAwfDIwOHwyMTZ8MjI0fDIzMnwyNDB8MjQ4fDI1Nik/JC87XG5leHBvcnQgY29uc3QgbWF4SW50OCA9IDJuICoqICg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE2ID0gMm4gKiogKDE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0ID0gMm4gKiogKDI0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDMyID0gMm4gKiogKDMybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQwID0gMm4gKiogKDQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDQ4ID0gMm4gKiogKDQ4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDU2ID0gMm4gKiogKDU2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDY0ID0gMm4gKiogKDY0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDcyID0gMm4gKiogKDcybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDgwID0gMm4gKiogKDgwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDg4ID0gMm4gKiogKDg4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDk2ID0gMm4gKiogKDk2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEwNCA9IDJuICoqICgxMDRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTEyID0gMm4gKiogKDExMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxMjAgPSAybiAqKiAoMTIwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDEyOCA9IDJuICoqICgxMjhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTM2ID0gMm4gKiogKDEzNm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNDQgPSAybiAqKiAoMTQ0biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE1MiA9IDJuICoqICgxNTJuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTYwID0gMm4gKiogKDE2MG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxNjggPSAybiAqKiAoMTY4biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDE3NiA9IDJuICoqICgxNzZuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MTg0ID0gMm4gKiogKDE4NG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQxOTIgPSAybiAqKiAoMTkybiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIwMCA9IDJuICoqICgyMDBuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjA4ID0gMm4gKiogKDIwOG4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyMTYgPSAybiAqKiAoMjE2biAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDIyNCA9IDJuICoqICgyMjRuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjMyID0gMm4gKiogKDIzMm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhJbnQyNDAgPSAybiAqKiAoMjQwbiAtIDFuKSAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heEludDI0OCA9IDJuICoqICgyNDhuIC0gMW4pIC0gMW47XG5leHBvcnQgY29uc3QgbWF4SW50MjU2ID0gMm4gKiogKDI1Nm4gLSAxbikgLSAxbjtcbmV4cG9ydCBjb25zdCBtaW5JbnQ4ID0gLSgybiAqKiAoOG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDE2ID0gLSgybiAqKiAoMTZuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQyNCA9IC0oMm4gKiogKDI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MzIgPSAtKDJuICoqICgzMm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDQwID0gLSgybiAqKiAoNDBuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ0OCA9IC0oMm4gKiogKDQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50NTYgPSAtKDJuICoqICg1Nm4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDY0ID0gLSgybiAqKiAoNjRuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ3MiA9IC0oMm4gKiogKDcybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50ODAgPSAtKDJuICoqICg4MG4gLSAxbikpO1xuZXhwb3J0IGNvbnN0IG1pbkludDg4ID0gLSgybiAqKiAoODhuIC0gMW4pKTtcbmV4cG9ydCBjb25zdCBtaW5JbnQ5NiA9IC0oMm4gKiogKDk2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTA0ID0gLSgybiAqKiAoMTA0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTEyID0gLSgybiAqKiAoMTEybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTIwID0gLSgybiAqKiAoMTIwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTI4ID0gLSgybiAqKiAoMTI4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTM2ID0gLSgybiAqKiAoMTM2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTQ0ID0gLSgybiAqKiAoMTQ0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTUyID0gLSgybiAqKiAoMTUybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTYwID0gLSgybiAqKiAoMTYwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTY4ID0gLSgybiAqKiAoMTY4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTc2ID0gLSgybiAqKiAoMTc2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTg0ID0gLSgybiAqKiAoMTg0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MTkyID0gLSgybiAqKiAoMTkybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjAwID0gLSgybiAqKiAoMjAwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjA4ID0gLSgybiAqKiAoMjA4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjE2ID0gLSgybiAqKiAoMjE2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjI0ID0gLSgybiAqKiAoMjI0biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjMyID0gLSgybiAqKiAoMjMybiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQwID0gLSgybiAqKiAoMjQwbiAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjQ4ID0gLSgybiAqKiAoMjQ4biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWluSW50MjU2ID0gLSgybiAqKiAoMjU2biAtIDFuKSk7XG5leHBvcnQgY29uc3QgbWF4VWludDggPSAybiAqKiA4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNiA9IDJuICoqIDE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNCA9IDJuICoqIDI0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQzMiA9IDJuICoqIDMybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0MCA9IDJuICoqIDQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ0OCA9IDJuICoqIDQ4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ1NiA9IDJuICoqIDU2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ2NCA9IDJuICoqIDY0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ3MiA9IDJuICoqIDcybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4MCA9IDJuICoqIDgwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ4OCA9IDJuICoqIDg4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQ5NiA9IDJuICoqIDk2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMDQgPSAybiAqKiAxMDRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDExMiA9IDJuICoqIDExMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTIwID0gMm4gKiogMTIwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxMjggPSAybiAqKiAxMjhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDEzNiA9IDJuICoqIDEzNm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTQ0ID0gMm4gKiogMTQ0biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNTIgPSAybiAqKiAxNTJuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE2MCA9IDJuICoqIDE2MG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTY4ID0gMm4gKiogMTY4biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQxNzYgPSAybiAqKiAxNzZuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDE4NCA9IDJuICoqIDE4NG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MTkyID0gMm4gKiogMTkybiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMDAgPSAybiAqKiAyMDBuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIwOCA9IDJuICoqIDIwOG4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjE2ID0gMm4gKiogMjE2biAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyMjQgPSAybiAqKiAyMjRuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDIzMiA9IDJuICoqIDIzMm4gLSAxbjtcbmV4cG9ydCBjb25zdCBtYXhVaW50MjQwID0gMm4gKiogMjQwbiAtIDFuO1xuZXhwb3J0IGNvbnN0IG1heFVpbnQyNDggPSAybiAqKiAyNDhuIC0gMW47XG5leHBvcnQgY29uc3QgbWF4VWludDI1NiA9IDJuICoqIDI1Nm4gLSAxbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNvbGlkaXR5LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Solidity.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/Withdrawal.js":
/*!*****************************************************!*\
  !*** ../../node_modules/ox/_esm/core/Withdrawal.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   toRpc: () => (/* binding */ toRpc)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n/**\n * Converts a {@link ox#Withdrawal.Rpc} to an {@link ox#Withdrawal.Withdrawal}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.fromRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: '0x620323',\n *   index: '0x0',\n *   validatorIndex: '0x1',\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: 6423331n,\n * // @log:   index: 0,\n * // @log:   validatorIndex: 1\n * // @log: }\n * ```\n *\n * @param withdrawal - The RPC withdrawal to convert.\n * @returns An instantiated {@link ox#Withdrawal.Withdrawal}.\n */\nfunction fromRpc(withdrawal) {\n    return {\n        ...withdrawal,\n        amount: BigInt(withdrawal.amount),\n        index: Number(withdrawal.index),\n        validatorIndex: Number(withdrawal.validatorIndex),\n    };\n}\n/**\n * Converts a {@link ox#Withdrawal.Withdrawal} to an {@link ox#Withdrawal.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Withdrawal } from 'ox'\n *\n * const withdrawal = Withdrawal.toRpc({\n *   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n *   amount: 6423331n,\n *   index: 0,\n *   validatorIndex: 1,\n * })\n * // @log: {\n * // @log:   address: '0x00000000219ab540356cBB839Cbe05303d7705Fa',\n * // @log:   amount: '0x620323',\n * // @log:   index: '0x0',\n * // @log:   validatorIndex: '0x1',\n * // @log: }\n * ```\n *\n * @param withdrawal - The Withdrawal to convert.\n * @returns An RPC Withdrawal.\n */\nfunction toRpc(withdrawal) {\n    return {\n        address: withdrawal.address,\n        amount: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.amount),\n        index: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.index),\n        validatorIndex: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromNumber(withdrawal.validatorIndex),\n    };\n}\n//# sourceMappingURL=Withdrawal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9XaXRoZHJhd2FsLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnQztBQUNoQztBQUNBLGVBQWUseUJBQXlCLE9BQU8sK0JBQStCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLCtCQUErQjtBQUM1RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0NBQWdDLE9BQU8sd0JBQXdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBYztBQUM5QixlQUFlLCtDQUFjO0FBQzdCLHdCQUF3QiwrQ0FBYztBQUN0QztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXFdpdGhkcmF3YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9IHRvIGFuIHtAbGluayBveCNXaXRoZHJhd2FsLldpdGhkcmF3YWx9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLmZyb21ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDIxOWFiNTQwMzU2Y0JCODM5Q2JlMDUzMDNkNzcwNUZhJyxcbiAqICAgYW1vdW50OiAnMHg2MjAzMjMnLFxuICogICBpbmRleDogJzB4MCcsXG4gKiAgIHZhbGlkYXRvckluZGV4OiAnMHgxJyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6IDY0MjMzMzFuLFxuICogLy8gQGxvZzogICBpbmRleDogMCxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB3aXRoZHJhd2FsIC0gVGhlIFJQQyB3aXRoZHJhd2FsIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1dpdGhkcmF3YWwuV2l0aGRyYXdhbH0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKHdpdGhkcmF3YWwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi53aXRoZHJhd2FsLFxuICAgICAgICBhbW91bnQ6IEJpZ0ludCh3aXRoZHJhd2FsLmFtb3VudCksXG4gICAgICAgIGluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC5pbmRleCksXG4gICAgICAgIHZhbGlkYXRvckluZGV4OiBOdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjV2l0aGRyYXdhbC5XaXRoZHJhd2FsfSB0byBhbiB7QGxpbmsgb3gjV2l0aGRyYXdhbC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgV2l0aGRyYXdhbCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHdpdGhkcmF3YWwgPSBXaXRoZHJhd2FsLnRvUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAyMTlhYjU0MDM1NmNCQjgzOUNiZTA1MzAzZDc3MDVGYScsXG4gKiAgIGFtb3VudDogNjQyMzMzMW4sXG4gKiAgIGluZGV4OiAwLFxuICogICB2YWxpZGF0b3JJbmRleDogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGFkZHJlc3M6ICcweDAwMDAwMDAwMjE5YWI1NDAzNTZjQkI4MzlDYmUwNTMwM2Q3NzA1RmEnLFxuICogLy8gQGxvZzogICBhbW91bnQ6ICcweDYyMDMyMycsXG4gKiAvLyBAbG9nOiAgIGluZGV4OiAnMHgwJyxcbiAqIC8vIEBsb2c6ICAgdmFsaWRhdG9ySW5kZXg6ICcweDEnLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHdpdGhkcmF3YWwgLSBUaGUgV2l0aGRyYXdhbCB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQW4gUlBDIFdpdGhkcmF3YWwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyh3aXRoZHJhd2FsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkcmVzczogd2l0aGRyYXdhbC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuYW1vdW50KSxcbiAgICAgICAgaW5kZXg6IEhleC5mcm9tTnVtYmVyKHdpdGhkcmF3YWwuaW5kZXgpLFxuICAgICAgICB2YWxpZGF0b3JJbmRleDogSGV4LmZyb21OdW1iZXIod2l0aGRyYXdhbC52YWxpZGF0b3JJbmRleCksXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdpdGhkcmF3YWwuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/Withdrawal.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/abiItem.js":
/*!***********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/abiItem.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAmbiguousTypes: () => (/* binding */ getAmbiguousTypes),\n/* harmony export */   isArgOfType: () => (/* binding */ isArgOfType),\n/* harmony export */   normalizeSignature: () => (/* binding */ normalizeSignature)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/../../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n\n\n/** @internal */\nfunction normalizeSignature(signature) {\n    let active = true;\n    let current = '';\n    let level = 0;\n    let result = '';\n    let valid = false;\n    for (let i = 0; i < signature.length; i++) {\n        const char = signature[i];\n        // If the character is a separator, we want to reactivate.\n        if (['(', ')', ','].includes(char))\n            active = true;\n        // If the character is a \"level\" token, we want to increment/decrement.\n        if (char === '(')\n            level++;\n        if (char === ')')\n            level--;\n        // If we aren't active, we don't want to mutate the result.\n        if (!active)\n            continue;\n        // If level === 0, we are at the definition level.\n        if (level === 0) {\n            if (char === ' ' && ['event', 'function', 'error', ''].includes(result))\n                result = '';\n            else {\n                result += char;\n                // If we are at the end of the definition, we must be finished.\n                if (char === ')') {\n                    valid = true;\n                    break;\n                }\n            }\n            continue;\n        }\n        // Ignore spaces\n        if (char === ' ') {\n            // If the previous character is a separator, and the current section isn't empty, we want to deactivate.\n            if (signature[i - 1] !== ',' && current !== ',' && current !== ',(') {\n                current = '';\n                active = false;\n            }\n            continue;\n        }\n        result += char;\n        current += char;\n    }\n    if (!valid)\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError('Unable to normalize signature.');\n    return result;\n}\n/** @internal */\nfunction isArgOfType(arg, abiParameter) {\n    const argType = typeof arg;\n    const abiParameterType = abiParameter.type;\n    switch (abiParameterType) {\n        case 'address':\n            return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(arg, { strict: false });\n        case 'bool':\n            return argType === 'boolean';\n        case 'function':\n            return argType === 'string';\n        case 'string':\n            return argType === 'string';\n        default: {\n            if (abiParameterType === 'tuple' && 'components' in abiParameter)\n                return Object.values(abiParameter.components).every((component, index) => {\n                    return isArgOfType(Object.values(arg)[index], component);\n                });\n            // `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n            // https://regexr.com/6v8hp\n            if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))\n                return argType === 'number' || argType === 'bigint';\n            // `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n            // https://regexr.com/6va55\n            if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))\n                return argType === 'string' || arg instanceof Uint8Array;\n            // fixed-length (`<type>[M]`) and dynamic (`<type>[]`) arrays\n            // https://regexr.com/6va6i\n            if (/[a-z]+[1-9]{0,3}(\\[[0-9]{0,}\\])+$/.test(abiParameterType)) {\n                return (Array.isArray(arg) &&\n                    arg.every((x) => isArgOfType(x, {\n                        ...abiParameter,\n                        // Pop off `[]` or `[M]` from end of type\n                        type: abiParameterType.replace(/(\\[[0-9]{0,}\\])$/, ''),\n                    })));\n            }\n            return false;\n        }\n    }\n}\n/** @internal */\nfunction getAmbiguousTypes(sourceParameters, targetParameters, args) {\n    for (const parameterIndex in sourceParameters) {\n        const sourceParameter = sourceParameters[parameterIndex];\n        const targetParameter = targetParameters[parameterIndex];\n        if (sourceParameter.type === 'tuple' &&\n            targetParameter.type === 'tuple' &&\n            'components' in sourceParameter &&\n            'components' in targetParameter)\n            return getAmbiguousTypes(sourceParameter.components, targetParameter.components, args[parameterIndex]);\n        const types = [sourceParameter.type, targetParameter.type];\n        const ambiguous = (() => {\n            if (types.includes('address') && types.includes('bytes20'))\n                return true;\n            if (types.includes('address') && types.includes('string'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            if (types.includes('address') && types.includes('bytes'))\n                return _Address_js__WEBPACK_IMPORTED_MODULE_1__.validate(args[parameterIndex], {\n                    strict: false,\n                });\n            return false;\n        })();\n        if (ambiguous)\n            return types;\n    }\n    return;\n}\n//# sourceMappingURL=abiItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlJdGVtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXlDO0FBQ0Y7QUFDdkM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpREFBZ0IsUUFBUSxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLElBQUksU0FBUyxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaURBQWdCO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsdUJBQXVCLGlEQUFnQjtBQUN2QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXGludGVybmFsXFxhYmlJdGVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi4vRXJyb3JzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgbGV0IGFjdGl2ZSA9IHRydWU7XG4gICAgbGV0IGN1cnJlbnQgPSAnJztcbiAgICBsZXQgbGV2ZWwgPSAwO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBsZXQgdmFsaWQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gc2lnbmF0dXJlW2ldO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yLCB3ZSB3YW50IHRvIHJlYWN0aXZhdGUuXG4gICAgICAgIGlmIChbJygnLCAnKScsICcsJ10uaW5jbHVkZXMoY2hhcikpXG4gICAgICAgICAgICBhY3RpdmUgPSB0cnVlO1xuICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgXCJsZXZlbFwiIHRva2VuLCB3ZSB3YW50IHRvIGluY3JlbWVudC9kZWNyZW1lbnQuXG4gICAgICAgIGlmIChjaGFyID09PSAnKCcpXG4gICAgICAgICAgICBsZXZlbCsrO1xuICAgICAgICBpZiAoY2hhciA9PT0gJyknKVxuICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IGFjdGl2ZSwgd2UgZG9uJ3Qgd2FudCB0byBtdXRhdGUgdGhlIHJlc3VsdC5cbiAgICAgICAgaWYgKCFhY3RpdmUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSWYgbGV2ZWwgPT09IDAsIHdlIGFyZSBhdCB0aGUgZGVmaW5pdGlvbiBsZXZlbC5cbiAgICAgICAgaWYgKGxldmVsID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJyAnICYmIFsnZXZlbnQnLCAnZnVuY3Rpb24nLCAnZXJyb3InLCAnJ10uaW5jbHVkZXMocmVzdWx0KSlcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnJztcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBjaGFyO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhdCB0aGUgZW5kIG9mIHRoZSBkZWZpbml0aW9uLCB3ZSBtdXN0IGJlIGZpbmlzaGVkLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZ25vcmUgc3BhY2VzXG4gICAgICAgIGlmIChjaGFyID09PSAnICcpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXMgYSBzZXBhcmF0b3IsIGFuZCB0aGUgY3VycmVudCBzZWN0aW9uIGlzbid0IGVtcHR5LCB3ZSB3YW50IHRvIGRlYWN0aXZhdGUuXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlW2kgLSAxXSAhPT0gJywnICYmIGN1cnJlbnQgIT09ICcsJyAmJiBjdXJyZW50ICE9PSAnLCgnKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9ICcnO1xuICAgICAgICAgICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGNoYXI7XG4gICAgICAgIGN1cnJlbnQgKz0gY2hhcjtcbiAgICB9XG4gICAgaWYgKCF2YWxpZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ1VuYWJsZSB0byBub3JtYWxpemUgc2lnbmF0dXJlLicpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gaXNBcmdPZlR5cGUoYXJnLCBhYmlQYXJhbWV0ZXIpIHtcbiAgICBjb25zdCBhcmdUeXBlID0gdHlwZW9mIGFyZztcbiAgICBjb25zdCBhYmlQYXJhbWV0ZXJUeXBlID0gYWJpUGFyYW1ldGVyLnR5cGU7XG4gICAgc3dpdGNoIChhYmlQYXJhbWV0ZXJUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgICAgICAgcmV0dXJuIEFkZHJlc3MudmFsaWRhdGUoYXJnLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGNhc2UgJ2Jvb2wnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdib29sZWFuJztcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdzdHJpbmcnO1xuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBpZiAoYWJpUGFyYW1ldGVyVHlwZSA9PT0gJ3R1cGxlJyAmJiAnY29tcG9uZW50cycgaW4gYWJpUGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKGFiaVBhcmFtZXRlci5jb21wb25lbnRzKS5ldmVyeSgoY29tcG9uZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNBcmdPZlR5cGUoT2JqZWN0LnZhbHVlcyhhcmcpW2luZGV4XSwgY29tcG9uZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGAodSlpbnQ8TT5gOiAodW4pc2lnbmVkIGludGVnZXIgdHlwZSBvZiBgTWAgYml0cywgYDAgPCBNIDw9IDI1NmAsIGBNICUgOCA9PSAwYFxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2OGhwXG4gICAgICAgICAgICBpZiAoL151P2ludCg4fDE2fDI0fDMyfDQwfDQ4fDU2fDY0fDcyfDgwfDg4fDk2fDEwNHwxMTJ8MTIwfDEyOHwxMzZ8MTQ0fDE1MnwxNjB8MTY4fDE3NnwxODR8MTkyfDIwMHwyMDh8MjE2fDIyNHwyMzJ8MjQwfDI0OHwyNTYpPyQvLnRlc3QoYWJpUGFyYW1ldGVyVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ1R5cGUgPT09ICdudW1iZXInIHx8IGFyZ1R5cGUgPT09ICdiaWdpbnQnO1xuICAgICAgICAgICAgLy8gYGJ5dGVzPE0+YDogYmluYXJ5IHR5cGUgb2YgYE1gIGJ5dGVzLCBgMCA8IE0gPD0gMzJgXG4gICAgICAgICAgICAvLyBodHRwczovL3JlZ2V4ci5jb20vNnZhNTVcbiAgICAgICAgICAgIGlmICgvXmJ5dGVzKFsxLTldfDFbMC05XXwyWzAtOV18M1swLTJdKT8kLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmcgaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICAgICAgLy8gZml4ZWQtbGVuZ3RoIChgPHR5cGU+W01dYCkgYW5kIGR5bmFtaWMgKGA8dHlwZT5bXWApIGFycmF5c1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9yZWdleHIuY29tLzZ2YTZpXG4gICAgICAgICAgICBpZiAoL1thLXpdK1sxLTldezAsM30oXFxbWzAtOV17MCx9XFxdKSskLy50ZXN0KGFiaVBhcmFtZXRlclR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KGFyZykgJiZcbiAgICAgICAgICAgICAgICAgICAgYXJnLmV2ZXJ5KCh4KSA9PiBpc0FyZ09mVHlwZSh4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hYmlQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3Agb2ZmIGBbXWAgb3IgYFtNXWAgZnJvbSBlbmQgb2YgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogYWJpUGFyYW1ldGVyVHlwZS5yZXBsYWNlKC8oXFxbWzAtOV17MCx9XFxdKSQvLCAnJyksXG4gICAgICAgICAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVycywgdGFyZ2V0UGFyYW1ldGVycywgYXJncykge1xuICAgIGZvciAoY29uc3QgcGFyYW1ldGVySW5kZXggaW4gc291cmNlUGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBzb3VyY2VQYXJhbWV0ZXIgPSBzb3VyY2VQYXJhbWV0ZXJzW3BhcmFtZXRlckluZGV4XTtcbiAgICAgICAgY29uc3QgdGFyZ2V0UGFyYW1ldGVyID0gdGFyZ2V0UGFyYW1ldGVyc1twYXJhbWV0ZXJJbmRleF07XG4gICAgICAgIGlmIChzb3VyY2VQYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJyAmJlxuICAgICAgICAgICAgdGFyZ2V0UGFyYW1ldGVyLnR5cGUgPT09ICd0dXBsZScgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiBzb3VyY2VQYXJhbWV0ZXIgJiZcbiAgICAgICAgICAgICdjb21wb25lbnRzJyBpbiB0YXJnZXRQYXJhbWV0ZXIpXG4gICAgICAgICAgICByZXR1cm4gZ2V0QW1iaWd1b3VzVHlwZXMoc291cmNlUGFyYW1ldGVyLmNvbXBvbmVudHMsIHRhcmdldFBhcmFtZXRlci5jb21wb25lbnRzLCBhcmdzW3BhcmFtZXRlckluZGV4XSk7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW3NvdXJjZVBhcmFtZXRlci50eXBlLCB0YXJnZXRQYXJhbWV0ZXIudHlwZV07XG4gICAgICAgIGNvbnN0IGFtYmlndW91cyA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMyMCcpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCdhZGRyZXNzJykgJiYgdHlwZXMuaW5jbHVkZXMoJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHJldHVybiBBZGRyZXNzLnZhbGlkYXRlKGFyZ3NbcGFyYW1ldGVySW5kZXhdLCB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJ2FkZHJlc3MnKSAmJiB0eXBlcy5pbmNsdWRlcygnYnl0ZXMnKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gQWRkcmVzcy52YWxpZGF0ZShhcmdzW3BhcmFtZXRlckluZGV4XSwge1xuICAgICAgICAgICAgICAgICAgICBzdHJpY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAoYW1iaWd1b3VzKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cbiAgICByZXR1cm47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmlJdGVtLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/abiItem.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/abiParameters.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/abiParameters.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeAddress: () => (/* binding */ decodeAddress),\n/* harmony export */   decodeArray: () => (/* binding */ decodeArray),\n/* harmony export */   decodeBool: () => (/* binding */ decodeBool),\n/* harmony export */   decodeBytes: () => (/* binding */ decodeBytes),\n/* harmony export */   decodeNumber: () => (/* binding */ decodeNumber),\n/* harmony export */   decodeParameter: () => (/* binding */ decodeParameter),\n/* harmony export */   decodeString: () => (/* binding */ decodeString),\n/* harmony export */   decodeTuple: () => (/* binding */ decodeTuple),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeAddress: () => (/* binding */ encodeAddress),\n/* harmony export */   encodeArray: () => (/* binding */ encodeArray),\n/* harmony export */   encodeBoolean: () => (/* binding */ encodeBoolean),\n/* harmony export */   encodeBytes: () => (/* binding */ encodeBytes),\n/* harmony export */   encodeNumber: () => (/* binding */ encodeNumber),\n/* harmony export */   encodeString: () => (/* binding */ encodeString),\n/* harmony export */   encodeTuple: () => (/* binding */ encodeTuple),\n/* harmony export */   getArrayComponents: () => (/* binding */ getArrayComponents),\n/* harmony export */   hasDynamicChild: () => (/* binding */ hasDynamicChild),\n/* harmony export */   prepareParameter: () => (/* binding */ prepareParameter),\n/* harmony export */   prepareParameters: () => (/* binding */ prepareParameters)\n/* harmony export */ });\n/* harmony import */ var _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../AbiParameters.js */ \"(ssr)/../../node_modules/ox/_esm/core/AbiParameters.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Address.js */ \"(ssr)/../../node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Solidity.js */ \"(ssr)/../../node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/** @internal */\nfunction decodeParameter(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return decodeArray(cursor, { ...param, type }, { checksumAddress, length, staticPosition });\n    }\n    if (param.type === 'tuple')\n        return decodeTuple(cursor, param, {\n            checksumAddress,\n            staticPosition,\n        });\n    if (param.type === 'address')\n        return decodeAddress(cursor, { checksum: checksumAddress });\n    if (param.type === 'bool')\n        return decodeBool(cursor);\n    if (param.type.startsWith('bytes'))\n        return decodeBytes(cursor, param, { staticPosition });\n    if (param.type.startsWith('uint') || param.type.startsWith('int'))\n        return decodeNumber(cursor, param);\n    if (param.type === 'string')\n        return decodeString(cursor, { staticPosition });\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(param.type);\n}\nconst sizeOfLength = 32;\nconst sizeOfOffset = 32;\n/** @internal */\nfunction decodeAddress(cursor, options = {}) {\n    const { checksum = false } = options;\n    const value = cursor.readBytes(32);\n    const wrap = (address) => checksum ? _Address_js__WEBPACK_IMPORTED_MODULE_1__.checksum(address) : address;\n    return [wrap(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.slice(value, -20))), 32];\n}\n/** @internal */\nfunction decodeArray(cursor, param, options) {\n    const { checksumAddress, length, staticPosition } = options;\n    // If the length of the array is not known in advance (dynamic array),\n    // this means we will need to wonder off to the pointer and decode.\n    if (!length) {\n        // Dealing with a dynamic type, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const startOfData = start + sizeOfLength;\n        // Get the length of the array from the offset.\n        cursor.setPosition(start);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfLength));\n        // Check if the array has any dynamic children.\n        const dynamicChild = hasDynamicChild(param);\n        let consumed = 0;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // If any of the children is dynamic, then all elements will be offset pointer, thus size of one slot (32 bytes).\n            // Otherwise, elements will be the size of their encoding (consumed bytes).\n            cursor.setPosition(startOfData + (dynamicChild ? i * 32 : consumed));\n            const [data, consumed_] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: startOfData,\n            });\n            consumed += consumed_;\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance,\n    // and the length of an element deeply nested in the array is not known,\n    // we need to decode the offset of the array data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the array data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of current slot + offset.\n        const start = staticPosition + offset;\n        const value = [];\n        for (let i = 0; i < length; ++i) {\n            // Move cursor along to the next slot (next offset pointer).\n            cursor.setPosition(start + i * 32);\n            const [data] = decodeParameter(cursor, param, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            value.push(data);\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the length of the array is known in advance and the array is deeply static,\n    // then we can just decode each element in sequence.\n    let consumed = 0;\n    const value = [];\n    for (let i = 0; i < length; ++i) {\n        const [data, consumed_] = decodeParameter(cursor, param, {\n            checksumAddress,\n            staticPosition: staticPosition + consumed,\n        });\n        consumed += consumed_;\n        value.push(data);\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeBool(cursor) {\n    return [_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBoolean(cursor.readBytes(32), { size: 32 }), 32];\n}\n/** @internal */\nfunction decodeBytes(cursor, param, { staticPosition }) {\n    const [_, size] = param.type.split('bytes');\n    if (!size) {\n        // Dealing with dynamic types, so get the offset of the bytes data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // Set position of the cursor to start of bytes data.\n        cursor.setPosition(staticPosition + offset);\n        const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n        // If there is no length, we have zero data.\n        if (length === 0) {\n            // As we have gone wondering, restore to the original position + next slot.\n            cursor.setPosition(staticPosition + 32);\n            return ['0x', 32];\n        }\n        const data = cursor.readBytes(length);\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(data), 32];\n    }\n    const value = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBytes(cursor.readBytes(Number.parseInt(size), 32));\n    return [value, 32];\n}\n/** @internal */\nfunction decodeNumber(cursor, param) {\n    const signed = param.type.startsWith('int');\n    const size = Number.parseInt(param.type.split('int')[1] || '256');\n    const value = cursor.readBytes(32);\n    return [\n        size > 48\n            ? _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toBigInt(value, { signed })\n            : _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(value, { signed }),\n        32,\n    ];\n}\n/** @internal */\nfunction decodeTuple(cursor, param, options) {\n    const { checksumAddress, staticPosition } = options;\n    // Tuples can have unnamed components (i.e. they are arrays), so we must\n    // determine whether the tuple is named or unnamed. In the case of a named\n    // tuple, the value will be an object where each property is the name of the\n    // component. In the case of an unnamed tuple, the value will be an array.\n    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name }) => !name);\n    // Initialize the value to an object or an array, depending on whether the\n    // tuple is named or unnamed.\n    const value = hasUnnamedChild ? [] : {};\n    let consumed = 0;\n    // If the tuple has a dynamic child, we must first decode the offset to the\n    // tuple data.\n    if (hasDynamicChild(param)) {\n        // Dealing with dynamic types, so get the offset of the tuple data.\n        const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(sizeOfOffset));\n        // Start is the static position of referencing slot + offset.\n        const start = staticPosition + offset;\n        for (let i = 0; i < param.components.length; ++i) {\n            const component = param.components[i];\n            cursor.setPosition(start + consumed);\n            const [data, consumed_] = decodeParameter(cursor, component, {\n                checksumAddress,\n                staticPosition: start,\n            });\n            consumed += consumed_;\n            value[hasUnnamedChild ? i : component?.name] = data;\n        }\n        // As we have gone wondering, restore to the original position + next slot.\n        cursor.setPosition(staticPosition + 32);\n        return [value, 32];\n    }\n    // If the tuple has static children, we can just decode each component\n    // in sequence.\n    for (let i = 0; i < param.components.length; ++i) {\n        const component = param.components[i];\n        const [data, consumed_] = decodeParameter(cursor, component, {\n            checksumAddress,\n            staticPosition,\n        });\n        value[hasUnnamedChild ? i : component?.name] = data;\n        consumed += consumed_;\n    }\n    return [value, consumed];\n}\n/** @internal */\nfunction decodeString(cursor, { staticPosition }) {\n    // Get offset to start of string data.\n    const offset = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // Start is the static position of current slot + offset.\n    const start = staticPosition + offset;\n    cursor.setPosition(start);\n    const length = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toNumber(cursor.readBytes(32));\n    // If there is no length, we have zero data (empty string).\n    if (length === 0) {\n        cursor.setPosition(staticPosition + 32);\n        return ['', 32];\n    }\n    const data = cursor.readBytes(length, 32);\n    const value = _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.toString(_Bytes_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(data));\n    // As we have gone wondering, restore to the original position + next slot.\n    cursor.setPosition(staticPosition + 32);\n    return [value, 32];\n}\n/** @internal */\nfunction prepareParameters({ checksumAddress, parameters, values, }) {\n    const preparedParameters = [];\n    for (let i = 0; i < parameters.length; i++) {\n        preparedParameters.push(prepareParameter({\n            checksumAddress,\n            parameter: parameters[i],\n            value: values[i],\n        }));\n    }\n    return preparedParameters;\n}\n/** @internal */\nfunction prepareParameter({ checksumAddress = false, parameter: parameter_, value, }) {\n    const parameter = parameter_;\n    const arrayComponents = getArrayComponents(parameter.type);\n    if (arrayComponents) {\n        const [length, type] = arrayComponents;\n        return encodeArray(value, {\n            checksumAddress,\n            length,\n            parameter: {\n                ...parameter,\n                type,\n            },\n        });\n    }\n    if (parameter.type === 'tuple') {\n        return encodeTuple(value, {\n            checksumAddress,\n            parameter: parameter,\n        });\n    }\n    if (parameter.type === 'address') {\n        return encodeAddress(value, {\n            checksum: checksumAddress,\n        });\n    }\n    if (parameter.type === 'bool') {\n        return encodeBoolean(value);\n    }\n    if (parameter.type.startsWith('uint') || parameter.type.startsWith('int')) {\n        const signed = parameter.type.startsWith('int');\n        const [, , size = '256'] = _Solidity_js__WEBPACK_IMPORTED_MODULE_4__.integerRegex.exec(parameter.type) ?? [];\n        return encodeNumber(value, {\n            signed,\n            size: Number(size),\n        });\n    }\n    if (parameter.type.startsWith('bytes')) {\n        return encodeBytes(value, { type: parameter.type });\n    }\n    if (parameter.type === 'string') {\n        return encodeString(value);\n    }\n    throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidTypeError(parameter.type);\n}\n/** @internal */\nfunction encode(preparedParameters) {\n    // 1. Compute the size of the static part of the parameters.\n    let staticSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic)\n            staticSize += 32;\n        else\n            staticSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n    }\n    // 2. Split the parameters into static and dynamic parts.\n    const staticParameters = [];\n    const dynamicParameters = [];\n    let dynamicSize = 0;\n    for (let i = 0; i < preparedParameters.length; i++) {\n        const { dynamic, encoded } = preparedParameters[i];\n        if (dynamic) {\n            staticParameters.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(staticSize + dynamicSize, { size: 32 }));\n            dynamicParameters.push(encoded);\n            dynamicSize += _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(encoded);\n        }\n        else {\n            staticParameters.push(encoded);\n        }\n    }\n    // 3. Concatenate static and dynamic parts.\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...staticParameters, ...dynamicParameters);\n}\n/** @internal */\nfunction encodeAddress(value, options) {\n    const { checksum = false } = options;\n    _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(value, { strict: checksum });\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(value.toLowerCase()),\n    };\n}\n/** @internal */\nfunction encodeArray(value, options) {\n    const { checksumAddress, length, parameter } = options;\n    const dynamic = length === null;\n    if (!Array.isArray(value))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.InvalidArrayError(value);\n    if (!dynamic && value.length !== length)\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.ArrayLengthMismatchError({\n            expectedLength: length,\n            givenLength: value.length,\n            type: `${parameter.type}[${length}]`,\n        });\n    let dynamicChild = false;\n    const preparedParameters = [];\n    for (let i = 0; i < value.length; i++) {\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter,\n            value: value[i],\n        });\n        if (preparedParam.dynamic)\n            dynamicChild = true;\n        preparedParameters.push(preparedParam);\n    }\n    if (dynamic || dynamicChild) {\n        const data = encode(preparedParameters);\n        if (dynamic) {\n            const length = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(preparedParameters.length, { size: 32 });\n            return {\n                dynamic: true,\n                encoded: preparedParameters.length > 0 ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(length, data) : length,\n            };\n        }\n        if (dynamicChild)\n            return { dynamic: true, encoded: data };\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction encodeBytes(value, { type }) {\n    const [, parametersize] = type.split('bytes');\n    const bytesSize = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(value);\n    if (!parametersize) {\n        let value_ = value;\n        // If the size is not divisible by 32 bytes, pad the end\n        // with empty bytes to the ceiling 32 bytes.\n        if (bytesSize % 32 !== 0)\n            value_ = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value_, Math.ceil((value.length - 2) / 2 / 32) * 32);\n        return {\n            dynamic: true,\n            encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(bytesSize, { size: 32 })), value_),\n        };\n    }\n    if (bytesSize !== Number.parseInt(parametersize))\n        throw new _AbiParameters_js__WEBPACK_IMPORTED_MODULE_0__.BytesSizeMismatchError({\n            expectedSize: Number.parseInt(parametersize),\n            value,\n        });\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(value) };\n}\n/** @internal */\nfunction encodeBoolean(value) {\n    if (typeof value !== 'boolean')\n        throw new _Errors_js__WEBPACK_IMPORTED_MODULE_5__.BaseError(`Invalid boolean value: \"${value}\" (type: ${typeof value}). Expected: \\`true\\` or \\`false\\`.`);\n    return { dynamic: false, encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.padLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromBoolean(value)) };\n}\n/** @internal */\nfunction encodeNumber(value, { signed, size }) {\n    if (typeof size === 'number') {\n        const max = 2n ** (BigInt(size) - (signed ? 1n : 0n)) - 1n;\n        const min = signed ? -max - 1n : 0n;\n        if (value > max || value < min)\n            throw new _Hex_js__WEBPACK_IMPORTED_MODULE_2__.IntegerOutOfRangeError({\n                max: max.toString(),\n                min: min.toString(),\n                signed,\n                size: size / 8,\n                value: value.toString(),\n            });\n    }\n    return {\n        dynamic: false,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(value, {\n            size: 32,\n            signed,\n        }),\n    };\n}\n/** @internal */\nfunction encodeString(value) {\n    const hexValue = _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromString(value);\n    const partsLength = Math.ceil(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue) / 32);\n    const parts = [];\n    for (let i = 0; i < partsLength; i++) {\n        parts.push(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.slice(hexValue, i * 32, (i + 1) * 32)));\n    }\n    return {\n        dynamic: true,\n        encoded: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.padRight(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(hexValue), { size: 32 })), ...parts),\n    };\n}\n/** @internal */\nfunction encodeTuple(value, options) {\n    const { checksumAddress, parameter } = options;\n    let dynamic = false;\n    const preparedParameters = [];\n    for (let i = 0; i < parameter.components.length; i++) {\n        const param_ = parameter.components[i];\n        const index = Array.isArray(value) ? i : param_.name;\n        const preparedParam = prepareParameter({\n            checksumAddress,\n            parameter: param_,\n            value: value[index],\n        });\n        preparedParameters.push(preparedParam);\n        if (preparedParam.dynamic)\n            dynamic = true;\n    }\n    return {\n        dynamic,\n        encoded: dynamic\n            ? encode(preparedParameters)\n            : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat(...preparedParameters.map(({ encoded }) => encoded)),\n    };\n}\n/** @internal */\nfunction getArrayComponents(type) {\n    const matches = type.match(/^(.*)\\[(\\d+)?\\]$/);\n    return matches\n        ? // Return `null` if the array is dynamic.\n            [matches[2] ? Number(matches[2]) : null, matches[1]]\n        : undefined;\n}\n/** @internal */\nfunction hasDynamicChild(param) {\n    const { type } = param;\n    if (type === 'string')\n        return true;\n    if (type === 'bytes')\n        return true;\n    if (type.endsWith('[]'))\n        return true;\n    if (type === 'tuple')\n        return param.components?.some(hasDynamicChild);\n    const arrayComponents = getArrayComponents(param.type);\n    if (arrayComponents &&\n        hasDynamicChild({\n            ...param,\n            type: arrayComponents[1],\n        }))\n        return true;\n    return false;\n}\n//# sourceMappingURL=abiParameters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9hYmlQYXJhbWV0ZXJzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ1o7QUFDSjtBQUNFO0FBQ047QUFDYTtBQUM5QztBQUNPO0FBQ1AsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQixJQUFJLHlDQUF5QztBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsdUNBQXVDLDJCQUEyQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQsY0FBYywrREFBOEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQ0FBMkM7QUFDbEQsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSx5Q0FBeUMsaURBQWdCO0FBQ3pELGlCQUFpQiw4Q0FBYSxDQUFDLDRDQUFXO0FBQzFDO0FBQ0E7QUFDTztBQUNQLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNo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QUE2QjtBQUN6QztBQUNBO0FBQ0Esb0JBQW9CLGlDQUFpQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkNBQVUsOEJBQThCLFNBQVM7QUFDL0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxpbnRlcm5hbFxcYWJpUGFyYW1ldGVycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBYmlQYXJhbWV0ZXJzIGZyb20gJy4uL0FiaVBhcmFtZXRlcnMuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4uL0J5dGVzLmpzJztcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4uL0hleC5qcyc7XG5pbXBvcnQgeyBpbnRlZ2VyUmVnZXggfSBmcm9tICcuLi9Tb2xpZGl0eS5qcyc7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUGFyYW1ldGVyKGN1cnNvciwgcGFyYW0sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtQWRkcmVzcywgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtLnR5cGUpO1xuICAgIGlmIChhcnJheUNvbXBvbmVudHMpIHtcbiAgICAgICAgY29uc3QgW2xlbmd0aCwgdHlwZV0gPSBhcnJheUNvbXBvbmVudHM7XG4gICAgICAgIHJldHVybiBkZWNvZGVBcnJheShjdXJzb3IsIHsgLi4ucGFyYW0sIHR5cGUgfSwgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbS50eXBlID09PSAndHVwbGUnKVxuICAgICAgICByZXR1cm4gZGVjb2RlVHVwbGUoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb24sXG4gICAgICAgIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYWRkcmVzcycpXG4gICAgICAgIHJldHVybiBkZWNvZGVBZGRyZXNzKGN1cnNvciwgeyBjaGVja3N1bTogY2hlY2tzdW1BZGRyZXNzIH0pO1xuICAgIGlmIChwYXJhbS50eXBlID09PSAnYm9vbCcpXG4gICAgICAgIHJldHVybiBkZWNvZGVCb29sKGN1cnNvcik7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnYnl0ZXMnKSlcbiAgICAgICAgcmV0dXJuIGRlY29kZUJ5dGVzKGN1cnNvciwgcGFyYW0sIHsgc3RhdGljUG9zaXRpb24gfSk7XG4gICAgaWYgKHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgndWludCcpIHx8IHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpXG4gICAgICAgIHJldHVybiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSk7XG4gICAgaWYgKHBhcmFtLnR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gZGVjb2RlU3RyaW5nKGN1cnNvciwgeyBzdGF0aWNQb3NpdGlvbiB9KTtcbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtLnR5cGUpO1xufVxuY29uc3Qgc2l6ZU9mTGVuZ3RoID0gMzI7XG5jb25zdCBzaXplT2ZPZmZzZXQgPSAzMjtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBZGRyZXNzKGN1cnNvciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGVja3N1bSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHZhbHVlID0gY3Vyc29yLnJlYWRCeXRlcygzMik7XG4gICAgY29uc3Qgd3JhcCA9IChhZGRyZXNzKSA9PiBjaGVja3N1bSA/IEFkZHJlc3MuY2hlY2tzdW0oYWRkcmVzcykgOiBhZGRyZXNzO1xuICAgIHJldHVybiBbd3JhcChIZXguZnJvbUJ5dGVzKEJ5dGVzLnNsaWNlKHZhbHVlLCAtMjApKSksIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVBcnJheShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIGxlbmd0aCwgc3RhdGljUG9zaXRpb24gfSA9IG9wdGlvbnM7XG4gICAgLy8gSWYgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgaXMgbm90IGtub3duIGluIGFkdmFuY2UgKGR5bmFtaWMgYXJyYXkpLFxuICAgIC8vIHRoaXMgbWVhbnMgd2Ugd2lsbCBuZWVkIHRvIHdvbmRlciBvZmYgdG8gdGhlIHBvaW50ZXIgYW5kIGRlY29kZS5cbiAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggYSBkeW5hbWljIHR5cGUsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBhcnJheSBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKHNpemVPZk9mZnNldCkpO1xuICAgICAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGF0aWNQb3NpdGlvbiArIG9mZnNldDtcbiAgICAgICAgY29uc3Qgc3RhcnRPZkRhdGEgPSBzdGFydCArIHNpemVPZkxlbmd0aDtcbiAgICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGZyb20gdGhlIG9mZnNldC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0KTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZMZW5ndGgpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGFycmF5IGhhcyBhbnkgZHluYW1pYyBjaGlsZHJlbi5cbiAgICAgICAgY29uc3QgZHluYW1pY0NoaWxkID0gaGFzRHluYW1pY0NoaWxkKHBhcmFtKTtcbiAgICAgICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgLy8gSWYgYW55IG9mIHRoZSBjaGlsZHJlbiBpcyBkeW5hbWljLCB0aGVuIGFsbCBlbGVtZW50cyB3aWxsIGJlIG9mZnNldCBwb2ludGVyLCB0aHVzIHNpemUgb2Ygb25lIHNsb3QgKDMyIGJ5dGVzKS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZWxlbWVudHMgd2lsbCBiZSB0aGUgc2l6ZSBvZiB0aGVpciBlbmNvZGluZyAoY29uc3VtZWQgYnl0ZXMpLlxuICAgICAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXJ0T2ZEYXRhICsgKGR5bmFtaWNDaGlsZCA/IGkgKiAzMiA6IGNvbnN1bWVkKSk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIHBhcmFtLCB7XG4gICAgICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uOiBzdGFydE9mRGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3VtZWQgKz0gY29uc3VtZWRfO1xuICAgICAgICAgICAgdmFsdWUucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSBsZW5ndGggb2YgdGhlIGFycmF5IGlzIGtub3duIGluIGFkdmFuY2UsXG4gICAgLy8gYW5kIHRoZSBsZW5ndGggb2YgYW4gZWxlbWVudCBkZWVwbHkgbmVzdGVkIGluIHRoZSBhcnJheSBpcyBub3Qga25vd24sXG4gICAgLy8gd2UgbmVlZCB0byBkZWNvZGUgdGhlIG9mZnNldCBvZiB0aGUgYXJyYXkgZGF0YS5cbiAgICBpZiAoaGFzRHluYW1pY0NoaWxkKHBhcmFtKSkge1xuICAgICAgICAvLyBEZWFsaW5nIHdpdGggZHluYW1pYyB0eXBlcywgc28gZ2V0IHRoZSBvZmZzZXQgb2YgdGhlIGFycmF5IGRhdGEuXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoc2l6ZU9mT2Zmc2V0KSk7XG4gICAgICAgIC8vIFN0YXJ0IGlzIHRoZSBzdGF0aWMgcG9zaXRpb24gb2YgY3VycmVudCBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAvLyBNb3ZlIGN1cnNvciBhbG9uZyB0byB0aGUgbmV4dCBzbG90IChuZXh0IG9mZnNldCBwb2ludGVyKS5cbiAgICAgICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCArIGkgKiAzMik7XG4gICAgICAgICAgICBjb25zdCBbZGF0YV0gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIDMyKTtcbiAgICAgICAgcmV0dXJuIFt2YWx1ZSwgMzJdO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBpcyBrbm93biBpbiBhZHZhbmNlIGFuZCB0aGUgYXJyYXkgaXMgZGVlcGx5IHN0YXRpYyxcbiAgICAvLyB0aGVuIHdlIGNhbiBqdXN0IGRlY29kZSBlYWNoIGVsZW1lbnQgaW4gc2VxdWVuY2UuXG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICBjb25zdCB2YWx1ZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBwYXJhbSwge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgc3RhdGljUG9zaXRpb246IHN0YXRpY1Bvc2l0aW9uICsgY29uc3VtZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgICAgIHZhbHVlLnB1c2goZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCb29sKGN1cnNvcikge1xuICAgIHJldHVybiBbQnl0ZXMudG9Cb29sZWFuKGN1cnNvci5yZWFkQnl0ZXMoMzIpLCB7IHNpemU6IDMyIH0pLCAzMl07XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQnl0ZXMoY3Vyc29yLCBwYXJhbSwgeyBzdGF0aWNQb3NpdGlvbiB9KSB7XG4gICAgY29uc3QgW18sIHNpemVdID0gcGFyYW0udHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgLy8gRGVhbGluZyB3aXRoIGR5bmFtaWMgdHlwZXMsIHNvIGdldCB0aGUgb2Zmc2V0IG9mIHRoZSBieXRlcyBkYXRhLlxuICAgICAgICBjb25zdCBvZmZzZXQgPSBCeXRlcy50b051bWJlcihjdXJzb3IucmVhZEJ5dGVzKDMyKSk7XG4gICAgICAgIC8vIFNldCBwb3NpdGlvbiBvZiB0aGUgY3Vyc29yIHRvIHN0YXJ0IG9mIGJ5dGVzIGRhdGEuXG4gICAgICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGF0aWNQb3NpdGlvbiArIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbGVuZ3RoLCB3ZSBoYXZlIHplcm8gZGF0YS5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgICAgICByZXR1cm4gWycweCcsIDMyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gY3Vyc29yLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW0hleC5mcm9tQnl0ZXMoZGF0YSksIDMyXTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBIZXguZnJvbUJ5dGVzKGN1cnNvci5yZWFkQnl0ZXMoTnVtYmVyLnBhcnNlSW50KHNpemUpLCAzMikpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVOdW1iZXIoY3Vyc29yLCBwYXJhbSkge1xuICAgIGNvbnN0IHNpZ25lZCA9IHBhcmFtLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgY29uc3Qgc2l6ZSA9IE51bWJlci5wYXJzZUludChwYXJhbS50eXBlLnNwbGl0KCdpbnQnKVsxXSB8fCAnMjU2Jyk7XG4gICAgY29uc3QgdmFsdWUgPSBjdXJzb3IucmVhZEJ5dGVzKDMyKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzaXplID4gNDhcbiAgICAgICAgICAgID8gQnl0ZXMudG9CaWdJbnQodmFsdWUsIHsgc2lnbmVkIH0pXG4gICAgICAgICAgICA6IEJ5dGVzLnRvTnVtYmVyKHZhbHVlLCB7IHNpZ25lZCB9KSxcbiAgICAgICAgMzIsXG4gICAgXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVUdXBsZShjdXJzb3IsIHBhcmFtLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBjaGVja3N1bUFkZHJlc3MsIHN0YXRpY1Bvc2l0aW9uIH0gPSBvcHRpb25zO1xuICAgIC8vIFR1cGxlcyBjYW4gaGF2ZSB1bm5hbWVkIGNvbXBvbmVudHMgKGkuZS4gdGhleSBhcmUgYXJyYXlzKSwgc28gd2UgbXVzdFxuICAgIC8vIGRldGVybWluZSB3aGV0aGVyIHRoZSB0dXBsZSBpcyBuYW1lZCBvciB1bm5hbWVkLiBJbiB0aGUgY2FzZSBvZiBhIG5hbWVkXG4gICAgLy8gdHVwbGUsIHRoZSB2YWx1ZSB3aWxsIGJlIGFuIG9iamVjdCB3aGVyZSBlYWNoIHByb3BlcnR5IGlzIHRoZSBuYW1lIG9mIHRoZVxuICAgIC8vIGNvbXBvbmVudC4gSW4gdGhlIGNhc2Ugb2YgYW4gdW5uYW1lZCB0dXBsZSwgdGhlIHZhbHVlIHdpbGwgYmUgYW4gYXJyYXkuXG4gICAgY29uc3QgaGFzVW5uYW1lZENoaWxkID0gcGFyYW0uY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgcGFyYW0uY29tcG9uZW50cy5zb21lKCh7IG5hbWUgfSkgPT4gIW5hbWUpO1xuICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlIHRvIGFuIG9iamVjdCBvciBhbiBhcnJheSwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlXG4gICAgLy8gdHVwbGUgaXMgbmFtZWQgb3IgdW5uYW1lZC5cbiAgICBjb25zdCB2YWx1ZSA9IGhhc1VubmFtZWRDaGlsZCA/IFtdIDoge307XG4gICAgbGV0IGNvbnN1bWVkID0gMDtcbiAgICAvLyBJZiB0aGUgdHVwbGUgaGFzIGEgZHluYW1pYyBjaGlsZCwgd2UgbXVzdCBmaXJzdCBkZWNvZGUgdGhlIG9mZnNldCB0byB0aGVcbiAgICAvLyB0dXBsZSBkYXRhLlxuICAgIGlmIChoYXNEeW5hbWljQ2hpbGQocGFyYW0pKSB7XG4gICAgICAgIC8vIERlYWxpbmcgd2l0aCBkeW5hbWljIHR5cGVzLCBzbyBnZXQgdGhlIG9mZnNldCBvZiB0aGUgdHVwbGUgZGF0YS5cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcyhzaXplT2ZPZmZzZXQpKTtcbiAgICAgICAgLy8gU3RhcnQgaXMgdGhlIHN0YXRpYyBwb3NpdGlvbiBvZiByZWZlcmVuY2luZyBzbG90ICsgb2Zmc2V0LlxuICAgICAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHBhcmFtLmNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhcnQgKyBjb25zdW1lZCk7XG4gICAgICAgICAgICBjb25zdCBbZGF0YSwgY29uc3VtZWRfXSA9IGRlY29kZVBhcmFtZXRlcihjdXJzb3IsIGNvbXBvbmVudCwge1xuICAgICAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzdGF0aWNQb3NpdGlvbjogc3RhcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN1bWVkICs9IGNvbnN1bWVkXztcbiAgICAgICAgICAgIHZhbHVlW2hhc1VubmFtZWRDaGlsZCA/IGkgOiBjb21wb25lbnQ/Lm5hbWVdID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcyB3ZSBoYXZlIGdvbmUgd29uZGVyaW5nLCByZXN0b3JlIHRvIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiArIG5leHQgc2xvdC5cbiAgICAgICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgICAgICByZXR1cm4gW3ZhbHVlLCAzMl07XG4gICAgfVxuICAgIC8vIElmIHRoZSB0dXBsZSBoYXMgc3RhdGljIGNoaWxkcmVuLCB3ZSBjYW4ganVzdCBkZWNvZGUgZWFjaCBjb21wb25lbnRcbiAgICAvLyBpbiBzZXF1ZW5jZS5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmNvbXBvbmVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50ID0gcGFyYW0uY29tcG9uZW50c1tpXTtcbiAgICAgICAgY29uc3QgW2RhdGEsIGNvbnN1bWVkX10gPSBkZWNvZGVQYXJhbWV0ZXIoY3Vyc29yLCBjb21wb25lbnQsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHN0YXRpY1Bvc2l0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWVbaGFzVW5uYW1lZENoaWxkID8gaSA6IGNvbXBvbmVudD8ubmFtZV0gPSBkYXRhO1xuICAgICAgICBjb25zdW1lZCArPSBjb25zdW1lZF87XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVTdHJpbmcoY3Vyc29yLCB7IHN0YXRpY1Bvc2l0aW9uIH0pIHtcbiAgICAvLyBHZXQgb2Zmc2V0IHRvIHN0YXJ0IG9mIHN0cmluZyBkYXRhLlxuICAgIGNvbnN0IG9mZnNldCA9IEJ5dGVzLnRvTnVtYmVyKGN1cnNvci5yZWFkQnl0ZXMoMzIpKTtcbiAgICAvLyBTdGFydCBpcyB0aGUgc3RhdGljIHBvc2l0aW9uIG9mIGN1cnJlbnQgc2xvdCArIG9mZnNldC5cbiAgICBjb25zdCBzdGFydCA9IHN0YXRpY1Bvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGN1cnNvci5zZXRQb3NpdGlvbihzdGFydCk7XG4gICAgY29uc3QgbGVuZ3RoID0gQnl0ZXMudG9OdW1iZXIoY3Vyc29yLnJlYWRCeXRlcygzMikpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlbmd0aCwgd2UgaGF2ZSB6ZXJvIGRhdGEgKGVtcHR5IHN0cmluZykuXG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjdXJzb3Iuc2V0UG9zaXRpb24oc3RhdGljUG9zaXRpb24gKyAzMik7XG4gICAgICAgIHJldHVybiBbJycsIDMyXTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoLCAzMik7XG4gICAgY29uc3QgdmFsdWUgPSBCeXRlcy50b1N0cmluZyhCeXRlcy50cmltTGVmdChkYXRhKSk7XG4gICAgLy8gQXMgd2UgaGF2ZSBnb25lIHdvbmRlcmluZywgcmVzdG9yZSB0byB0aGUgb3JpZ2luYWwgcG9zaXRpb24gKyBuZXh0IHNsb3QuXG4gICAgY3Vyc29yLnNldFBvc2l0aW9uKHN0YXRpY1Bvc2l0aW9uICsgMzIpO1xuICAgIHJldHVybiBbdmFsdWUsIDMyXTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlUGFyYW1ldGVycyh7IGNoZWNrc3VtQWRkcmVzcywgcGFyYW1ldGVycywgdmFsdWVzLCB9KSB7XG4gICAgY29uc3QgcHJlcGFyZWRQYXJhbWV0ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyOiBwYXJhbWV0ZXJzW2ldLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1tpXSxcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyZWRQYXJhbWV0ZXJzO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVQYXJhbWV0ZXIoeyBjaGVja3N1bUFkZHJlc3MgPSBmYWxzZSwgcGFyYW1ldGVyOiBwYXJhbWV0ZXJfLCB2YWx1ZSwgfSkge1xuICAgIGNvbnN0IHBhcmFtZXRlciA9IHBhcmFtZXRlcl87XG4gICAgY29uc3QgYXJyYXlDb21wb25lbnRzID0gZ2V0QXJyYXlDb21wb25lbnRzKHBhcmFtZXRlci50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnN0IFtsZW5ndGgsIHR5cGVdID0gYXJyYXlDb21wb25lbnRzO1xuICAgICAgICByZXR1cm4gZW5jb2RlQXJyYXkodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICAgIHBhcmFtZXRlcjoge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtZXRlcixcbiAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZSA9PT0gJ3R1cGxlJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlVHVwbGUodmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgIHBhcmFtZXRlcjogcGFyYW1ldGVyLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlID09PSAnYWRkcmVzcycpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUFkZHJlc3ModmFsdWUsIHtcbiAgICAgICAgICAgIGNoZWNrc3VtOiBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZW5jb2RlQm9vbGVhbih2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChwYXJhbWV0ZXIudHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgY29uc3Qgc2lnbmVkID0gcGFyYW1ldGVyLnR5cGUuc3RhcnRzV2l0aCgnaW50Jyk7XG4gICAgICAgIGNvbnN0IFssICwgc2l6ZSA9ICcyNTYnXSA9IGludGVnZXJSZWdleC5leGVjKHBhcmFtZXRlci50eXBlKSA/PyBbXTtcbiAgICAgICAgcmV0dXJuIGVuY29kZU51bWJlcih2YWx1ZSwge1xuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICAgICAgc2l6ZTogTnVtYmVyKHNpemUpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmFtZXRlci50eXBlLnN0YXJ0c1dpdGgoJ2J5dGVzJykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGU6IHBhcmFtZXRlci50eXBlIH0pO1xuICAgIH1cbiAgICBpZiAocGFyYW1ldGVyLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQWJpUGFyYW1ldGVycy5JbnZhbGlkVHlwZUVycm9yKHBhcmFtZXRlci50eXBlKTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGUocHJlcGFyZWRQYXJhbWV0ZXJzKSB7XG4gICAgLy8gMS4gQ29tcHV0ZSB0aGUgc2l6ZSBvZiB0aGUgc3RhdGljIHBhcnQgb2YgdGhlIHBhcmFtZXRlcnMuXG4gICAgbGV0IHN0YXRpY1NpemUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgZHluYW1pYywgZW5jb2RlZCB9ID0gcHJlcGFyZWRQYXJhbWV0ZXJzW2ldO1xuICAgICAgICBpZiAoZHluYW1pYylcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gMzI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHN0YXRpY1NpemUgKz0gSGV4LnNpemUoZW5jb2RlZCk7XG4gICAgfVxuICAgIC8vIDIuIFNwbGl0IHRoZSBwYXJhbWV0ZXJzIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhcnRzLlxuICAgIGNvbnN0IHN0YXRpY1BhcmFtZXRlcnMgPSBbXTtcbiAgICBjb25zdCBkeW5hbWljUGFyYW1ldGVycyA9IFtdO1xuICAgIGxldCBkeW5hbWljU2l6ZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBkeW5hbWljLCBlbmNvZGVkIH0gPSBwcmVwYXJlZFBhcmFtZXRlcnNbaV07XG4gICAgICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgICAgICBzdGF0aWNQYXJhbWV0ZXJzLnB1c2goSGV4LmZyb21OdW1iZXIoc3RhdGljU2l6ZSArIGR5bmFtaWNTaXplLCB7IHNpemU6IDMyIH0pKTtcbiAgICAgICAgICAgIGR5bmFtaWNQYXJhbWV0ZXJzLnB1c2goZW5jb2RlZCk7XG4gICAgICAgICAgICBkeW5hbWljU2l6ZSArPSBIZXguc2l6ZShlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRpY1BhcmFtZXRlcnMucHVzaChlbmNvZGVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLiBDb25jYXRlbmF0ZSBzdGF0aWMgYW5kIGR5bmFtaWMgcGFydHMuXG4gICAgcmV0dXJuIEhleC5jb25jYXQoLi4uc3RhdGljUGFyYW1ldGVycywgLi4uZHluYW1pY1BhcmFtZXRlcnMpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUFkZHJlc3ModmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGNoZWNrc3VtID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgQWRkcmVzcy5hc3NlcnQodmFsdWUsIHsgc3RyaWN0OiBjaGVja3N1bSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LnBhZExlZnQodmFsdWUudG9Mb3dlckNhc2UoKSksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVBcnJheSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBsZW5ndGgsIHBhcmFtZXRlciB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkeW5hbWljID0gbGVuZ3RoID09PSBudWxsO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkludmFsaWRBcnJheUVycm9yKHZhbHVlKTtcbiAgICBpZiAoIWR5bmFtaWMgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkFycmF5TGVuZ3RoTWlzbWF0Y2hFcnJvcih7XG4gICAgICAgICAgICBleHBlY3RlZExlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgZ2l2ZW5MZW5ndGg6IHZhbHVlLmxlbmd0aCxcbiAgICAgICAgICAgIHR5cGU6IGAke3BhcmFtZXRlci50eXBlfVske2xlbmd0aH1dYCxcbiAgICAgICAgfSk7XG4gICAgbGV0IGR5bmFtaWNDaGlsZCA9IGZhbHNlO1xuICAgIGNvbnN0IHByZXBhcmVkUGFyYW1ldGVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJlcGFyZWRQYXJhbSA9IHByZXBhcmVQYXJhbWV0ZXIoe1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1ldGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlW2ldLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWNDaGlsZCA9IHRydWU7XG4gICAgICAgIHByZXBhcmVkUGFyYW1ldGVycy5wdXNoKHByZXBhcmVkUGFyYW0pO1xuICAgIH1cbiAgICBpZiAoZHluYW1pYyB8fCBkeW5hbWljQ2hpbGQpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gSGV4LmZyb21OdW1iZXIocHJlcGFyZWRQYXJhbWV0ZXJzLmxlbmd0aCwgeyBzaXplOiAzMiB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHluYW1pYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbmNvZGVkOiBwcmVwYXJlZFBhcmFtZXRlcnMubGVuZ3RoID4gMCA/IEhleC5jb25jYXQobGVuZ3RoLCBkYXRhKSA6IGxlbmd0aCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR5bmFtaWNDaGlsZClcbiAgICAgICAgICAgIHJldHVybiB7IGR5bmFtaWM6IHRydWUsIGVuY29kZWQ6IGRhdGEgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHluYW1pYzogZmFsc2UsXG4gICAgICAgIGVuY29kZWQ6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZUJ5dGVzKHZhbHVlLCB7IHR5cGUgfSkge1xuICAgIGNvbnN0IFssIHBhcmFtZXRlcnNpemVdID0gdHlwZS5zcGxpdCgnYnl0ZXMnKTtcbiAgICBjb25zdCBieXRlc1NpemUgPSBIZXguc2l6ZSh2YWx1ZSk7XG4gICAgaWYgKCFwYXJhbWV0ZXJzaXplKSB7XG4gICAgICAgIGxldCB2YWx1ZV8gPSB2YWx1ZTtcbiAgICAgICAgLy8gSWYgdGhlIHNpemUgaXMgbm90IGRpdmlzaWJsZSBieSAzMiBieXRlcywgcGFkIHRoZSBlbmRcbiAgICAgICAgLy8gd2l0aCBlbXB0eSBieXRlcyB0byB0aGUgY2VpbGluZyAzMiBieXRlcy5cbiAgICAgICAgaWYgKGJ5dGVzU2l6ZSAlIDMyICE9PSAwKVxuICAgICAgICAgICAgdmFsdWVfID0gSGV4LnBhZFJpZ2h0KHZhbHVlXywgTWF0aC5jZWlsKCh2YWx1ZS5sZW5ndGggLSAyKSAvIDIgLyAzMikgKiAzMik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICAgICAgZW5jb2RlZDogSGV4LmNvbmNhdChIZXgucGFkTGVmdChIZXguZnJvbU51bWJlcihieXRlc1NpemUsIHsgc2l6ZTogMzIgfSkpLCB2YWx1ZV8pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYnl0ZXNTaXplICE9PSBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSkpXG4gICAgICAgIHRocm93IG5ldyBBYmlQYXJhbWV0ZXJzLkJ5dGVzU2l6ZU1pc21hdGNoRXJyb3Ioe1xuICAgICAgICAgICAgZXhwZWN0ZWRTaXplOiBOdW1iZXIucGFyc2VJbnQocGFyYW1ldGVyc2l6ZSksXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIHsgZHluYW1pYzogZmFsc2UsIGVuY29kZWQ6IEhleC5wYWRSaWdodCh2YWx1ZSkgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVCb29sZWFuKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcihgSW52YWxpZCBib29sZWFuIHZhbHVlOiBcIiR7dmFsdWV9XCIgKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkuIEV4cGVjdGVkOiBcXGB0cnVlXFxgIG9yIFxcYGZhbHNlXFxgLmApO1xuICAgIHJldHVybiB7IGR5bmFtaWM6IGZhbHNlLCBlbmNvZGVkOiBIZXgucGFkTGVmdChIZXguZnJvbUJvb2xlYW4odmFsdWUpKSB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZU51bWJlcih2YWx1ZSwgeyBzaWduZWQsIHNpemUgfSkge1xuICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uc3QgbWF4ID0gMm4gKiogKEJpZ0ludChzaXplKSAtIChzaWduZWQgPyAxbiA6IDBuKSkgLSAxbjtcbiAgICAgICAgY29uc3QgbWluID0gc2lnbmVkID8gLW1heCAtIDFuIDogMG47XG4gICAgICAgIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbilcbiAgICAgICAgICAgIHRocm93IG5ldyBIZXguSW50ZWdlck91dE9mUmFuZ2VFcnJvcih7XG4gICAgICAgICAgICAgICAgbWF4OiBtYXgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBtaW46IG1pbi50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgIHNpZ25lZCxcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplIC8gOCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiBmYWxzZSxcbiAgICAgICAgZW5jb2RlZDogSGV4LmZyb21OdW1iZXIodmFsdWUsIHtcbiAgICAgICAgICAgIHNpemU6IDMyLFxuICAgICAgICAgICAgc2lnbmVkLFxuICAgICAgICB9KSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVN0cmluZyh2YWx1ZSkge1xuICAgIGNvbnN0IGhleFZhbHVlID0gSGV4LmZyb21TdHJpbmcodmFsdWUpO1xuICAgIGNvbnN0IHBhcnRzTGVuZ3RoID0gTWF0aC5jZWlsKEhleC5zaXplKGhleFZhbHVlKSAvIDMyKTtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHNMZW5ndGg7IGkrKykge1xuICAgICAgICBwYXJ0cy5wdXNoKEhleC5wYWRSaWdodChIZXguc2xpY2UoaGV4VmFsdWUsIGkgKiAzMiwgKGkgKyAxKSAqIDMyKSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljOiB0cnVlLFxuICAgICAgICBlbmNvZGVkOiBIZXguY29uY2F0KEhleC5wYWRSaWdodChIZXguZnJvbU51bWJlcihIZXguc2l6ZShoZXhWYWx1ZSksIHsgc2l6ZTogMzIgfSkpLCAuLi5wYXJ0cyksXG4gICAgfTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmNvZGVUdXBsZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2hlY2tzdW1BZGRyZXNzLCBwYXJhbWV0ZXIgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGR5bmFtaWMgPSBmYWxzZTtcbiAgICBjb25zdCBwcmVwYXJlZFBhcmFtZXRlcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtZXRlci5jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtXyA9IHBhcmFtZXRlci5jb21wb25lbnRzW2ldO1xuICAgICAgICBjb25zdCBpbmRleCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gaSA6IHBhcmFtXy5uYW1lO1xuICAgICAgICBjb25zdCBwcmVwYXJlZFBhcmFtID0gcHJlcGFyZVBhcmFtZXRlcih7XG4gICAgICAgICAgICBjaGVja3N1bUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHBhcmFtXyxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVtpbmRleF0sXG4gICAgICAgIH0pO1xuICAgICAgICBwcmVwYXJlZFBhcmFtZXRlcnMucHVzaChwcmVwYXJlZFBhcmFtKTtcbiAgICAgICAgaWYgKHByZXBhcmVkUGFyYW0uZHluYW1pYylcbiAgICAgICAgICAgIGR5bmFtaWMgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkeW5hbWljLFxuICAgICAgICBlbmNvZGVkOiBkeW5hbWljXG4gICAgICAgICAgICA/IGVuY29kZShwcmVwYXJlZFBhcmFtZXRlcnMpXG4gICAgICAgICAgICA6IEhleC5jb25jYXQoLi4ucHJlcGFyZWRQYXJhbWV0ZXJzLm1hcCgoeyBlbmNvZGVkIH0pID0+IGVuY29kZWQpKSxcbiAgICB9O1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5Q29tcG9uZW50cyh0eXBlKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHR5cGUubWF0Y2goL14oLiopXFxbKFxcZCspP1xcXSQvKTtcbiAgICByZXR1cm4gbWF0Y2hlc1xuICAgICAgICA/IC8vIFJldHVybiBgbnVsbGAgaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMuXG4gICAgICAgICAgICBbbWF0Y2hlc1syXSA/IE51bWJlcihtYXRjaGVzWzJdKSA6IG51bGwsIG1hdGNoZXNbMV1dXG4gICAgICAgIDogdW5kZWZpbmVkO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc0R5bmFtaWNDaGlsZChwYXJhbSkge1xuICAgIGNvbnN0IHsgdHlwZSB9ID0gcGFyYW07XG4gICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ2J5dGVzJylcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGUuZW5kc1dpdGgoJ1tdJykpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlID09PSAndHVwbGUnKVxuICAgICAgICByZXR1cm4gcGFyYW0uY29tcG9uZW50cz8uc29tZShoYXNEeW5hbWljQ2hpbGQpO1xuICAgIGNvbnN0IGFycmF5Q29tcG9uZW50cyA9IGdldEFycmF5Q29tcG9uZW50cyhwYXJhbS50eXBlKTtcbiAgICBpZiAoYXJyYXlDb21wb25lbnRzICYmXG4gICAgICAgIGhhc0R5bmFtaWNDaGlsZCh7XG4gICAgICAgICAgICAuLi5wYXJhbSxcbiAgICAgICAgICAgIHR5cGU6IGFycmF5Q29tcG9uZW50c1sxXSxcbiAgICAgICAgfSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFiaVBhcmFtZXRlcnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/abiParameters.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/bytes.js":
/*!*********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/bytes.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   charCodeMap: () => (/* binding */ charCodeMap),\n/* harmony export */   charCodeToBase16: () => (/* binding */ charCodeToBase16),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Bytes.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n\n/** @internal */\nfunction assertSize(bytes, size_) {\n    if (_Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes) > size_)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(bytes),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nconst charCodeMap = {\n    zero: 48,\n    nine: 57,\n    A: 65,\n    F: 70,\n    a: 97,\n    f: 102,\n};\n/** @internal */\nfunction charCodeToBase16(char) {\n    if (char >= charCodeMap.zero && char <= charCodeMap.nine)\n        return char - charCodeMap.zero;\n    if (char >= charCodeMap.A && char <= charCodeMap.F)\n        return char - (charCodeMap.A - 10);\n    if (char >= charCodeMap.a && char <= charCodeMap.f)\n        return char - (charCodeMap.a - 10);\n    return undefined;\n}\n/** @internal */\nfunction pad(bytes, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return bytes;\n    if (bytes.length > size)\n        throw new _Bytes_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: bytes.length,\n            targetSize: size,\n            type: 'Bytes',\n        });\n    const paddedBytes = new Uint8Array(size);\n    for (let i = 0; i < size; i++) {\n        const padEnd = dir === 'right';\n        paddedBytes[padEnd ? i : size - i - 1] =\n            bytes[padEnd ? i : bytes.length - i - 1];\n    }\n    return paddedBytes;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value;\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    return data;\n}\n//# sourceMappingURL=bytes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9ieXRlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFxQztBQUNyQztBQUNPO0FBQ1AsUUFBUSwyQ0FBVTtBQUNsQixrQkFBa0Isd0RBQXVCO0FBQ3pDLHVCQUF1QiwyQ0FBVTtBQUNqQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCwwREFBMEQsMkNBQVU7QUFDcEUsa0JBQWtCLGtFQUFpQztBQUNuRDtBQUNBO0FBQ0Esa0JBQWtCLDJDQUFVO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsUUFBUSwyQ0FBVTtBQUNsQixrQkFBa0Isa0VBQWlDO0FBQ25EO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQVU7QUFDNUIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDO0FBQ3ZDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxpQ0FBaUM7QUFDeEMsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcX2VzbVxcY29yZVxcaW50ZXJuYWxcXGJ5dGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4uL0J5dGVzLmpzJztcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTaXplKGJ5dGVzLCBzaXplXykge1xuICAgIGlmIChCeXRlcy5zaXplKGJ5dGVzKSA+IHNpemVfKVxuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2l6ZU92ZXJmbG93RXJyb3Ioe1xuICAgICAgICAgICAgZ2l2ZW5TaXplOiBCeXRlcy5zaXplKGJ5dGVzKSxcbiAgICAgICAgICAgIG1heFNpemU6IHNpemVfLFxuICAgICAgICB9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRTdGFydE9mZnNldCh2YWx1ZSwgc3RhcnQpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnbnVtYmVyJyAmJiBzdGFydCA+IDAgJiYgc3RhcnQgPiBCeXRlcy5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBCeXRlcy5TbGljZU9mZnNldE91dE9mQm91bmRzRXJyb3Ioe1xuICAgICAgICAgICAgb2Zmc2V0OiBzdGFydCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnc3RhcnQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVuZE9mZnNldCh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBlbmQgPT09ICdudW1iZXInICYmXG4gICAgICAgIEJ5dGVzLnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgQnl0ZXMuU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogZW5kLFxuICAgICAgICAgICAgcG9zaXRpb246ICdlbmQnLFxuICAgICAgICAgICAgc2l6ZTogQnl0ZXMuc2l6ZSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBjaGFyQ29kZU1hcCA9IHtcbiAgICB6ZXJvOiA0OCxcbiAgICBuaW5lOiA1NyxcbiAgICBBOiA2NSxcbiAgICBGOiA3MCxcbiAgICBhOiA5NyxcbiAgICBmOiAxMDIsXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNoYXJDb2RlVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGNoYXJDb2RlTWFwLnplcm8gJiYgY2hhciA8PSBjaGFyQ29kZU1hcC5uaW5lKVxuICAgICAgICByZXR1cm4gY2hhciAtIGNoYXJDb2RlTWFwLnplcm87XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuQSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLkYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwLkEgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gY2hhckNvZGVNYXAuYSAmJiBjaGFyIDw9IGNoYXJDb2RlTWFwLmYpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGNoYXJDb2RlTWFwLmEgLSAxMCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoYnl0ZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZGlyLCBzaXplID0gMzIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKHNpemUgPT09IDApXG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICBpZiAoYnl0ZXMubGVuZ3RoID4gc2l6ZSlcbiAgICAgICAgdGhyb3cgbmV3IEJ5dGVzLlNpemVFeGNlZWRzUGFkZGluZ1NpemVFcnJvcih7XG4gICAgICAgICAgICBzaXplOiBieXRlcy5sZW5ndGgsXG4gICAgICAgICAgICB0YXJnZXRTaXplOiBzaXplLFxuICAgICAgICAgICAgdHlwZTogJ0J5dGVzJyxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBjb25zdCBwYWRFbmQgPSBkaXIgPT09ICdyaWdodCc7XG4gICAgICAgIHBhZGRlZEJ5dGVzW3BhZEVuZCA/IGkgOiBzaXplIC0gaSAtIDFdID1cbiAgICAgICAgICAgIGJ5dGVzW3BhZEVuZCA/IGkgOiBieXRlcy5sZW5ndGggLSBpIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBwYWRkZWRCeXRlcztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0cmltKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciA9ICdsZWZ0JyB9ID0gb3B0aW9ucztcbiAgICBsZXQgZGF0YSA9IHZhbHVlO1xuICAgIGxldCBzbGljZUxlbmd0aCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAoZGF0YVtkaXIgPT09ICdsZWZ0JyA/IGkgOiBkYXRhLmxlbmd0aCAtIGkgLSAxXS50b1N0cmluZygpID09PSAnMCcpXG4gICAgICAgICAgICBzbGljZUxlbmd0aCsrO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZGF0YSA9XG4gICAgICAgIGRpciA9PT0gJ2xlZnQnXG4gICAgICAgICAgICA/IGRhdGEuc2xpY2Uoc2xpY2VMZW5ndGgpXG4gICAgICAgICAgICA6IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSBzbGljZUxlbmd0aCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ieXRlcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/bytes.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/cursor.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/cursor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NegativeOffsetError: () => (/* binding */ NegativeOffsetError),\n/* harmony export */   PositionOutOfBoundsError: () => (/* binding */ PositionOutOfBoundsError),\n/* harmony export */   RecursiveReadLimitExceededError: () => (/* binding */ RecursiveReadLimitExceededError),\n/* harmony export */   create: () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors.js */ \"(ssr)/../../node_modules/ox/_esm/core/Errors.js\");\n\nconst staticCursor = /*#__PURE__*/ {\n    bytes: new Uint8Array(),\n    dataView: new DataView(new ArrayBuffer(0)),\n    position: 0,\n    positionReadCount: new Map(),\n    recursiveReadCount: 0,\n    recursiveReadLimit: Number.POSITIVE_INFINITY,\n    assertReadLimit() {\n        if (this.recursiveReadCount >= this.recursiveReadLimit)\n            throw new RecursiveReadLimitExceededError({\n                count: this.recursiveReadCount + 1,\n                limit: this.recursiveReadLimit,\n            });\n    },\n    assertPosition(position) {\n        if (position < 0 || position > this.bytes.length - 1)\n            throw new PositionOutOfBoundsError({\n                length: this.bytes.length,\n                position,\n            });\n    },\n    decrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position - offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    getReadCount(position) {\n        return this.positionReadCount.get(position || this.position) || 0;\n    },\n    incrementPosition(offset) {\n        if (offset < 0)\n            throw new NegativeOffsetError({ offset });\n        const position = this.position + offset;\n        this.assertPosition(position);\n        this.position = position;\n    },\n    inspectByte(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectBytes(length, position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + length - 1);\n        return this.bytes.subarray(position, position + length);\n    },\n    inspectUint8(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position);\n        return this.bytes[position];\n    },\n    inspectUint16(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 1);\n        return this.dataView.getUint16(position);\n    },\n    inspectUint24(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 2);\n        return ((this.dataView.getUint16(position) << 8) +\n            this.dataView.getUint8(position + 2));\n    },\n    inspectUint32(position_) {\n        const position = position_ ?? this.position;\n        this.assertPosition(position + 3);\n        return this.dataView.getUint32(position);\n    },\n    pushByte(byte) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = byte;\n        this.position++;\n    },\n    pushBytes(bytes) {\n        this.assertPosition(this.position + bytes.length - 1);\n        this.bytes.set(bytes, this.position);\n        this.position += bytes.length;\n    },\n    pushUint8(value) {\n        this.assertPosition(this.position);\n        this.bytes[this.position] = value;\n        this.position++;\n    },\n    pushUint16(value) {\n        this.assertPosition(this.position + 1);\n        this.dataView.setUint16(this.position, value);\n        this.position += 2;\n    },\n    pushUint24(value) {\n        this.assertPosition(this.position + 2);\n        this.dataView.setUint16(this.position, value >> 8);\n        this.dataView.setUint8(this.position + 2, value & ~4294967040);\n        this.position += 3;\n    },\n    pushUint32(value) {\n        this.assertPosition(this.position + 3);\n        this.dataView.setUint32(this.position, value);\n        this.position += 4;\n    },\n    readByte() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectByte();\n        this.position++;\n        return value;\n    },\n    readBytes(length, size) {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectBytes(length);\n        this.position += size ?? length;\n        return value;\n    },\n    readUint8() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint8();\n        this.position += 1;\n        return value;\n    },\n    readUint16() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint16();\n        this.position += 2;\n        return value;\n    },\n    readUint24() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint24();\n        this.position += 3;\n        return value;\n    },\n    readUint32() {\n        this.assertReadLimit();\n        this._touch();\n        const value = this.inspectUint32();\n        this.position += 4;\n        return value;\n    },\n    get remaining() {\n        return this.bytes.length - this.position;\n    },\n    setPosition(position) {\n        const oldPosition = this.position;\n        this.assertPosition(position);\n        this.position = position;\n        return () => (this.position = oldPosition);\n    },\n    _touch() {\n        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)\n            return;\n        const count = this.getReadCount();\n        this.positionReadCount.set(this.position, count + 1);\n        if (count > 0)\n            this.recursiveReadCount++;\n    },\n};\n/** @internal */\nfunction create(bytes, { recursiveReadLimit = 8_192 } = {}) {\n    const cursor = Object.create(staticCursor);\n    cursor.bytes = bytes;\n    cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    cursor.positionReadCount = new Map();\n    cursor.recursiveReadLimit = recursiveReadLimit;\n    return cursor;\n}\n/** @internal */\nclass NegativeOffsetError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ offset }) {\n        super(`Offset \\`${offset}\\` cannot be negative.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.NegativeOffsetError'\n        });\n    }\n}\n/** @internal */\nclass PositionOutOfBoundsError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ length, position }) {\n        super(`Position \\`${position}\\` is out of bounds (\\`0 < position < ${length}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.PositionOutOfBoundsError'\n        });\n    }\n}\n/** @internal */\nclass RecursiveReadLimitExceededError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ count, limit }) {\n        super(`Recursive read limit of \\`${limit}\\` exceeded (recursive read count: \\`${count}\\`).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Cursor.RecursiveReadLimitExceededError'\n        });\n    }\n}\n//# sourceMappingURL=cursor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9jdXJzb3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTyx5QkFBeUIsNkJBQTZCLElBQUk7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLFFBQVE7QUFDMUIsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMsaURBQWdCO0FBQzlELGtCQUFrQixrQkFBa0I7QUFDcEMsNEJBQTRCLFNBQVMsd0NBQXdDLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyw4Q0FBOEMsaURBQWdCO0FBQ3JFLGtCQUFrQixjQUFjO0FBQ2hDLDJDQUEyQyxNQUFNLHVDQUF1QyxNQUFNO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxpbnRlcm5hbFxcY3Vyc29yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEVycm9ycyBmcm9tICcuLi9FcnJvcnMuanMnO1xuY29uc3Qgc3RhdGljQ3Vyc29yID0gLyojX19QVVJFX18qLyB7XG4gICAgYnl0ZXM6IG5ldyBVaW50OEFycmF5KCksXG4gICAgZGF0YVZpZXc6IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMCkpLFxuICAgIHBvc2l0aW9uOiAwLFxuICAgIHBvc2l0aW9uUmVhZENvdW50OiBuZXcgTWFwKCksXG4gICAgcmVjdXJzaXZlUmVhZENvdW50OiAwLFxuICAgIHJlY3Vyc2l2ZVJlYWRMaW1pdDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGFzc2VydFJlYWRMaW1pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucmVjdXJzaXZlUmVhZENvdW50ID49IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCArIDEsXG4gICAgICAgICAgICAgICAgbGltaXQ6IHRoaXMucmVjdXJzaXZlUmVhZExpbWl0LFxuICAgICAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhc3NlcnRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID4gdGhpcy5ieXRlcy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgIH0sXG4gICAgZGVjcmVtZW50UG9zaXRpb24ob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE5lZ2F0aXZlT2Zmc2V0RXJyb3IoeyBvZmZzZXQgfSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiAtIG9mZnNldDtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcbiAgICB9LFxuICAgIGdldFJlYWRDb3VudChwb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvblJlYWRDb3VudC5nZXQocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikgfHwgMDtcbiAgICB9LFxuICAgIGluY3JlbWVudFBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBOZWdhdGl2ZU9mZnNldEVycm9yKHsgb2Zmc2V0IH0pO1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyBvZmZzZXQ7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfSxcbiAgICBpbnNwZWN0Qnl0ZShwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzW3Bvc2l0aW9uXTtcbiAgICB9LFxuICAgIGluc3BlY3RCeXRlcyhsZW5ndGgsIHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgbGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ5dGVzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDgocG9zaXRpb25fKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25fID8/IHRoaXMucG9zaXRpb247XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlc1twb3NpdGlvbl07XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDE2KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNihwb3NpdGlvbik7XG4gICAgfSxcbiAgICBpbnNwZWN0VWludDI0KHBvc2l0aW9uXykge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHBvc2l0aW9uXyA/PyB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uICsgMik7XG4gICAgICAgIHJldHVybiAoKHRoaXMuZGF0YVZpZXcuZ2V0VWludDE2KHBvc2l0aW9uKSA8PCA4KSArXG4gICAgICAgICAgICB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KHBvc2l0aW9uICsgMikpO1xuICAgIH0sXG4gICAgaW5zcGVjdFVpbnQzMihwb3NpdGlvbl8pIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbl8gPz8gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbihwb3NpdGlvbiArIDMpO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIocG9zaXRpb24pO1xuICAgIH0sXG4gICAgcHVzaEJ5dGUoYnl0ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24pO1xuICAgICAgICB0aGlzLmJ5dGVzW3RoaXMucG9zaXRpb25dID0gYnl0ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaEJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIGJ5dGVzLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmJ5dGVzLnNldChieXRlcywgdGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gYnl0ZXMubGVuZ3RoO1xuICAgIH0sXG4gICAgcHVzaFVpbnQ4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbik7XG4gICAgICAgIHRoaXMuYnl0ZXNbdGhpcy5wb3NpdGlvbl0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbisrO1xuICAgIH0sXG4gICAgcHVzaFVpbnQxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHRoaXMucG9zaXRpb24gKyAxKTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5wb3NpdGlvbiwgdmFsdWUpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgfSxcbiAgICBwdXNoVWludDI0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UG9zaXRpb24odGhpcy5wb3NpdGlvbiArIDIpO1xuICAgICAgICB0aGlzLmRhdGFWaWV3LnNldFVpbnQxNih0aGlzLnBvc2l0aW9uLCB2YWx1ZSA+PiA4KTtcbiAgICAgICAgdGhpcy5kYXRhVmlldy5zZXRVaW50OCh0aGlzLnBvc2l0aW9uICsgMiwgdmFsdWUgJiB+NDI5NDk2NzA0MCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcbiAgICB9LFxuICAgIHB1c2hVaW50MzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRQb3NpdGlvbih0aGlzLnBvc2l0aW9uICsgMyk7XG4gICAgICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDMyKHRoaXMucG9zaXRpb24sIHZhbHVlKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICAgIH0sXG4gICAgcmVhZEJ5dGUoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0Qnl0ZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRCeXRlcyhsZW5ndGgsIHNpemUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RCeXRlcyhsZW5ndGgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IHNpemUgPz8gbGVuZ3RoO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDgoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDgoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICByZWFkVWludDE2KCkge1xuICAgICAgICB0aGlzLmFzc2VydFJlYWRMaW1pdCgpO1xuICAgICAgICB0aGlzLl90b3VjaCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaW5zcGVjdFVpbnQxNigpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHJlYWRVaW50MjQoKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0UmVhZExpbWl0KCk7XG4gICAgICAgIHRoaXMuX3RvdWNoKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5pbnNwZWN0VWludDI0KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMztcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcmVhZFVpbnQzMigpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRSZWFkTGltaXQoKTtcbiAgICAgICAgdGhpcy5fdG91Y2goKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluc3BlY3RVaW50MzIoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcbiAgICBnZXQgcmVtYWluaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ieXRlcy5sZW5ndGggLSB0aGlzLnBvc2l0aW9uO1xuICAgIH0sXG4gICAgc2V0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgb2xkUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgICAgICB0aGlzLmFzc2VydFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMucG9zaXRpb24gPSBvbGRQb3NpdGlvbik7XG4gICAgfSxcbiAgICBfdG91Y2goKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY3Vyc2l2ZVJlYWRMaW1pdCA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuZ2V0UmVhZENvdW50KCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25SZWFkQ291bnQuc2V0KHRoaXMucG9zaXRpb24sIGNvdW50ICsgMSk7XG4gICAgICAgIGlmIChjb3VudCA+IDApXG4gICAgICAgICAgICB0aGlzLnJlY3Vyc2l2ZVJlYWRDb3VudCsrO1xuICAgIH0sXG59O1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShieXRlcywgeyByZWN1cnNpdmVSZWFkTGltaXQgPSA4XzE5MiB9ID0ge30pIHtcbiAgICBjb25zdCBjdXJzb3IgPSBPYmplY3QuY3JlYXRlKHN0YXRpY0N1cnNvcik7XG4gICAgY3Vyc29yLmJ5dGVzID0gYnl0ZXM7XG4gICAgY3Vyc29yLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVzLmJ1ZmZlciwgYnl0ZXMuYnl0ZU9mZnNldCwgYnl0ZXMuYnl0ZUxlbmd0aCk7XG4gICAgY3Vyc29yLnBvc2l0aW9uUmVhZENvdW50ID0gbmV3IE1hcCgpO1xuICAgIGN1cnNvci5yZWN1cnNpdmVSZWFkTGltaXQgPSByZWN1cnNpdmVSZWFkTGltaXQ7XG4gICAgcmV0dXJuIGN1cnNvcjtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjbGFzcyBOZWdhdGl2ZU9mZnNldEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBvZmZzZXQgfSkge1xuICAgICAgICBzdXBlcihgT2Zmc2V0IFxcYCR7b2Zmc2V0fVxcYCBjYW5ub3QgYmUgbmVnYXRpdmUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdDdXJzb3IuTmVnYXRpdmVPZmZzZXRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbGVuZ3RoLCBwb3NpdGlvbiB9KSB7XG4gICAgICAgIHN1cGVyKGBQb3NpdGlvbiBcXGAke3Bvc2l0aW9ufVxcYCBpcyBvdXQgb2YgYm91bmRzIChcXGAwIDwgcG9zaXRpb24gPCAke2xlbmd0aH1cXGApLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnQ3Vyc29yLlBvc2l0aW9uT3V0T2ZCb3VuZHNFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNsYXNzIFJlY3Vyc2l2ZVJlYWRMaW1pdEV4Y2VlZGVkRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGNvdW50LCBsaW1pdCB9KSB7XG4gICAgICAgIHN1cGVyKGBSZWN1cnNpdmUgcmVhZCBsaW1pdCBvZiBcXGAke2xpbWl0fVxcYCBleGNlZWRlZCAocmVjdXJzaXZlIHJlYWQgY291bnQ6IFxcYCR7Y291bnR9XFxgKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ0N1cnNvci5SZWN1cnNpdmVSZWFkTGltaXRFeGNlZWRlZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/cursor.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/ens.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/ens.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   packetToBytes: () => (/* binding */ packetToBytes),\n/* harmony export */   unwrapLabelhash: () => (/* binding */ unwrapLabelhash),\n/* harmony export */   wrapLabelhash: () => (/* binding */ wrapLabelhash)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../index.js */ \"(ssr)/../../node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Ens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Ens.js */ \"(ssr)/../../node_modules/ox/_esm/core/Ens.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n\n\n/**\n * @internal\n * Encodes a [DNS packet](https://docs.ens.domains/resolution/names#dns) into a ByteArray containing a UDP payload.\n */\nfunction packetToBytes(packet) {\n    // strip leading and trailing `.`\n    const value = packet.replace(/^\\.|\\.$/gm, '');\n    if (value.length === 0)\n        return new Uint8Array(1);\n    const bytes = new Uint8Array(_index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(value).byteLength + 2);\n    let offset = 0;\n    const list = value.split('.');\n    for (let i = 0; i < list.length; i++) {\n        let encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(list[i]);\n        // if the length is > 255, make the encoded label value a labelhash\n        // this is compatible with the universal resolver\n        if (encoded.byteLength > 255)\n            encoded = _index_js__WEBPACK_IMPORTED_MODULE_0__.fromString(wrapLabelhash(_Ens_js__WEBPACK_IMPORTED_MODULE_1__.labelhash(list[i])));\n        bytes[offset] = encoded.length;\n        bytes.set(encoded, offset + 1);\n        offset += encoded.length + 1;\n    }\n    if (bytes.byteLength !== offset + 1)\n        return bytes.slice(0, offset + 1);\n    return bytes;\n}\n/** @internal */\nfunction wrapLabelhash(hash) {\n    return `[${hash.slice(2)}]`;\n}\n/** @internal */\nfunction unwrapLabelhash(label) {\n    if (label.length !== 66)\n        return null;\n    if (label.indexOf('[') !== 0)\n        return null;\n    if (label.indexOf(']') !== 65)\n        return null;\n    const hash = `0x${label.slice(1, 65)}`;\n    if (!_Hex_js__WEBPACK_IMPORTED_MODULE_2__.validate(hash, { strict: true }))\n        return null;\n    return hash;\n}\n//# sourceMappingURL=ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lbnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXVDO0FBQ047QUFDQTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsaURBQWdCO0FBQ2pEO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDLHNCQUFzQixpREFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFnQixlQUFlLDhDQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekMsU0FBUyw2Q0FBWSxTQUFTLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXGludGVybmFsXFxlbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnl0ZXMgfSBmcm9tICcuLi8uLi9pbmRleC5qcyc7XG5pbXBvcnQgKiBhcyBFbnMgZnJvbSAnLi4vRW5zLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEVuY29kZXMgYSBbRE5TIHBhY2tldF0oaHR0cHM6Ly9kb2NzLmVucy5kb21haW5zL3Jlc29sdXRpb24vbmFtZXMjZG5zKSBpbnRvIGEgQnl0ZUFycmF5IGNvbnRhaW5pbmcgYSBVRFAgcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2tldFRvQnl0ZXMocGFja2V0KSB7XG4gICAgLy8gc3RyaXAgbGVhZGluZyBhbmQgdHJhaWxpbmcgYC5gXG4gICAgY29uc3QgdmFsdWUgPSBwYWNrZXQucmVwbGFjZSgvXlxcLnxcXC4kL2dtLCAnJyk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDEpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoQnl0ZXMuZnJvbVN0cmluZyh2YWx1ZSkuYnl0ZUxlbmd0aCArIDIpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGNvbnN0IGxpc3QgPSB2YWx1ZS5zcGxpdCgnLicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZW5jb2RlZCA9IEJ5dGVzLmZyb21TdHJpbmcobGlzdFtpXSk7XG4gICAgICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgPiAyNTUsIG1ha2UgdGhlIGVuY29kZWQgbGFiZWwgdmFsdWUgYSBsYWJlbGhhc2hcbiAgICAgICAgLy8gdGhpcyBpcyBjb21wYXRpYmxlIHdpdGggdGhlIHVuaXZlcnNhbCByZXNvbHZlclxuICAgICAgICBpZiAoZW5jb2RlZC5ieXRlTGVuZ3RoID4gMjU1KVxuICAgICAgICAgICAgZW5jb2RlZCA9IEJ5dGVzLmZyb21TdHJpbmcod3JhcExhYmVsaGFzaChFbnMubGFiZWxoYXNoKGxpc3RbaV0pKSk7XG4gICAgICAgIGJ5dGVzW29mZnNldF0gPSBlbmNvZGVkLmxlbmd0aDtcbiAgICAgICAgYnl0ZXMuc2V0KGVuY29kZWQsIG9mZnNldCArIDEpO1xuICAgICAgICBvZmZzZXQgKz0gZW5jb2RlZC5sZW5ndGggKyAxO1xuICAgIH1cbiAgICBpZiAoYnl0ZXMuYnl0ZUxlbmd0aCAhPT0gb2Zmc2V0ICsgMSlcbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIG9mZnNldCArIDEpO1xuICAgIHJldHVybiBieXRlcztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwTGFiZWxoYXNoKGhhc2gpIHtcbiAgICByZXR1cm4gYFske2hhc2guc2xpY2UoMil9XWA7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwTGFiZWxoYXNoKGxhYmVsKSB7XG4gICAgaWYgKGxhYmVsLmxlbmd0aCAhPT0gNjYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsYWJlbC5pbmRleE9mKCdbJykgIT09IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChsYWJlbC5pbmRleE9mKCddJykgIT09IDY1KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBoYXNoID0gYDB4JHtsYWJlbC5zbGljZSgxLCA2NSl9YDtcbiAgICBpZiAoIUhleC52YWxpZGF0ZShoYXNoLCB7IHN0cmljdDogdHJ1ZSB9KSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGhhc2g7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/ens.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/errors.js":
/*!**********************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/errors.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getUrl: () => (/* binding */ getUrl),\n/* harmony export */   getVersion: () => (/* binding */ getVersion),\n/* harmony export */   prettyPrint: () => (/* binding */ prettyPrint)\n/* harmony export */ });\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ \"(ssr)/../../node_modules/ox/_esm/core/version.js\");\n\n/** @internal */\nfunction getUrl(url) {\n    return url;\n}\n/** @internal */\nfunction getVersion() {\n    return _version_js__WEBPACK_IMPORTED_MODULE_0__.version;\n}\n/** @internal */\nfunction prettyPrint(args) {\n    if (!args)\n        return '';\n    const entries = Object.entries(args)\n        .map(([key, value]) => {\n        if (value === undefined || value === false)\n            return null;\n        return [key, value];\n    })\n        .filter(Boolean);\n    const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);\n    return entries\n        .map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`)\n        .join('\\n');\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUN4QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLGdEQUFPO0FBQ2xCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLElBQUksMkJBQTJCLEVBQUUsTUFBTTtBQUM5RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXGludGVybmFsXFxlcnJvcnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gJy4uL3ZlcnNpb24uanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVybCh1cmwpIHtcbiAgICByZXR1cm4gdXJsO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gcHJldHR5UHJpbnQoYXJncykge1xuICAgIGlmICghYXJncylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhhcmdzKVxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBba2V5LCB2YWx1ZV07XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICBjb25zdCBtYXhMZW5ndGggPSBlbnRyaWVzLnJlZHVjZSgoYWNjLCBba2V5XSkgPT4gTWF0aC5tYXgoYWNjLCBrZXkubGVuZ3RoKSwgMCk7XG4gICAgcmV0dXJuIGVudHJpZXNcbiAgICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiBgICAke2Ake2tleX06YC5wYWRFbmQobWF4TGVuZ3RoICsgMSl9ICAke3ZhbHVlfWApXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/errors.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/hex.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/hex.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assertEndOffset: () => (/* binding */ assertEndOffset),\n/* harmony export */   assertSize: () => (/* binding */ assertSize),\n/* harmony export */   assertStartOffset: () => (/* binding */ assertStartOffset),\n/* harmony export */   pad: () => (/* binding */ pad),\n/* harmony export */   trim: () => (/* binding */ trim)\n/* harmony export */ });\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Hex.js */ \"(ssr)/../../node_modules/ox/_esm/core/Hex.js\");\n\n/** @internal */\nfunction assertSize(hex, size_) {\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex) > size_)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeOverflowError({\n            givenSize: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(hex),\n            maxSize: size_,\n        });\n}\n/** @internal */\nfunction assertStartOffset(value, start) {\n    if (typeof start === 'number' && start > 0 && start > _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) - 1)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: start,\n            position: 'start',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n}\n/** @internal */\nfunction assertEndOffset(value, start, end) {\n    if (typeof start === 'number' &&\n        typeof end === 'number' &&\n        _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value) !== end - start) {\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SliceOffsetOutOfBoundsError({\n            offset: end,\n            position: 'end',\n            size: _Hex_js__WEBPACK_IMPORTED_MODULE_0__.size(value),\n        });\n    }\n}\n/** @internal */\nfunction pad(hex_, options = {}) {\n    const { dir, size = 32 } = options;\n    if (size === 0)\n        return hex_;\n    const hex = hex_.replace('0x', '');\n    if (hex.length > size * 2)\n        throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.SizeExceedsPaddingSizeError({\n            size: Math.ceil(hex.length / 2),\n            targetSize: size,\n            type: 'Hex',\n        });\n    return `0x${hex[dir === 'right' ? 'padEnd' : 'padStart'](size * 2, '0')}`;\n}\n/** @internal */\nfunction trim(value, options = {}) {\n    const { dir = 'left' } = options;\n    let data = value.replace('0x', '');\n    let sliceLength = 0;\n    for (let i = 0; i < data.length - 1; i++) {\n        if (data[dir === 'left' ? i : data.length - i - 1].toString() === '0')\n            sliceLength++;\n        else\n            break;\n    }\n    data =\n        dir === 'left'\n            ? data.slice(sliceLength)\n            : data.slice(0, data.length - sliceLength);\n    if (data === '0')\n        return '0x';\n    if (dir === 'right' && data.length % 2 === 1)\n        return `0x${data}0`;\n    return `0x${data}`;\n}\n//# sourceMappingURL=hex.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9oZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWlDO0FBQ2pDO0FBQ087QUFDUCxRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixzREFBcUI7QUFDdkMsdUJBQXVCLHlDQUFRO0FBQy9CO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLDBEQUEwRCx5Q0FBUTtBQUNsRSxrQkFBa0IsZ0VBQStCO0FBQ2pEO0FBQ0E7QUFDQSxrQkFBa0IseUNBQVE7QUFDMUIsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLHlDQUFRO0FBQ2hCLGtCQUFrQixnRUFBK0I7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQix5Q0FBUTtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sK0JBQStCO0FBQ3RDLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ08saUNBQWlDO0FBQ3hDLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxpbnRlcm5hbFxcaGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEhleCBmcm9tICcuLi9IZXguanMnO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFNpemUoaGV4LCBzaXplXykge1xuICAgIGlmIChIZXguc2l6ZShoZXgpID4gc2l6ZV8pXG4gICAgICAgIHRocm93IG5ldyBIZXguU2l6ZU92ZXJmbG93RXJyb3Ioe1xuICAgICAgICAgICAgZ2l2ZW5TaXplOiBIZXguc2l6ZShoZXgpLFxuICAgICAgICAgICAgbWF4U2l6ZTogc2l6ZV8sXG4gICAgICAgIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydFN0YXJ0T2Zmc2V0KHZhbHVlLCBzdGFydCkge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdudW1iZXInICYmIHN0YXJ0ID4gMCAmJiBzdGFydCA+IEhleC5zaXplKHZhbHVlKSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBIZXguU2xpY2VPZmZzZXRPdXRPZkJvdW5kc0Vycm9yKHtcbiAgICAgICAgICAgIG9mZnNldDogc3RhcnQsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3N0YXJ0JyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RW5kT2Zmc2V0KHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIGVuZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgSGV4LnNpemUodmFsdWUpICE9PSBlbmQgLSBzdGFydCkge1xuICAgICAgICB0aHJvdyBuZXcgSGV4LlNsaWNlT2Zmc2V0T3V0T2ZCb3VuZHNFcnJvcih7XG4gICAgICAgICAgICBvZmZzZXQ6IGVuZCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnZW5kJyxcbiAgICAgICAgICAgIHNpemU6IEhleC5zaXplKHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhZChoZXhfLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGRpciwgc2l6ZSA9IDMyIH0gPSBvcHRpb25zO1xuICAgIGlmIChzaXplID09PSAwKVxuICAgICAgICByZXR1cm4gaGV4XztcbiAgICBjb25zdCBoZXggPSBoZXhfLnJlcGxhY2UoJzB4JywgJycpO1xuICAgIGlmIChoZXgubGVuZ3RoID4gc2l6ZSAqIDIpXG4gICAgICAgIHRocm93IG5ldyBIZXguU2l6ZUV4Y2VlZHNQYWRkaW5nU2l6ZUVycm9yKHtcbiAgICAgICAgICAgIHNpemU6IE1hdGguY2VpbChoZXgubGVuZ3RoIC8gMiksXG4gICAgICAgICAgICB0YXJnZXRTaXplOiBzaXplLFxuICAgICAgICAgICAgdHlwZTogJ0hleCcsXG4gICAgICAgIH0pO1xuICAgIHJldHVybiBgMHgke2hleFtkaXIgPT09ICdyaWdodCcgPyAncGFkRW5kJyA6ICdwYWRTdGFydCddKHNpemUgKiAyLCAnMCcpfWA7XG59XG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBkaXIgPSAnbGVmdCcgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRhdGEgPSB2YWx1ZS5yZXBsYWNlKCcweCcsICcnKTtcbiAgICBsZXQgc2xpY2VMZW5ndGggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKGRhdGFbZGlyID09PSAnbGVmdCcgPyBpIDogZGF0YS5sZW5ndGggLSBpIC0gMV0udG9TdHJpbmcoKSA9PT0gJzAnKVxuICAgICAgICAgICAgc2xpY2VMZW5ndGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRhdGEgPVxuICAgICAgICBkaXIgPT09ICdsZWZ0J1xuICAgICAgICAgICAgPyBkYXRhLnNsaWNlKHNsaWNlTGVuZ3RoKVxuICAgICAgICAgICAgOiBkYXRhLnNsaWNlKDAsIGRhdGEubGVuZ3RoIC0gc2xpY2VMZW5ndGgpO1xuICAgIGlmIChkYXRhID09PSAnMCcpXG4gICAgICAgIHJldHVybiAnMHgnO1xuICAgIGlmIChkaXIgPT09ICdyaWdodCcgJiYgZGF0YS5sZW5ndGggJSAyID09PSAxKVxuICAgICAgICByZXR1cm4gYDB4JHtkYXRhfTBgO1xuICAgIHJldHVybiBgMHgke2RhdGF9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/hex.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/internal/lru.js":
/*!*******************************************************!*\
  !*** ../../node_modules/ox/_esm/core/internal/lru.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LruMap: () => (/* binding */ LruMap)\n/* harmony export */ });\n/**\n * @internal\n *\n * Map with a LRU (Least recently used) policy.\n * @see https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU\n */\nclass LruMap extends Map {\n    constructor(size) {\n        super();\n        Object.defineProperty(this, \"maxSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.maxSize = size;\n    }\n    get(key) {\n        const value = super.get(key);\n        if (super.has(key) && value !== undefined) {\n            this.delete(key);\n            super.set(key, value);\n        }\n        return value;\n    }\n    set(key, value) {\n        super.set(key, value);\n        if (this.maxSize && this.size > this.maxSize) {\n            const firstKey = this.keys().next().value;\n            if (firstKey)\n                this.delete(firstKey);\n        }\n        return this;\n    }\n}\n//# sourceMappingURL=lru.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9pbnRlcm5hbC9scnUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxfZXNtXFxjb3JlXFxpbnRlcm5hbFxcbHJ1LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGludGVybmFsXG4gKlxuICogTWFwIHdpdGggYSBMUlUgKExlYXN0IHJlY2VudGx5IHVzZWQpIHBvbGljeS5cbiAqIEBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FjaGVfcmVwbGFjZW1lbnRfcG9saWNpZXMjTFJVXG4gKi9cbmV4cG9ydCBjbGFzcyBMcnVNYXAgZXh0ZW5kcyBNYXAge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWF4U2l6ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1heFNpemUgPSBzaXplO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuZ2V0KGtleSk7XG4gICAgICAgIGlmIChzdXBlci5oYXMoa2V5KSAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5tYXhTaXplICYmIHRoaXMuc2l6ZSA+IHRoaXMubWF4U2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RLZXkgPSB0aGlzLmtleXMoKS5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICBpZiAoZmlyc3RLZXkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoZmlyc3RLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxydS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/internal/lru.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/_esm/core/version.js":
/*!**************************************************!*\
  !*** ../../node_modules/ox/_esm/core/version.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/** @internal */\nconst version = '0.1.1';\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L19lc20vY29yZS92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXF9lc21cXGNvcmVcXHZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IHZlcnNpb24gPSAnMC4xLjEnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmVyc2lvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/_esm/core/version.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs":
/*!********************************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ens_beautify: () => (/* binding */ ens_beautify),\n/* harmony export */   ens_emoji: () => (/* binding */ ens_emoji),\n/* harmony export */   ens_normalize: () => (/* binding */ ens_normalize),\n/* harmony export */   ens_normalize_fragment: () => (/* binding */ ens_normalize_fragment),\n/* harmony export */   ens_split: () => (/* binding */ ens_split),\n/* harmony export */   ens_tokenize: () => (/* binding */ ens_tokenize),\n/* harmony export */   is_combining_mark: () => (/* binding */ is_combining_mark),\n/* harmony export */   nfc: () => (/* binding */ nfc),\n/* harmony export */   nfd: () => (/* binding */ nfd),\n/* harmony export */   safe_str_from_cps: () => (/* binding */ safe_str_from_cps),\n/* harmony export */   should_escape: () => (/* binding */ should_escape)\n/* harmony export */ });\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-ens data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: 0ca3917bee1eee342d64c631cb1dbaac37b167d848887d59f6d68328dc99ac09\nvar COMPRESSED$1 = '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';\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\n// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4\r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\r\n\r\n\r\nfunction read_trie(next) {\r\n\tlet ret = [];\r\n\tlet sorted = read_sorted(next); \r\n\texpand(decode([]), []);\r\n\treturn ret; // not sorted\r\n\tfunction decode(Q) { // characters that lead into this node\r\n\t\tlet S = next(); // state: valid, save, check\r\n\t\tlet B = read_array_while(() => { // buckets leading to new nodes\r\n\t\t\tlet cps = read_sorted(next).map(i => sorted[i]);\r\n\t\t\tif (cps.length) return decode(cps);\r\n\t\t});\r\n\t\treturn {S, B, Q};\r\n\t}\r\n\tfunction expand({S, B}, cps, saved) {\r\n\t\tif (S & 4 && saved === cps[cps.length-1]) return;\r\n\t\tif (S & 2) saved = cps[cps.length-1];\r\n\t\tif (S & 1) ret.push(cps); \r\n\t\tfor (let br of B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\texpand(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\r\n\r\nfunction array_replace(v, a, b) {\r\n\tlet prev = 0;\r\n\twhile (true) {\r\n\t\tlet next = v.indexOf(a, prev);\r\n\t\tif (next < 0) break;\r\n\t\tv[next] = b; \r\n\t\tprev = next + 1;\r\n\t}\r\n}\n\n// created 2024-09-13T06:42:45.675Z\n// compressed base64-encoded blob for include-nf data\n// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js\n// see: https://github.com/adraffy/ens-normalize.js#security\n// SHA-256: a79d5f9b1879a7b416aa659f4a3d788f80a8cf5f0ab955a456592c02f556a28c\nvar COMPRESSED = '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';\n\n// https://unicode.org/reports/tr15/\r\n// for reference implementation\r\n// see: /derive/nf.js\r\n\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nlet SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;\r\n\r\n// export function nf_deinit() {\r\n// \tif (!SHIFTED_RANK) return;\r\n// \tSHIFTED_RANK = EXCLUSIONS = DECOMP = RECOMP = undefined;\r\n// }\r\n\r\nfunction init$1() {\r\n\t//console.time('nf');\r\n\tlet r = read_compressed_payload(COMPRESSED);\r\n\tSHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\n\tEXCLUSIONS = new Set(read_sorted(r));\r\n\tDECOMP = new Map();\r\n\tRECOMP = new Map();\r\n\tfor (let [cp, cps] of read_mapped(r)) {\r\n\t\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\t\tlet [a, b] = cps;\r\n\t\t\tlet bucket = RECOMP.get(a);\r\n\t\t\tif (!bucket) {\r\n\t\t\t\tbucket = new Map();\r\n\t\t\t\tRECOMP.set(a, bucket);\r\n\t\t\t}\r\n\t\t\tbucket.set(b, cp);\r\n\t\t}\r\n\t\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n\t}\r\n\t//console.timeEnd('nf');\r\n\t// 20230905: 11ms\r\n}\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tif (!SHIFTED_RANK) init$1();\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\nconst HYPHEN = 0x2D;\r\nconst STOP = 0x2E;\r\nconst STOP_CH = '.';\r\nconst FE0F = 0xFE0F;\r\nconst UNIQUE_PH = 1;\r\n\r\n// 20230913: replace [...v] with Array_from(v) to avoid large spreads\r\nconst Array_from = x => Array.from(x); // Array.from.bind(Array);\r\n\r\nfunction group_has_cp(g, cp) {\r\n\t// 20230913: keep primary and secondary distinct instead of creating valid union\r\n\treturn g.P.has(cp) || g.Q.has(cp);\r\n}\r\n\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; } // free tagging system\r\n}\r\n\r\nlet MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;\r\n\r\n// export function ens_deinit() {\r\n// \tnf_deinit();\r\n// \tif (!MAPPED) return;\r\n// \tMAPPED = IGNORED = CM = NSM = ESCAPE = NFC_CHECK = GROUPS = WHOLE_VALID = WHOLE_MAP = VALID = EMOJI_LIST = EMOJI_ROOT = undefined;\r\n// }\r\n\r\nfunction init() {\r\n\tif (MAPPED) return;\r\n\t\r\n\tlet r = read_compressed_payload(COMPRESSED$1);\r\n\tconst read_sorted_array = () => read_sorted(r);\r\n\tconst read_sorted_set = () => new Set(read_sorted_array());\r\n\tconst set_add_many = (set, v) => v.forEach(x => set.add(x));\r\n\r\n\tMAPPED = new Map(read_mapped(r)); \r\n\tIGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints\r\n\r\n\t/*\r\n\t// direct include from payload is smaller than the decompression code\r\n\tconst FENCED = new Map(read_array_while(() => {\r\n\t\tlet cp = r();\r\n\t\tif (cp) return [cp, read_str(r())];\r\n\t}));\r\n\t*/\r\n\t// 20230217: we still need all CM for proper error formatting\r\n\t// but norm only needs NSM subset that are potentially-valid\r\n\tCM = read_sorted_array();\r\n\tNSM = new Set(read_sorted_array().map(i => CM[i]));\r\n\tCM = new Set(CM);\r\n\t\r\n\tESCAPE = read_sorted_set(); // characters that should not be printed\r\n\tNFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations\r\n\r\n\tlet chunks = read_sorted_arrays(r);\r\n\tlet unrestricted = r();\r\n\t//const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));\r\n\tconst read_chunked = () => {\r\n\t\t// 20230921: build set in parts, 2x faster\r\n\t\tlet set = new Set();\r\n\t\tread_sorted_array().forEach(i => set_add_many(set, chunks[i]));\r\n\t\tset_add_many(set, read_sorted_array());\r\n\t\treturn set; \r\n\t};\r\n\tGROUPS = read_array_while(i => {\r\n\t\t// minifier property mangling seems unsafe\r\n\t\t// so these are manually renamed to single chars\r\n\t\tlet N = read_array_while(r).map(x => x+0x60);\r\n\t\tif (N.length) {\r\n\t\t\tlet R = i >= unrestricted; // unrestricted then restricted\r\n\t\t\tN[0] -= 32; // capitalize\r\n\t\t\tN = str_from_cps(N);\r\n\t\t\tif (R) N=`Restricted[${N}]`;\r\n\t\t\tlet P = read_chunked(); // primary\r\n\t\t\tlet Q = read_chunked(); // secondary\r\n\t\t\tlet M = !r(); // not-whitelisted, check for NSM\r\n\t\t\t// *** this code currently isn't needed ***\r\n\t\t\t/*\r\n\t\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t\tlet M = r()-1; // number of combining mark\r\n\t\t\tif (M < 0) { // whitelisted\r\n\t\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\t\tlet i = r();\r\n\t\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t\t})];\r\n\t\t\t\t}));\r\n\t\t\t}*/\r\n\t\t\treturn {N, P, Q, M, R};\r\n\t\t}\r\n\t});\r\n\r\n\t// decode compressed wholes\r\n\tWHOLE_VALID = read_sorted_set();\r\n\tWHOLE_MAP = new Map();\r\n\tlet wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a-b); // must be sorted\r\n\twholes.forEach((cp, i) => {\r\n\t\tlet d = r(); \r\n\t\tlet w = wholes[i] = d ? wholes[i-d] : {V: [], M: new Map()};\r\n\t\tw.V.push(cp); // add to member set\r\n\t\tif (!WHOLE_VALID.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t\t}\r\n\t});\r\n\r\n\t// compute confusable-extent complements\r\n\t// usage: WHOLE_MAP.get(cp).M.get(cp) = complement set\r\n\tfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t\t// connect all groups that have each whole character\r\n\t\tlet recs = [];\r\n\t\tfor (let cp of V) {\r\n\t\t\tlet gs = GROUPS.filter(g => group_has_cp(g, cp));\r\n\t\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\t\tif (!rec) {\r\n\t\t\t\trec = {G: new Set(), V: []};\r\n\t\t\t\trecs.push(rec);\r\n\t\t\t}\r\n\t\t\trec.V.push(cp);\r\n\t\t\tset_add_many(rec.G, gs);\r\n\t\t}\r\n\t\t// per character cache groups which are not a member of the extent\r\n\t\tlet union = recs.flatMap(x => Array_from(x.G)); // all of the groups used by this whole\r\n\t\tfor (let {G, V} of recs) {\r\n\t\t\tlet complement = new Set(union.filter(g => !G.has(g))); // groups not covered by the extent\r\n\t\t\tfor (let cp of V) {\r\n\t\t\t\tM.set(cp, complement); // this is the same reference\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// compute valid set\r\n\t// 20230924: VALID was union but can be re-used\r\n\tVALID = new Set(); // exists in 1+ groups\r\n\tlet multi = new Set(); // exists in 2+ groups\r\n\tconst add_to_union = cp => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);\r\n\tfor (let g of GROUPS) {\r\n\t\tfor (let cp of g.P) add_to_union(cp);\r\n\t\tfor (let cp of g.Q) add_to_union(cp);\r\n\t}\r\n\t// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\n\tfor (let cp of VALID) {\r\n\t\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t\t}\r\n\t}\r\n\t// add all decomposed parts\r\n\t// see derive: \"Valid is Closed (via Brute-force)\"\r\n\tset_add_many(VALID, nfd(VALID));\r\n\t\r\n\t// decode emoji\r\n\t// 20230719: emoji are now fully-expanded to avoid quirk logic \r\n\tEMOJI_LIST = read_trie(r).map(v => Emoji.from(v)).sort(compare_arrays);\r\n\tEMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)\r\n\tfor (let cps of EMOJI_LIST) {\r\n\t\t// 20230719: change to *slightly* stricter algorithm which disallows \r\n\t\t// insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)\r\n\t\t// example: beautified [A B] (eg. flag emoji) \r\n\t\t//  before: allow: [A FE0F B], error: [A FE0F FE0F B] \r\n\t\t//   after: error: both\r\n\t\t// note: this code now matches ENSNormalize.{cs,java} logic\r\n\t\tlet prev = [EMOJI_ROOT];\r\n\t\tfor (let cp of cps) {\r\n\t\t\tlet next = prev.map(node => {\r\n\t\t\t\tlet child = node.get(cp);\r\n\t\t\t\tif (!child) {\r\n\t\t\t\t\t// should this be object? \r\n\t\t\t\t\t// (most have 1-2 items, few have many)\r\n\t\t\t\t\t// 20230719: no, v8 default map is 4?\r\n\t\t\t\t\tchild = new Map();\r\n\t\t\t\t\tnode.set(cp, child);\r\n\t\t\t\t}\r\n\t\t\t\treturn child;\r\n\t\t\t});\r\n\t\t\tif (cp === FE0F) {\r\n\t\t\t\tprev.push(...next); // less than 20 elements\r\n\t\t\t} else {\r\n\t\t\t\tprev = next;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (let x of prev) {\r\n\t\t\tx.V = cps;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error(`invalid label extension: \"${str_from_cps(cps.slice(0, 4))}\"`); // this can only be ascii so cant be bidi\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// if cps exceed max, middle truncate with ellipsis\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tif (cps.length > max) {\r\n\t\tmax >>= 1;\r\n\t\tcps = [...cps.slice(0, max), 0x2026, ...cps.slice(-max)];\r\n\t}\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\n// note: Object.freeze() doesn't work\r\nfunction is_combining_mark(cp, only_nsm) { // 20240127: add extra argument\r\n\tinit();\r\n\treturn only_nsm ? NSM.has(cp) : CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\tinit();\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\tinit();\r\n\treturn EMOJI_LIST.map(x => x.slice()); // emoji are exposed so copy\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tinit();\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat())).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(split(name, nfc, filter_fe0f));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet labels = split(name, nfc, x => x); // emoji not exposed\r\n\tfor (let {type, output, error} of labels) {\r\n\t\tif (error) break; // flatten will throw\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t// https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(labels);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\treturn split(name, nfc, preserve_emoji ? x => x.slice() : filter_fe0f); // emoji are exposed so copy\r\n}\r\n\r\nfunction split(name, nf, ef) {\r\n\tif (!name) return []; // 20230719: empty name allowance\r\n\tinit();\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = tokens_from_str(input, nf, ef);\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} \r\n\t\t\tlet norm = info.output = tokens.flat();\r\n\t\t\tcheck_leading_underscore(norm);\r\n\t\t\tlet emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);\r\n\t\t\tif (!emoji && norm.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\tcheck_label_extension(norm); // only needed for ascii\r\n\t\t\t\t// cant have fenced\r\n\t\t\t\t// cant have cm\r\n\t\t\t\t// cant have wholes\r\n\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\ttype = 'ASCII';\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// 5.) \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\tlet unique = Array_from(new Set(chars));\r\n\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = [];\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : Array_from(set);\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaining groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => group_has_cp(g, cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => group_has_cp(g, cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (!GROUPS.some(g => group_has_cp(g, cp))) { \r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\t// 20230716: change to more exact statement, see: ENSNormalize.{cs,java}\r\n\t\t\t\t// note: this doesn't have to be a composition\r\n\t\t\t\t// 20230720: change to full check\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp)); // only check primary\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tfor (let cp of cps) {\r\n\t\tif (!group_has_cp(g, cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (g.M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\n// 20230818: rename for 'process' name collision h/t Javarome\r\n// https://github.com/adraffy/ens-normalize.js/issues/23\r\nfunction tokens_from_str(input, nf, ef) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(ef(emoji));\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps); // less than 10 elements\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\t// 20230912: unicode 15.1 changed the order of processing such that\r\n\t\t\t\t\t// disallowed parts are only rejected after NFC\r\n\t\t\t\t\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t\t\t\t\t// this doesn't impact normalization as of today\r\n\t\t\t\t\t// technically, this error can be removed as the group logic will apply similar logic\r\n\t\t\t\t\t// however the error type might be less clear\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet pos = cps.length;\r\n\twhile (pos) {\r\n\t\tnode = node.get(cps[--pos]);\r\n\t\tif (!node) break;\r\n\t\tlet {V} = node;\r\n\t\tif (V) { // this is a valid emoji (so far)\r\n\t\t\temoji = V;\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // (optional) copy input, used for ens_tokenize()\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\treturn emoji;\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tinit();\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({\r\n\t\t\t\ttype: TY_EMOJI,\r\n\t\t\t\temoji: emoji.slice(), // copy emoji\r\n\t\t\t\tinput: eaten,\r\n\t\t\t\tcps: filter_fe0f(emoji)\r\n\t\t\t});\r\n\t\t\teaten = []; // reset buffer\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9AYWRyYWZmeS9lbnMtbm9ybWFsaXplL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0JBQXNCO0FBQ3RCLGtCQUFrQjtBQUNsQixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSCxVQUFVO0FBQ1Y7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxFQUFFLFlBQVksR0FBRyw4QkFBOEIsRUFBRTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QixlQUFlO0FBQ2Y7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGtCQUFrQjtBQUNsQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0wsSUFBSTtBQUNKLFdBQVc7QUFDWDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLGdCQUFnQjtBQUNoQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsWUFBWSxNQUFNO0FBQ2xCLDJEQUEyRDtBQUMzRDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQSxxQ0FBcUMsa0NBQWtDO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsOEJBQThCLEtBQUs7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSztBQUNqRDtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLElBQUksTUFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxXQUFXLHFCQUFxQjtBQUNoQyxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QyxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLGdEQUFnRDtBQUNoRDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBEQUEwRDtBQUMxRCx5QkFBeUI7QUFDekI7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHFCQUFxQixpQkFBaUIsT0FBTztBQUM3QztBQUNBLDZDQUE2QztBQUM3QztBQUNBLHlEQUF5RCwyQkFBMkIsSUFBSSw0QkFBNEI7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVEsR0FBRyxJQUFJO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBLGdDQUFnQztBQUNoQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHNDQUFzQyxJQUFJLElBQUk7QUFDNUc7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxjQUFjO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLGNBQWMsTUFBTSxFQUFFLE9BQU87QUFDN0I7QUFDQSxzQ0FBc0MsS0FBSyxJQUFJLE9BQU87QUFDdEQ7QUFDQTtBQUNBLHdDQUF3QyxNQUFNO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsS0FBSyxJQUFJO0FBQzlGO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFlBQVk7QUFDWjtBQUNBLHlDQUF5QyxPQUFPLE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUssRUFBRSxpREFBaUQsR0FBRyxJQUFJLEdBQUcsRUFBRTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUFzQztBQUN2RDtBQUNBLHFCQUFxQixPQUFPLE9BQU87QUFDbkM7QUFDQSx1REFBdUQsY0FBYztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxzREFBc0QsR0FBRyxJQUFJLEdBQUcsUUFBUTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGdDQUFnQztBQUN2RztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixRQUFRLEtBQUssSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSyxhQUFhLE9BQU87QUFDMUQsOENBQThDLFFBQVEsWUFBWSxJQUFJO0FBQ3RFLHdCQUF3QixLQUFLLGtCQUFrQixPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx1Q0FBdUMsS0FBSyxJQUFJLEdBQUcsRUFBRTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVixXQUFXO0FBQ1g7QUFDQSx1REFBdUQ7QUFDdkQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixlQUFlO0FBQ2YsSUFBSTtBQUNKO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DLEtBQUs7QUFDTCxpQkFBaUIsMEJBQTBCO0FBQzNDLEtBQUs7QUFDTCxpQkFBaUIscUJBQXFCO0FBQ3RDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0JBQWtCLHNDQUFzQztBQUN4RCxNQUFNO0FBQ04sa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQjtBQUNqRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0EseUJBQXlCLHFCQUFxQixTQUFTO0FBQ3ZELFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdDQUFnQztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsVUFBVTtBQUMxRCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsbUJBQW1CO0FBQ25CO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixnQkFBZ0I7QUFDaEI7QUFDQSxLQUFLLHNDQUFzQztBQUMzQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQTREO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBOztBQUVrSyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcbm9kZV9tb2R1bGVzXFxAYWRyYWZmeVxcZW5zLW5vcm1hbGl6ZVxcZGlzdFxcaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNyZWF0ZWQgMjAyNC0wOS0xM1QwNjo0Mjo0NS42NzVaXG4vLyBjb21wcmVzc2VkIGJhc2U2NC1lbmNvZGVkIGJsb2IgZm9yIGluY2x1ZGUtZW5zIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogMGNhMzkxN2JlZTFlZWUzNDJkNjRjNjMxY2IxZGJhYWMzN2IxNjdkODQ4ODg3ZDU5ZjZkNjgzMjhkYzk5YWMwOVxudmFyIENPTVBSRVNTRUQkMSA9ICdBRWtVNEFuZ0RWZ0IwUUtSQVFZQk93RHFBVEVBbndEYkFJVUFwQUJzQU9BQWJ3Q1JBRVlBaVFCUEFIWUFQZ0ErQUNzQU53QWxBR01BSHdBdkFDc0FKUUFXQUM4QUd3QWlBQ0lBTHdBVUFDc0FFUUFpQUFzQUd3QVJBQmNBR0FBNkFDa0FMQUFzQURVQUZnQXNBQkVBSFFBaEFBOEFHd0FkQUJVQUZnQVpBQTBBRFFBWEFCQUFHUUFVQUJJRXFnWUpBUjRVRmpmREJkTUFzUUN1UHdGbkFLVUJBMTBqQUs1L0x5OHZMd0UvcHdVSjYvMEhQd2JrTVFWWEJWZ0FQU3M1QVBhMkVRYkl3UXVVQ2tFRHlKNHpBc1VLTHdLT29RS0cyRCtPYjRrQ3hjc0NnL0lCSDk4SkFQS3RBVUVDTFkwS1A0OEE0d0RpQ2hVQUY5UzV5QXdMUFowRUczY0EvUUk1R0wwUDZ3a0dLZWtGQklGbkRSc0hMUUNyQUdtUjc2V2Nmd0JiQnBNakJ1a0FHd0E3REpNQVd4VmJxZnU3NXd6YklNOEl1eWtEc1JRN0FQY3RhNk1Bb1gwWUFCY0VKZGNXQVIwQXVSbk5CUG9KSUV3M0NaY0ppQjRiVmxsTTQ0TkNBQk1BREFBVkFBNXJWQUFoQUE0QVIrNFYyRDN6T1ZqS2xlWXVDaEFkWDAxWVBld0FFd0FNQUJVQURtc2dYRUNYQU1QckFCc0FPUXpGQUJzVlc2bjdBZHE0SEIwRld3WGlBdENmQXNTd0Nrd2NwR1VVY3hwdFRQVUF1dzFuQXVFQUN5MDBpUmZKa1FLQmV3RVRHd0M5RFdjQzRRQUxMUUZJVUNXUlRBb0RMZnNGTWduWGFSZXRBZGREQUVrckVuY0NNUlloQXVzbnVUZHJBRG5oQWZVbEFNY095N1VCRzJPQkFMRUZBQVVBaXROSkJSdkRId2NYQUtnbjBRR2hLeTBEbXdCbkFRb1pQdTAzZEFRWUZ3Q3FBY2NDSVFEVEt4SnpPdk5Rc0FXUU9uY25OVWdGK2ljRldRVllyN2dGYVR0ZFFoSTZXRUdYZTVObVg2SDRDeE1EeFFjbDhYY2pCS05MQWxOVEFuVWJxeWNCajZPbE5Wc0RSUmNFZzJFSkFORUdxejh2SXdjcEFqbGRBR3NCWVI5eEFJTWRHUUNWQVVtM0FDZHBGd0d2eFFNM0xTRkRVd0Z2V1FabEFtVUE4VWtYQXlrQkJRQkpRUUNyQUYwQWN3QXJ0UVlIOCs4WmpYOEFDU0VBS1FDekcwY0IwUUhiQndzeGwzaUI2QUFLQUJFQU5BQTlBRGd6ZDNuVHdCQmZFRndCVFFsTWJEb1ZDd0tzRDZZTDVSRVZETkVxeTlQWUFEU3BCK3NEVXdmckExTURVd2ZyQitzRFV3ZnJBMU1EVXdOVEExTWNDdkFhMDhBUVh3OUlCRzBGamdXTEJOWUlneVpKRVlFSEtBalNWQTEwSGh4SEEwVUEvQ01sU1J3N2t6TUxKVUpNREUwREIvdzJRbXluZlRnRFJ6R3JWUFdRb2dQTE1rODViQUVlY1JLZ0FDb1BjeHcxdFU1K2VrZHhvQXBMVDY2MWYwbGlUbWNDdmpxb1AvZ0tJUW1UYjd0M1RnWTlFQmNub1JEekRDOEJzUUUzRGVsTDFBVHRCamNFeFI5NUdSVVB5WldZQ0tFdDJRenBKdDh1bllCV0kvRXFmd1hwUy9BODJRdEpVV1FQVlF0aENkODZYNEZLQXgwQkNTS0hDdGtOTlFocEVPOEt4V2NONFJGQkJ6VUQwVW1XQUtFRy9Rc05IVEVWc1NZTVlxZ0xCVGx6QnZjYThndUxKcXNUSlhyNEJjOGFIUVpKQVNVYSt3RExMdU9GckZvdFhCaFBXd1gvQ3lFand4U2tVQndOSVVDemVFUWFGd2NSSmFVQ2pVTnNTb05STWg2UElmSThPUTFpTGc5UmVBZnhQQUVaU3d0OVBKcEdwMFVLRWM0K2lUMUVJa1ZNS0FReGV5d3JKNGNKeXcrQkRMVjhiZ0ZWQ1IwSnJReHRFeTBSRXpmQkNEVUhGU21YSUNjUkNCMUdrV0NXQlBPYkErOFR6UU1IQlRzSlBRY1BBN0VjS1JNcUZTVUZDWUVnMHdMdk50RXVyd0tMVm53QkV3WEhEeUVmMnhCTVI5d081UWlYQW1FRGZ5WG5BQ2tWSFFBVElwY0lQMThBVzQvVVV3RXV4d2pEYW1namNBTmpGT05kRVc4SGpRNVRCNk1jTHhXN0hOMXd4RjRIaGdRb242c0pWd0Z4Q1pVQld3VGZDQVUxVjR5Y0lEMW5UNHRVR0pjZ1hVRTdYZmdDTFF4aEZadEV1WWQwQW9jUFp4SVhBVEVCYndjMURQMENjeEhwRVdjUWtRam5oZ0Exc1RQME9pRUVTeUYvSUEwS0l3TkxiTW9MSXliMURQUmxBWjhTWGdNSU5EbDM2bWVuWUxJZ0Yva0hGVExCUVZ3aDdRdU9UOGtNbUJxOUdENVVLaG5nQjdzRDd4cnZKK1pCVXdYN0E1OFBPa2t6NmdTNUMyVUlod2s3QUVVT254TUgweGhtQ20yTXpBRXRod0d6bFFOVGpYOENhNHNHTXdjSEFHTUhnd1YxNFFBWkFxTUlud0FCQU1zRFV3QTFBcWtIbVFBVkFJRTlBVGtESXlzQkhlRUNpd09QQ0MzSEFaRXJBZThsQkJlL0RCRUE4ek51UmdMRHJRS0FabWFlQmRsVUFvb0NSVEVCU1NFRUFVcERUUU9yYmQwQTF3QkhCZy9iUXdFUnAwYkhGdDgvQWR0ckp3RERBUGNBQVRFSEFUMEJ5UUh2YVFDekFWc0xMUW1lcjdFQlNlVWxBSDhBRVdjQjB3S0ZBTmtBTVFCNzdRRlBBRWtGVmZVRnp3SkxSUUVOTFJRblUxMEJ0d01iQVM4QkNRQjFCc2VKb2NVREd3UnBCODhDRUJjVjNRTHZLZ2V4QXlMYkU4bEN3UUs5MmxFQU1oSUtOQXExQ3JRZlgvTmNMd0l0YmoxTUFBb2ZwRDdEUDBvRlRUdFBPMVE3VHp0VU8wODdWRHRQTzFRN1R6dFVBNU83M3J2ZUNtaGZRV0huREtJTjBFVEVPa1VUMTJCTllDNFR4QzJ6RkwwVnlpVlNHVGthdUNjQkplQlZCUThBTGM5bUxBZ29OSEVYdUFBN0tXU0RQV09DSGl3S1J4empVNDFVOUMwWEFLMUxuak9yRGFnYkVVUThCVU4xNldJbUZnb0tIZ0prZlFKaVBsZEpxMWMzSEFLaDh3Sm9sQUptQlFLZmdEZ1hCd0ptTndKbUlnUnFCSHNEZnc4RGZvNDVBamx6RXpsK09oOGZBbXdaQWpJeU9BWUNiY01DYmFycmhpOWpRU2NCWXdEYUFOMEFSZ0VIbEF5SkFQb0h2Z0FKc1FKM0t3SjJuanNDZVVjL0FuaTJHVmpYUmFwRzB3SjhPd0o2eEFKOUJRSjg3QVZWQlJ4SC9FaDVYeUFBSnhGSlZFcFhFUk5LeUFMUS9RTFF5RXNqQTRoTEE0ZmlSTUdSTGdMeW5Wei9Bd09xUzhwTUtTSExUVWhOcXdLTE93S0sxTDBYQXhrL1l3R3pBbzR6QW81WVBKTjlBbzdWQW81WWRGR3dVekVHVXRCVWdRS1Q5d0tUQ0FEbEFCaFZHbFdyVmN3Q0xCY3BrWUl5M1hoaVJUYzFBcGViQXUrdVdCMmtBRlVoQXBhTEFwWjRtQUNsV2FoYUJYMUpBRGNDbHJFQ2xrcGNRRnpOQXBuSEFwbGdYTVpkQXhVQ25KYzV2anFaQXB3U0FwK1hBcDYwaGdBWkN5MG1Dd0tkN1FLZWpnQ3hPV0V3WWVzQ25zOENvR29CcFFLZW14c0Nua3FoWThSa0l5RW5BaWVyQWlaNkFxRDNBcUJJQXFMWkFxSEFBcVlyQXFYS0FxZjdBSGtDcCs1b2VHaXQvMFZxR0dyTkFxemZBcXlxQXExakFxeitBbGNaQWxYWUFySGQwd01mU215VEFySzVDUUt5NUJOczNHMWZiVVJiQXlYSkFyWllOenR1akFNcFFRSzRXZ0s1UXhFQ3VTWnpjREp3M1FLOUZRSzcxbkNTQXpJTkFyNkVjZjRETTIwQ3ZoWnpIbk5MQXNQSEFzTUFjMzUwUnpGQmROd0RQS01EUEpZRFBic0N4WGdDeGtNQ3hneUZBc2hsVFFMSVFBTEpTd0xKS2dKa21RTGR6bmgxWFhpcWVTRkx6QU1ZbjJiK0FtSHdHZStWSUhzSFhvNWV0dzBDejJjQ3oyZ3JSMC9PN3crYkFNS3BBczl2QVNYbUEwNE9ma2NCQXR3akF0dUdBdEpMQTFKWUExTmJBUDBEVllpQWhUdkhFdWxjUVlJWWdzK0N5b09KQXRyREF0bmFoQXlFUmFjNEE0YWhBQ3NEWkFxR2JWWDFBRkVDMzJFQzNyUnZjd0xpSyswUUFmTXNJd0gwbHdIeXpvTUM2KzhDNld4MUF1cjFBdXJnQVBWREFiVUM3b1VDNjVpV3BwYi9BdTQ3QTRYY21IVnczSEdkQXZML0FHVURqaEtaandMM0R3T1JhZ09TZ3dMM2xBTDUxUUw0WXBvWW1xZTNNNXNhQTUxL0F2NzJBUmNBTlo4WW42OERCWWtEcG1ZRHB0VUF6Y0VEQm1haGhLSUJCUU1NUlFFTEFSc0hhUVpkdFdNQkFMY0VaN3NOaHg2dkNRQVRjVFVBSHdNdkVra0RoWHNCWHlNZEFJenJBQjBBNXA4RG00MElzd1libjhFQXB3VVJ1K2tkUFQ0V2VBVm9OejVBSzBJaFFyUmZjUkZmdkFDV3hRVXlBSkJNR1p1NU95WmdNaEc2enc0dkdNWVlpY24yQlZjRldBVlhCVmdGWXdWWUJWY0ZXQVZYQlZnRlZ3VllCVmNGV0VZVkNOZUZad0lDQWdwa1h1a3JCTWtEc1FZdnU3c0F1d1NudXdEblFDa1dzZ1ZHUG1rK2NFSS9RclpmZFRkZjZBQllFVE9yQUl6K3pHdkwvS2JuUm5vOUppTUVLeFluTmpWK2JkOXF3ZkVad2l4cEFXdlhiakFYQlY4RmFzbkJ5YmdJejBsYkFBQUFDbnhlZll1K0FETS9nUUFERnRFRzVhMGpCUUNNd3dzREFRMEE1V1VkUFNRZlNrS3hRcnhCT0NOZkoyQTJKemdqQ2NFOUNrUS9RejU0UG9FK2NENXhBb2xDdkVsQ08xL0xUazlxVFFvc2ExUXZhZ3R1SDEvZ016b2JDV2ViQ21Jakt6d2RKa0tyUXJ3cnpBSEwvRi9KRGg4dUNRZ0pJbjZkMzJvNkxVb1h5YXZKckFsbHdjdk1DbUJCWHcvbEVLTVJBSk9OSFVWQ0pSdXBiVG5PT0FvelAwTStjRUkvSEFjS0hVeEhiRnNzTFZyaHZCSUtmZTBkSzBJL0hGMElTZ2tPTTFSRFFqY0VPME9jTEFxQkd5MUNQeHYxQ0ZNaUl4Z3dNUUFGajJId1hncHhaTWxnQzJBdEkyNURZQms1QWhzZVlMTUdBbXNRWlU1Z1RSRUJaT2RnRldDVllIMWdzMkJMWUpGb0ZoY0d0UTdjVmFtOFdndERGcXNCdXl2TndRSWZGUUFjQXg0QmVRSnNMekNWVW9BQmlncTRSeG9BNUNOMGpncktEYVpONmdHYkFvZWNUd1ZBWHdEMzl3a0FOQlpYREF1bERDUWZ1cTlIQUU4TU5BQVZFNThyZ2doNkF0SUxTMlVSR3dEWVRnWjFCQW9lV2dBeEFMYTRBWm9uQ3hadnF5UTRueGtCV3dHR0Nmd0QyZTBQQnFvR1NnYTVBQjNMVmFsYUNidGhFNGtMTFQ4T3V3RzdBU0lDUjFvb0tDZ2dIaDhoTEJJbUJpRU1qUUJVQW01WGtFbVZBVzRmRDNGSEFkTjFEODVSSUJtcHNFM3FCeEVGVEY4QTkvY0tBSG9HSkd3S0t3dWxPREF0eDY5V0RRc0FYN3dMQUdOQWxRaDZBT3BON3lJYnZ3QXhBTGE0QVpvbkxUc096Z0tRR0h0UXUxaklkSEtPMTZXYkR2V1pGVDBiN0FFcEVGd1NCZzhiQWNjSk9oQ1RCUkFyRERZTEFCRUFzODRCQWdDa0FPRUFtSUlBQld0WEx3QVVBRnNieGk1c2Rpb053UkFDT3lRejArRWNIZ3NiZlFKN0xzNmhIQVRCQ3FyeGJBQTNPUzBPcGdlN0NRQVFPaTdPRVJrQWZhdmFIQSs3R2tjY3phRjNIZ0U5S2w4Y0F1dWdDQUhDQVVMejVCOWxBYjRKdHd6NkNEd0tQZ0FGd0FzOUFrc051d2k4RFR3S3ZDN09vU29KUEE2N0JaZ0JHMnNLRDRzYTRRSERBUkVMdXhZN0FLQUxPeEM3QkJpZ2U5d0FPMnNNUEFBQ3BnbThCUnZROVFVQnZnSDZic29HZXdBSHV3RzdEMDBSRXJ3QkFRRHFBUUFBZEJWYkJoYkxGUHh2RjdzWU93QXV1d0xyRGxhb3V3QWV1d0pWSUNwL0FBRzdBQUxqQUFnN0ZUd1Z1d0FidXdHOUtPQ2xXdzYveEFEMEFHajdMN1p0dmdOSW83dklxRHNEQWJ1Vkowc0FBbHNBQ3JzRUFPZmRHYnNJR25zSW9RVUsvM0FBMzd1bnV4amJHcnVqaTNseUJ2dXBtNE1BRXJzR0d3c0J2QUFBaGdCdHV3WUFDN3VuT3dFYU83b0lvWnpLQWJzTDdRZkFxVHNBNFhzQnZ3QUE1UUFWdXdBRyt3QUp1d0JwaXdBYXV3QU91d0lZdTQ1cEZmc0FBVnNBRG1zQUxrc2VBQWE3QUJlN0NDRUFEVW9Cd2dDM3J5WUJ3QUFBdEFBT213RytKK1FBc2xvQUhCc0J2LzdoQ3FFQUJjWUxGUlhiQUFlYkFFSzdBUUlBYWJzQUMzc0FIYnNBQ0xzSm9RQUZ5Z0J1bnhuVkFKRUlJUUFGeWdBQk93QUgyd0FkbXdnaEFBYWFBQWw3QUJzckFHMGJBT2E3Z0FBSVd3QVV1d2toQUFiS0FPT0xBQWs3QzZFT3hQdGZBQWM3QUc2Y1FFZ0FSd0FET3dBSnJRTTNBQWNiQUJsN0Fidi9BYWI3QUFvYkFBbzdBQW43cCtzR3V3QUpHd0FEQ3dBUU93QUFGRHNBRVdzQUQ0c0FEZXNBRGJzQUdRc0dGaHNBRlRzQWJwc1dzd0c3QUxvQUV6c0RBR2tyQ2dEaFN3QUNPd0FFVWdBWGV3VWJBQWJRQUJpN0FBdjdBRis3QUd2N0FPU0xBYnNBRjNZQnZBQUJjZ3VoQUFWS0hnRjdLRklBT1VVQS9nY05ESElBS0Nwd0FhUUZDRjRCdkY0akRBa0hiMHRzWHlxSkh6d1VZaTAyQTZFS3RBSFlBQllDMFFOdUFYWnlSMUlVSVFOUEFoVStBU3dHQTNOR3ZIdFNla0FBS1FBeEFmc0FVd3JiQUh1UUxBRXJBSGJsRFJFeVJnRktBRmNGQUFGUUFRZUt6QUI0T3dRZ3BRQmFBTllWQUpWb054K0xBTTFyc1FEUDFCWUl3blZ6R3hoV0hRblJBWWlRcXlKVFUwMUlFanpDaWZrQWZ4dzNRQ2tyNEJHWFR3QnlBU2tzTUNsQ0dROERNRlVFOThYdUFFdGwzQUJxQW5FQ1B4RjZPc2Q0TGpYVkJnVUFFQnNkQ2dnTUtnUWZIU2xPVTA0SXVib0FDaExOQUNZQUFSb0FoZ0NKQUk0MUFPNEF0QURnQUowOEFMc0Fxd0NtQUtFQThnQ2ZBTk1BbkFEckFRd0JCd0RBQUhrQVdnRExBTTBCQndEWEFPc0FpQUNpQVRVQTR3RFlBTlVEQVFjcU05VFUxTlMyd056TjBNNURNaGNCVFFGWEwwY0JWUUZrQVdNQlZnRkhTME5GYUEwQlRoVUhDQU15Tmd3SEFDSU5KQ1lwTERnNk9qMDlQVDQvRGtBZVVWRlJVVk5UVWxNcFZGVlhWbFljWFdGaFlHSmhJMlpvY0c5eWNuSnljbkowZEhSMGRIUjBkSFIwZEhaMmQzWjFXd0JBN0FCRkFKWUFkQUF1QUdMeUFJb0FVd0JUQURNQ2Mra0FoLy95OGdCZ0FJL3NBSnNBU3dCZUFHRDUrYW9BZ1FDQkFHVUFVZ0N0QUI0QXNnQi9BandDUHdENEFPTUErZ0Q2QU9RQSt3RGxBT1VBNUFEaUFDa0Nkd0ZOQVR3Qk9nRlFBVG9CT2dFNkFUVUJOQUUwQVRRQkdBRlVEd0FyQ0FBQVRSY0tGZ01WRmc0QWlnQ1NBS0lBU3dCa0dBSXRBSEFBYVFDUkF4SURKQ29ESGtFK1J5a0Fpd0pMQU1NQ1V3S2dBTG9Da2dLU0FwSUNrZ0tTQXBJQ2h3S1NBcElDa2dLU0FwSUNrZ0tSQXBFQ2xBS2NBcE1Da2dLU0FwQUNrQUtRQXBBQ2pnS1JBbkVCMEFLVEFwc0NrZ0tTQXBFV2VRc0ErZ1VEcHdKZEFqWVhBVkFRTlFMZUVRb3JFd0ZLTnhOTmtRRjNwRHdCWlZrQS93TTlSd0VBQUpNcEhoaVBhZ0FwWUFCcEFDNEFpUU9Vekl2d3JvUmFCYm9yRHNJUkFaM1ZkQ29MQkNNeGJBRXpXbXdCc2dEZGZvQi9mb0IrZ1lLQ2ZvT0doSDZGaUlhQWg0S0lnb2wraW42TGZveUtqWDZPZm8rQ2tINlJmcEorazM2VWc1V0lsb0tYZnRvQzJXemhBdGRzQUlKc0pHeWdBSU5zYkFSQ0JEOEVRUVJFQkVJRVNBUkZCRUFFUmdSSUJFY0VRd1JGQkVnQWxtWnNBS01EaDJ3QXRHWUJCV3dBeVZGc2JBRFBiQUlNYkFEMldtd0E5Z0VaQVBZQTlBRDBBUFVBOUFOOFhtelVoQ05sdndEMkFQUUE5QUQxQVBRY2JHd0FpVnBzQVBZQWlRRVpBUFlBaVFMc0FQWUFpUU44WG16VWhDTmx2eHhzQVBkYWJBRVpBUFlBOWdEMEFQUUE5UUQwQVBjQTlBRDBBUFVBOUFOOFhtelVoQ05sdnh4c2JBQ0pXbXdCR1FEMkFJa0E5Z0NKQXV3QTlnQ0pBM3hlYk5TRUkyVy9IR3dDUXdFMmJBSktBVGxzQWt2QmJHd0NWMnhzQTU0QzdBT2VBNTREbndPZkE1OERud044WG16VWhDTmx2eHhzYkFDSldtd0JHUU9lQUlrRG5nQ0pBdXdEbmdDSkEzeGViTlNFSTJXL0hHd0VOMndBaVFRNEFJa0dqVEZ0SUM5czFtNERKbXdBL1FER1dnSnNiQUJWV3Y0VU1nSnNiQUNKQW13QVZBRUF1VjVzQW14ZWJHd0FpVjVzQW14ZWJEM1lBRWxzMWdKc2JFWkZOaUo5RkdWQWU4eHZFWkt2eFZmS1pzekFWVEJ6WUJIMmQxaXlVWEVISDd0d053N2VaRjVKSlJISTVFZ2FScjVEMjAvM2RmT05yRkxTcTVxU3JyZ2QyQ0VVcTcyMldCUS9MenBBK2J4MW9SRUk1eHk0QkRTWk51bjBaV09SVUpxSW5aU3lNYWlveXZmU0kwbDV1RkR6YldhUTI4L3pkQjBod1I0T1FaMC9qbjlBTFNMTmlrakZZR2ZxUjM4OXF0RmxoRDNhNktkSWg5N3JoWllweXd1TGM3bzhxbDUvWDhLQ2JQVTNML1FsbUNvd2hSWGhzR0R2ZzZ3VU5wckE5Yk0vNDl1eGxBajdaVnkzb3VFWS9CZ0ZYQk55SzBUTHJTalpXZUptL1Q0bno2UUdMVDNjSk50V1JaVlpUdklkdGF4TU1KUkhnaWc5K1MxMUxqQmg3SW5yMDZ5a29jaDFVMDk3UncwaHZnbU9yeWRReWFXY0VRRGcwUmF2dU11VDB6WWFiVVpsMWUzM0hOU0sxb05VQ1MwM2VoKzlDMkV2RjNmcTloK1hCYUFNRnVvV2VaZittZlpnTDRIenlpS0RJVXRmTlU0b0Z1MGFFOXF0M1ZBM1U0RDNmT1NyQWNZVm5qRzNjU2twMXZoWFpucDNKUW00SmtuS2RCaXRPMk5WbkdDWVF3VTNZTVdIV0I4N05FZCs0QUh1T0tJOEJTSUg5MnJlVzBwZnMra1dDVEp4RENiUmpGdjhDZmM0L0RTQllKU2NKWVRlQUVnZzl3VEV2Y3dkL1F1SFJIcUd6QVE0ZlhmNUZVSTFsUHJPK2Z2RWNQbDRKSW5NMXo5QXRCVDJiTDRRWUVSRWU3S2lTbm54VHd0bUFGam44bHFUM21ORDhxVGt0WDJGMTZBZTljYWtxSjYvcEVRc0hVUnF5cVdsUk1DektYUktmQ0hUN3NZSFd4OS9UL3VnWVRGWTZpVk4zQnRtNThBVEpSNWFsWVp5YktNV29qd093M0hiRm4yM05GeWVMbDcrRXI4MlJjaHlZdUJvR1EzajdTQVdOeGlZdnA1VStGcS9ERXpCOWNHNURsSldzcWtvc1J6ZTkyT1ZsQ3RRRVlvMVMxbEY3Mlo4eFdjNGxkLytmRmNmVEVEVEZiOWQ4dEpHUTc1ZHBKRXZjV3lHbUdCaVRiaVdEZEdPY3c5M0RteHE1SVNVcm1hc3lnT05mSEx2aGdvODNIUVplbmJkQnRTekJrdllyQ0VRL3hFRE1oTVpzTjZncXBseDVqR0c5bVNRTGhNODFVRWRFZUo1OXNkTkpEQUZ5L2dQeUpvS2x3UFpnQi9Na0Mva0lDTGlDQjh2YStuQ2RPMnJ5NGFEZmttUEZwRi9IL1NHUTNMSjZhQXY5ZHRKOERuaUh0TE9ja1ppeDBCVmIwaVI1VjNMQXA1MjFMQlNJaTZBdFY3cjJaQi9oUUV2QXc1NEVGTk9RY0ZubDF4R1VJYzY3dHFLMUlOTndEMm4vUmJ3Z3pPOWg0NUxNNlZNdU44VjFaTklRNnQrWHkzbFRxeVZDRDVrcUx5L3QzL2I4TUxiZ0RnOEpJV0RrU1orTHJHaGhyK2dZcEgrcHIxVG5DVW5aUGpwVWR3NmJTTDZNV1ZYb0REY2lRRFdFQ3dVMmU2VkVwZnJjT0JiclNPaWpxR2tFSW9KUGJwbWVKTGtjd2J2QTB5V0lpeFFWam8wSG5ZaDdmamkrRGZkcTFtdFYxbEcyWno5UjdlRk1IUytGSzdueWJ1dHUyZnd6RHBGbGRPMnBaQnNoc0hKV2FsdG4zUFdPb0dKcENUMmpFOEVIT3VDNkZrZWpOV2Nmc1dDcU5xTUxQOXhUd2NXQXJqMkVpaUk3RCtFYURpNy8yY3FITDFnUGlGNkMvSjdhVW83UlFxb2dQWjExV3FieVA5N25zb014UE9DNzh3Wk1GN0IxWTBnN0pOWEpWL25OMW00eHg4aGJxV3owN0tTYXFyNWhFNGljQjMyNkRNUi92VUtYOUxvTmpsZS9aV3RiVWhyVEFjc2RnckxsRzVOZThhaVIwYlMvMlpocE5PVlZ4YXZXSVpzRU0vcmQ2OEVCNHZqYmJEMTNOa01LMXF2TWs3NHZHYlNrTDdVTE8wc1o5UjZBUFNDbzZLSCtYbjk4d0VkdzFiQ1BBbkRUYUJzRDZzaWRBR041OHVpSDRhM292RzFLeVpBdTJYdHlHZ0YvdmdXS0d4dzlSMWxmQVZjZnVZRTcxREh1eHRUemZHWm5IYURwREdXbWZFcTBONEdhd0U3eUlrYW96OGpjbVZtekplMXlkTThxMHAwOFlJeEZjWTFZY3FRYzFkaldCRW9ORVRERmNnazV3YVJmdEVKYXNQUkVrclYrK04vVE9La0VSRjFmQ0xyWFM4REZHWUdSQmVFQ01RUk5FczBFUzNGelV0WENjTnhwWUVNM1VlaTZYb2RacnVYVUlSbm4rVVhmMmIvcjduMXZRdXRvaTZXb0liVzdzdkROV0JiVVdjRFVjN0Y5U0pLM2J2U3k5S0lxaGd5SkhvVzJLcHZ2MEo0b2IxNEhGWEdXV1ZzWVhKemp3eFMrU0FEU2hUZ0NSamhvRGdqQVlSR3h3SjFWb253K2NwbkNLaHo4TlFQcmIwU0Z4SElSYm1HOTVRMmhsQzRtRHh2UEJSYmtGYTYwY3ZXYWtkN2Ywa1ZCeHhrdHpaOWFnUEpFV3lBNjNSU0hZVnF0OGNQcnMydUZKM3JTM2s5RVRHS241K0E2RjlJT3JkWkhmVDFiaUV5VUpLRXZ3enVzY3dzaEdDQkp2ZDE2VHJlZlcwM3hWbkpmNHh2czcyUGR4ck1pZGpKTzhFaVd5Ti9WV3lCM2Z2OWtjMzRZSXVaVEZ0WEdvOUR1RzNIMVVrYTVGZ0JNd0RQRXZSY1NhYmkzV2FrTlFrWEZlY0psRms2YnVMVms1WUhwdUtXVHc2b0Y2MzJGUFBTVklWbDVoZ1VBZUhoajB0L3N3L1BFRXZUaExRRERGRTM0ZUNnL3JMT3lYVDNyK0w5OG9SS3JsVE8wTWRBTFlRM3JSUXFDN2Q4MjJkSlBHeEYxSzRKMlR0ZlBTTUZhQ0FnMG4wTkdrOXlpYUtLT0pEMXYyYUJYOUhVT0lhd2pqZnZ3Q21qSFpKVFI2MlI5Yzl4MzNKbkJqV3JONFFZRU9tZWh5MG9aTVA5WE05WnlpNlRZb2UwN1BhTGNlUlhjQ1daaVkvaW1SVVdXNittY2k3K3dNeFNkd01kYlhja1h0dmhKSDhzYzRpUWNUd203eXArM2Y3Q2Flc1RUUUIycWtnZVhoK3dGaVNNWGZNbEg3WWlsME9vWjJRVHRSTFRpcDJPMGNMWjRTc3RxV0haNkgrOEEya1pYaHBtMGtQYkw5ZFVhblRPdnppcUlVaDZBbWJ3YTNXckNiMmVXYnVDTjNMMWhnV1VtalJDM0pvTDNkQmhSM2ltU1FJOHh1Q01mc3N6bGppN2NTU2hOU1lkcUNYUHhFVndicU85aTVCNmhmOTNZSTdhZXlJOGp4Z2NWWEswSS9rbGJ2aFNYamtqT0l3WmdQZFZ3bXNGVzdIR1BMVUF2RFJ1S20raXR5YlJnN2M4K1lxcWpnODI0UWYrL054c0JTVU5BSzlLQ29KcGF1RnFLMFhRVUxyV1lqNEZueGVLRHV2cjU0aW9rcGkrRDU3ZTZZMXp4UkpKZHNIbkRSM0p5cmFDVXVmSEJSVEtPRFdCVnp0aGptNGszL0h2K1E5OTBYRFZSK0tXK1RjSlgwNDVMVzg2RUtoei85N2Fxajg5QThadlRrMS8vdGN6b3NVOTBsb0lQVmFIdVdlZ0pVM3dQLy83WEhjTzdjMHlRTTJqTS9JaFFLcmY4aGlPYkhXaVdEWk1hbkY4VWYvSHpibURmQzJ3VC8vYWlaNGhHVHYveHpnS3dkYjFzRDZjR0VrY2VvdzBzM2I4OS96ZyszcGx5Um0wSGxaaTg4Nmo1d1V3RmhkSGlEVGFCaWRaUm81Y3gvdE1lTHlndU9BVGJ6cTE3eWRoemJycHh1bnVIeDZsYkZHaU85N2dzZDRkay8vN2lDSW8rRXcraEcyc281a3Z2K0lURzRjMWZ6SFB0dTFYbjVRZlVucVkzL3VCeVZtQjdnbW5FL0UrNXpkbSs2bkRtb2V3czVmcitOelRoZFNIeks0YkJRT0w5YzRPOE9JMHhMU3FqSjRsYm5pTEpnMWFGcFFSTHdhU01abXBrQzllL2o2Rk9WclRRNmEvYTRhbEdnZnJsMlpMMXNiSFVRM0RPSTdudHE5ZGlIRmZtM3QxbXVsM3JkSkVKQ0hubFcvaGxRbnRpcE1ycGVNczdmVXI2d0szNzBEN1ZiWEgwRFVIemRZZlJnLzZaMTFVbHQxc2ZmSlMraGVIYmNvMTVTeHkzK3JEblBlc3FIMWxhamsweXUwMmhQVXZFVXF2Y1VYV1hMN0FkMHdOR014NWdPbGU0WEp4cS9yL1lZMHhkY28yd1JTRUd3Y1Q3WUFEbEJySGM5WmJ2ek9MMFF3eVdDV1dDaEI5T2JnODAwdjd0eUJXYU52ZHd6K2ZMN1BoOWkyaXJFZUprUmdPemVFRHcrSmlEL1Y5M3ZIOUZnTUVvRklKTW9JdW9nbWljWm9oZjk0U0J1UG42aFhhVjlqUDRWVlZBL2J1K1dnOFM4OEdMdG1FUFNOUkxkdGxYeDJYTC9udU04bktraG5sbmphcm9waUtLTElIOTRwTElBU2NpMHBEQmZqOUhpNUJmYVRTWFFnNStQTWpRWDkxS3RrNE1PcUsxSzk5bDRCUlB2NSt2Tm92R1ozSXhRdjhJQ3ZqVjQvZGlUaHBvYU04dXZkM0Q5ZC9ERTQ3N3czeUFiVzNJRG0yaTczcFo5YUVqMzhKcVM2aC9zOC94Z21VSVZjdXEySlRnZWZBeXVvYWZ6UXhBdVJBU2VnM050RzNhY2gvSkVreXVYK0pEdDJQbkRaVFNoVWh5SEhHM3R0QmcvNmxoQWNoR2pMSkJ0b3BqNGUwMU1sQ3AyeXFRUlRyNHNCQlhydStsS2FvYW53WVg4eTJhV0NKaVIzS25oQ09rWVZGU3ZzTzBvRFJ1alVGT0VwdGlORFRZckpvVWJ2T3l2bDRBaEM5aDN3T1JpVFhLMU1ycE1mbnZkbm5kblIvSFJWU3VzTUJnSXh3ckxkbjN2cTFWY25jUGlEMFNxdVR4L2tObXhlRnlDVDR1WFZVZDlBTCtyU0dtdXE3T09DekRLZVZQamlOV1Zhb1A1S09GcVlxNVhjdWYveFc5Uyt1OWVJcTlHQXRaV3RRbGdrUmVjalJ0dkcxTlI0V1hYcG4rcHdzVEJUSXkwNzlJa2c4clNlZjFhVmFwSUZjWENkNkMyd0hWakxYUitOMHR3NFRhdzZ4Nkg5MEJGUmdOcnRscTJ1cDZoSEt1VjNpbk01UkphUVdaSGQ4NGU2UnNLa2s5cG8zZGs5Ynk1NHRwUHc3Y0JrRmFzL0crR2JId3VHK0F3UDU1Qlp5WElMVEhDSVZyUHBYSEVhVVBZZkw2bnBoSlAxUmMxMHhHNFVhQ2VZNElIQ3d1dXI4eG1TUURnWTRhVndoeldoamJ0U0hHOEpPNlAyaTJuQzkvMEJmeDB6azZkWVFxM2F3N2s1dklPYkQ3U0VLcnhoejBmUTArWVRPZkhXMjNDQk5lWmNpMXFOc1VEaG9lcW1meVA2UHZqb0VqSGs4UWJyRnlRVlpQSFZXaWpuYjhZQ002NWlZTm9FYnZuY2hTdFovOWNLZzVWZDQ1ajhLbkI2VWp6WGwvYmt5Wng3Vm9ENDdvY1VVaTExN1d3Z3lTU2I0clhnTEo1Mk12NVhKYnAzSSt1QlA4MUJVdk9qeTRDYWNnaStHV1dsQy84ZHdncXdpb2pqVUJEbkVPeHlSeW93d0xRZnl0RnJhMU9aUzRYdlJZcjR1b2FtQWZHM0kvcDJiQTdHOTB5cUtUaEg4S2UwMFRxZCszbDNkbUpwYUNaZWxCTVlqR3FOTFZhM1NNNCtMUWVMNTZnWTZCeW15MkxRUFZPeGpXZmo1dHE0bzc0c3djeGh5R0pQeW5rUzV4QWpPWFpQMS9GQVljQlQzdTZxTG9Ja0VmRXJ3bzRnb3pteUkxWUN2TTBveUkzZ2hqR1BRU3NvZjJzS1VocTkxV3NLeTljWVdOKzRBMnY0cEcvTXhwZGM2dzZrSS9IWDdYYjBUdWlobXNpT3kyd1FJc3JaYlVtcjNPQlNVbzZvREpOZ1FwK1lxWWtnVGdZY1daRGdhd0p3M0RGZmR6VC8vUGhWVWlkZ0IycWE4dXcvajlUb0hCQVMzM2lUOFlMaGhBZnlYRzBiUVVGcDdRbUg3b1EzaTZGbGY0T1RaTHZKZGg4cGZ1ZmxtV3Uyb2htNXBUaVNnMXBsM3ZxOXVsdVRKd3FYZmgxaHF5OGUyaUhvRCtZMzVnQ0lWaVRvNlZPdEs1ZEQ4SFlDbHVjSnVjWEFTendlMmtQajRTNGVZUXRta1lIYWdYaEF6cC9GNTQxeEU4WUZZcVNQc3pEdXozc29Xekh5MHAzRTJqd1pOUWFJY0dVOUZOUXdReGVEdzBabEs5ZHhYcmo5SVVIR1VQVE95aWI4Q3FYbWJaN0V4NTRibjFyTHgzcXFBYXZ1L2doNlhqVjBHbU4xcCt5eU1LOUhONXVZRXZ4Z2JBazQzdHNoZVJFaHlJK1E1V0xJbmVLVEdQbVlpTS9seE9wOGZ2cUh5OFlnWEswVGxNaVgwdGxpTEkySnRmbVdaUDhlVlY3MzJzZFltK3BjV3pEekVtS0xKWnllZWx5YVpLa2pQbm5VTzlrZUR3dGdpTG5tZDUrdCtTcjV5OGJyUm5sdnhjV0VXZkNxSUFMUVlIdmFYeDZqVGc0ZEFseWU0Njl1R3d3T1pWWkNJTExmR2phTWc0TFVDTk1UdE1TcDFhQzJ5LzN3UjJ0MXYzdy9pTkJSUStiTmJ0RHFMMk5BcjdLNHJVY3lxYlNwTnJYWmdBV1h2anhCQnRmWUxLMXVSWXQzcTJwZlhKT0FMMEh0V2NFd0pMZGRPU0pLVjFTd3ZjdkV1emcvNE1QbkE4TUlVSk9McW0zcUk2d0Z5Tjk5Q2s2ellhVi96R1NBekYvUEdzYU5hNHZQTGU1UW55dXFWVW5WUTZ4RUxBNmdiZTUzYUdnZWtlK1IveWNiMkxKVnljN0JodXpJOTB6QStjNndVRFRiN05ILy9nZERTbDJ1L2FXN2xSSm04bTFmTHRQeGNOdUVNNUpia09DWktQTTg4SFVzTFJvQzFwbUtLbHZXeWVBWHV4SUxidTBzbnBTeGY4TitSZ3RMVVNlNW4yZ2RqT2pvU1RhTjdtTVo3YkYrY1drL01TOG1GRDRwY3lsNVVON0NicEZaSDJhK1BtMVZBblVUVmZidzhxcm16MUc5bTVhS21SelkxU01oaFBybENuMnQ0dU5VWE5BM0lGZTZOT2pTQzFERWFBRlpBZkRsRWtRQ3NiTmhzWlBqNk5RUERTQjN0TGlUbzBaWW9FYkllRUlhS3RVM1drNjByRXN6YXdURnV5SFZkMzY1TEEvYy91YXJBQk41TTVyR3EvZHFURzNJbHllLzVFS2lZaXNpc3V6cU5hWmptV3YwejlUT1JjMENLYmFUZWEyMTRvTk05dTJzWFVadWIvZXFNM1BpL1BqUlN5UWlPU3dQV2lmMmFzVGd1NmhTNmZiNVVHb3NDV3hkZWRNcWRWaUlVVVNTZElKeCtxUTRLU2hmVFQzOVZBV1piaSttQitpS0lDTndwdDZjZmxZNTdSY2JzNmQxa0EyNklydTczY3V4WVZsU3Z1SmRjUjVWZkRZWlJrOFgwQVhlUFJPeXczTGU2TGFVZG1UTHpZc29OaGhnUXBkNjd4Vk5pSGdrM3Bha21uZGVJQXRUQzREQ1h5OW9TNmVVNENXeERkVm1ZNTNwS05iZEFLbVFzUDM3bHJKWkM2aURYTUVMR0tjSGpOdXVaZ2NEeVk4Vy95djZoYTNEWDdPV20vMzVmcHZodzU1b2l0ZjRWK0dVTGxjUFdZeUdHdVZCZHJvMTljOHUwUkRkZER1bjQwVzdHNWNTSXpITGgvcVp4YjU5UitFUFkrd1oyWGVya1VpbTkyaGhYcEt5VzZXdEFoNnpRUzk3RHJQeWpDdktpM3BDdzk2TGVLeW5PcHlqdHNNUWMyUm1JLzIwekZPWmNTYTJBSysrUG9SY1Q2emVKeXhsQlo3a2s1bWhxWEdrTGxNMmhGS2MrL1Q1NDR4WFAwVWEzOFE2eGRQVExUZUcxUEhuTE1hT3Zrc1VRTXJFRlRCL2xpekNpcm1GUUw4ellWVStPVGVZUUVGYUlUc0JTTU1ZZXhTOUhrYWpPMmdHSWYybWljdm50Q1pKc1pRRXdJSDMvNEpHSlFHZmxCdUg1ck5YbW5SUllYRFFzM1pvRVFvTXRZRHIxa0ZLVVMvc2lpUVNVeGNUSDlYWWVCWmlLRERGUW9FeFJFTzlkZGRLUUxPM0J3TUh2eW1DU1RGeVkrdnhuM0QyN05EeDZPbFUwOTJENUVEVXdpbHR0cVZIcGpKUURVY2VKWUNMc0syc3dmWGVOVVZyQkpUL3cvc2srN3NpOHJQdGlNRmlzK294dkdkR1F4aXJNQklENzAwVDM5bVVMdU5Iek95Tit4QmZjRkFDWmN5bmdGMWFTcHYwSlBrTlVyQVpUcWZwbHY1MDljR1hGVWlFRW01ZFpiK09zUC9ibGl6cWRLNDUvZFNzSXJ1ZllUckNQWTJsZ0pENms2UWxqVGZYVmxIZllLU3ErTXNhZ3lVY2FNaW50eXI5NWJEOGtkVEFlWU5MTnNNbW8vV2RkOGEyblN0QlA0OUFSSWpxcXBVSFdZNHE0bXZPNUNxL0NnQ1ArNC9CKzV6dXRHd1g1cHNzZ1ZMcjErZklNN1dXTGZpVVFEazRjNlpkSFpPV3Y1aEczZzJkZ1E1TlhucElZK0JXd0pwYW91ZjI1YlhuakR6YkhuUU5vZkgvYzZtK2RFQVM5R3MyaDdwRlJQS09CRG5xc3daOEtaamhJZDF5dEhVVHM1MzNLd0JvU2lJbW94S1FVZ1o3ejZwQTlRQjNzWjhDcTB2d3V0SlRUa2ZiWDhBekNwbTJjRlh4L1AyMm5pVU1IYXVVOElHYys3OFI2VHN1dG9vbm9xRnVvTkEzbDgwdDM4N1lITW9MNUtHQVQxSk80em14K3ZKMExiTEhsaWNIcmFTVll2SmpuTzlwKytxbldnS3c5T3dGVlZVYWd2WnVmOXFmaXV1bStoSWljeFAxcTR6RG56a0hzQ05yaUx4QnB4WTlOK1VPbXF6ZFkxTXVuTE1EZ2tNeWkzdXZuTjNVQlhKZVo4WUxzNXhyOFFyT2hpbVlvS3VHQmViWkhBaUJJa1ZpdjNERzhrMm9OcHA1T0lnWDZ1bHFhUk44VjYyUVVQam41dGwxa1BYaFQ5YmNkOHFJbThnaTRvci9GR2J2UTZwZ0dTSG1uYXlydWdtZjVFMHVwR3hQUmYvM3hPdGl0R01hSExLSlZtNXpoZ2xtVmZJOTFvMHl4aEpaVlMvNXdROHpmeEs4WWx3MFdtSFhvR2ZSa29CUng5SHNubC82c2dUakFWd3BtTnVTZVp0QndsWDRxQjhCaDhseGpxQkRJdUZHSjRJMXd4TjBYUmxBQXNsenFNS3dRZnlBN09rdWl2Q1hmditpKzNYbWhjQkZNMm40amRUK055VW1CblFKUFYzRjJzWmZLdkpoVWxYelNvc0ZSNFZldlZWY09rRm5uamRpUldjMFRlU1l4ajQxc0pHWU1iWlRlTEkzR3Z5WjgvZ0FBdWRRMSs0b0ZYK2VuWDVWNDlNY3pHQ1lWQnVvQzRrSGpwN1pWeGorY2xCd1ByOWsrdjA1U3NlelFLM2VueExzMU50L043YzdBSW1WVXlzakdvdTRpT29oSG84M1pzOS9NSS9PV0IrT3lYek9CRDkzTmJBcEdIWHJ2OENWUkhwMmJ3SCt4QjU1Y2ZOcmRxRkQzNUhTTXg0aVZtdHpZQW1TQ0lWOGtYc0hvcTNESWI5M3JpVFdidWJuanhiQlc1ekNvblZ0YnhMUlN0WEhrSXlBQnlhb3pNRTk1MkdjOWFBZEFiQnBaU1ZDSDg4VXdiLzRiUFRWT1ZsK1dvTVlEN0pJdks4VmNNcko4ekhWNGJiRzBEZzdLeDE3QTRlai9aY1oyWjVwVnVWTFVIMUUvQWNjVVRLbTgxU0UrTFE2U1RUVURzY1VrMHgyT1dJYkVPUmhnNjl0ZG9UR05rQTFSZmtHSVJaSHI1bUNYT3BMQzU1V1d6Q1pvR1BGVVZ0WlJId2gwbnEwMzlDRGRqRVBvK0p5YXhTUUF2RGdSNklxdnh5MGZycnRFRzFBMzg1TjgxbDA1U1N6TitJRG05YnlwRjltOTJFVXFibG5hdVo1c2pjMzd3UnlrT2RsN3c0bzhXTWdRc2ppaTNFRS9hSllEZkhzMWNINkROQkV1ampjQ2M4cUFlZllGeUlBVVJEY0RuenVuNVVta2JCUXNVNGV1L1c4STluQkUwcUpLVGRnMmh3anEwK1hWN2EzVEo3UithbHZKWkNSaWE5bEorZ3JOQjlkYnJPbVdFdlVvdE1qdkRocTR3Vi9rcTRmdklCa3pVR3BEZVlINzRybmU4dVUzZGdvTlpkUjlwVUw2cTlZRE5SZk9pRjZEeWsrU1lYUUlnaFRqbTlxUjR0QkhoMGdubUYvOXEzUXYyMkV6YUxoU3ZEbERPeE1yckNOUm1MQ2wxakFwekxyQkNQbjJtam41enFLN09ZSzdWeE9mUTVHZkJmb1BkeVF3cUZFZ0NWSGtKOW9UbmFnUk0zUjArcnN1TjVqUXY5aWNDYXYvcDFXcWlFWFN6Q2RMZC9XRUE2ejZkRFA3dFBxUGJlRFlLQWtWY3oxbExHYkZPQzliN2NCZDNNVjBWZThkWjg5b1I3T254R1M3dVZwU3J5OGJhblZad3BKZytua0gxalJCWWEyQnZCTVkyeElUSDlFUlhDakh6ZFp4cytpcGRYUDJEWTdYK2VXaUJodFQyTDBSUkdUTFBlYXpuNXRwbDR0dThpRTJyV2lnNzMxaXVKRFJiQ0hIeStnL01iOSttaUF5VnFmSXBYVC9pWmVPeE94T0RPMGhFcExNNzhJMStHMlo0NXlpM2xTMUszbTRXTVE1NTlMcDRVTUw1dlpVallHSnV4bCtPUHBVSDVrbHB5QnVqa2pwcmhlaTBUbVVpazEwZ2p2TlVwOG1Ea1dsTktpa21Zc3BhVlRxZXdibk96SnJtejhGTElwc1Q2N0VKTEhJSWZlRGNXRWZpUCtESnJaMWpmeHBvQWIyYWJlTXFMeCs5UnVaR3pRb1l0WVZHZ0FXd0VNOUtlazJ2UEllQk5BS0Q2YW83bnc2c2d2ZmVMWlBvWGtiWU8vdFN0SEpkS3prK1dGU0ZFVTJOY0FMSkFFUDZTOHBjbnFxQkJ0NTdkd1RyelFOQ0lkazJTb2NLNGRMUmJEL3B1L1ZyeUtubTY1WllYaUpDZkhKazNteDlNUlNsK25TSzZPcUVCU29HanowL0xBRGRkd0YvSHFjZkszSzNPKzZZVUdRY21qOHBaTDRQaFo2S3JHa2I4QjM4Rm1EdnZMZDNYUVhidlMvRlFtclhGVHZKTmthTi9GR284M0t1UzQzQksxVWZWbklxaWdHa0NvUDVmQmRhMk13QUdUR05LWDlLOXQ0Qng4M3BNRmM1S1NPUm1XS3YrOFZvVmdnV3hvYUJ6My85SUJoNlJ3TGQxdGVid3k4OXh2RTV6NkVFcFhwRGZyWFdmUnNNczYrZWtVSEg2aWRWb3NubzU1K3hROFpxemVsaDBieHRKVGdDY0gzWjMvQ3hseDllTklTNEpJRktPQVZyRHFiclhSc3ptWTU1YTUrbmlKR0h0a08zYjZtbklEeExhMVdYYzdCQWUzM210Mkt5TTRGYmMzUjYvV1ZUUU44UWhscUF0YXZlMldzUVRxeldlU2xLdUdVVklKUnF0T2JwdjI5NHJTMGtETjFSS3pkc3RaVFhKZWJSMkhsenNRNFAzTmJNSFVxRlpNWncrL0lLWG5oNHQrbFk4cW9jcC9CMW9Nc3pSMDNFRnMzYlBlTkQ4UWtJdE12bGxPYmVDejNTWkFqcVpyb2JtTGNycEZ5UVY3bXdCamczQzNDOC9iYzVnb1FodjhqL0lYTUxHbnQ0bUY3dHliUkRHNUcwcG9seG9VU2NRa1B2bW5nYTIvSythYXBLZXFTTDBCVG1vMUNtNWcrYm9vTk90ZHlLdmEyS29lZlJVUmFCazcxMTNRS28zeStXVHVGS3RnRVRJSzhIUmx1WVM5RHZsY2NpQ0R2bkc4VWFKUmZaRTJzaVpzaVRIdlJtTjgweGtVSUluSGVSWmw1UmUvK0FUTDZWaEtGaThDWi9uL2piRlY2VDVwWitVb3BwdnNpM3FqYWNWRk9KZ1dXZmRsd1ZIS1BXL1RKTzNuYTloUk05YlMyeW8yckVzQzZJQnpSUmVWTzZJZXNKVTdQSXR6T2FtcitST0Zmd0dabVo3dWU4SE54QWdMSktiN1AzcDhkTXFrNkJlNVBKYVQvNVJkYzFkZVlWaWhXSDljalZLYzl1ejVFbmZIcXhMVWtPTzhpSlVFTkJOVmY1THlOeTh6akx1Lzc4azVXTlR5d2lQZlllWDNDUGs3eWM2Q0kzbHVtL0NFWndmVWFOcGNJM0tzUHFmbjJsbXoza2QvYWNRaktBMWVia0phaXVMRCtlcFEvRmMxbGxIWFhNem9mV3p6L0tkMjlTTm1PaGNqTVd3MWpxMWczWWZyWFo5cnpYRFlXNFp0dGZnZk1pNm9DVXRCczBQa01WdXhtcTVseEVvQ2FTWFBTcUNKSjdNbEtkUkRpZFZ0MEFGbHhrNWNUZFgrK3NCRjIrRTM1bWp3Zm04RVJWeEgwRnZ1QVF0c2ZBNFYyRzBUS1RVeGV5UkdWamQvdTZGMVN2dUFpVTIvV2FRamNOQ1U0RXA3VnVuWENZU2JaajNVM3d6dS9MV001TVBsWXV5UTNGT09DRC96dDdLMjk1aFkySmh3RitPRERJWjY3NnZHUUZLdmVFUVlrV2o3bGtLN3JWbUQ3TWhVMFkvdEY4RWNUVHBvNC95cU91ZmJkL3pXSXBNYWpuYkR1V0sydm42T1BQdHoycmM5TUlCTmxQZDh0dCt5Zis3U0M0d3FFUGJvektNQ3dZNUJ5Z3g0Sm1vSUVEc2l4V1JEY2RIZDZTMy9kWk1IWE9KQUF2NytOSXN0bDAwY3JnU3FIWktBRWU0ZzNHNGR6SVY1MUVlWkIwMXI3cDhHTmxmVW5HL0dqWmdOR3NxWFpkWU1CVnRBdEZOdjNoSldQdmU0R3ZxWjJYeHVpTmtIVHo1a3hXZ3IwUGpRZEpsVnl3SjlaZjJadnFlZVRib2xLdHZLNTRyZTJMcTVCb3l6ZnNSdHZEZnlhbzNrbXlGekRRODhuTStxeDgzdzc0UkRsa25ndFlpQXJJMDVFcHJlM0dnQmVTbE1pZzBwRTZSR1FhRnpuS2tHZWIwU296TEN5aU90eGg3aGd3WmxiS2JDbHpVVWZDOG50TWlIVU9aRTM3NVJoVHk5YzREQStvTUxrVURrenRTeWJaYmRtUDF4cGFJYmpVcFBBSEJxM2NJcStDQkZ6Yk1sTU1DQ2tVUTZkOUxHVjZHWUNzWWlFV1pJeTNuQm51eE9ZWGVVNFlUR0RTaW45ZTQvcENqUHRRU0hsZzVMTUV2SWxGMEVsdGhxckYxMjlpSzJSUEJFV2QzWFdPbDNTV1Y1dXo1VlV5WllwNWtFRm16N1FmUC9CMVcxQkJ6UTJpVEdiU1ZUNzlsVUh6Y0dYejNQSmNlU2d6NHVrbkVUVXdvMHhmZnByMktVdlpGMGkvcjJzTDNJRklDbFl4OENiSVpFNlF0N01ESmJPUEIzeE1TY3dhT2NXRzY2SUpmQ25Ea2IwRDJNYitQSHpYK29pQ2J4ZVRJb2d0eU4rczJOSmlyTkFDay9PQUNTT1R0VjZ2c2N3YnpXNE0xNjh4cWFJK1J6UjQ3UzFubFYvck9vWm5pZDg3bi9JbWEyWFlhM3VuM0J1R0Fpc05qYjhlTE1UOU9uTXRhelFST0ZDdU8xSGlaWGFPYzBvVURiTkM0ZUtMVG9PeDhEelZoTWdHQThYSUFRMngzYjZJMHVFeUxzc1FqSlgzUXBoY1VNeDRLc01nSis3MmttNE4yYXFrQkYyY29LbVVFdDFlcUlNR24rNXR4TVQ0a1lWR2QzQUxPK3k5WjRQUDNkM2w0OEpRSzhzOVpaL1F4LytOQktnQkVKRmxRMzJwc29KaWloR083RlNZTTVMODFxNzJrYUFZY2lsRUZNRytaSzFCY01xRUxrZmx5Q1Y3djhKRVhMTzRSZi9vWllOWkhaVmpKaGZMNmZucFA5VGlvM0V1dWU1dVM3Rk1rZkdPZVJDVHJCWjA2Q2Fldjd0Z3VmZVRyWDM0VXIvVnZjK2I4a3NpSVNoTkp0dUY5V21ZeE9aNHhnOHk2elRkeTNLQUIyeTVrWWtjUm5Yc3B0V3dBRnlLWjJJL1FHeVNOZW9RTGtJTlVNbG9DKzVMM1d1TU14Mjk3UTF4VVlMS3FaOVhIYXZhb2JvNlFRdjRhdU1tK2k4NEloeFJwUHQ5blVtY2F2OU5jakNjUCtUY01teHNRWi9GM21nZW9BMGZRZ3d2VHN5WHV1VGFNM1NxdHYyamFhYWptYUZRcEs5VzZ1SWJlcXd2U0RvMzRaclk2ZWxEVUh3U0NqSFJSbWx3bXl5K2VPcmE2NFNzcTBYU1hZbGpNSHRLWStGU2hjTWtIc0VVWS80Qnc2M2RKNktwd0RheG10aGxEZGJkRStUdllGM3YzM2NHU0txTysxSDFwS1loSk12WkQ1Y2tRY0h5TkY4enJ0aVI1YjBrbzZOUEdvUmV4VVpUWVA2VmJVZG4zenp4R0JPaThaME9xSGpHcVl4Ulh3TjNtWWkwR1lFRVpZcStRM1F2ZEtjRUhJTExMajhTK1ZGZXBTZkVydG1mWkNkdnhiZklpZkZTcEV6S2krN1ZKc0xNVCt6RUZleXAxT2R3UkMxVlpyZlRMSXlSN3hUUFVjWkZZUEQ5cUk3RDcwdVRiNGhkcHFQWHNKSVJOWWJadE53Y2gxT0kzdHJoM3UyU2NvUXlNOVBPbkluc1VhK09vdmN3a1VQMVVmSXpQYjk1bjRCYUYyZXY1N05IQWVqMCtCVk1GOS9Dajk2NjNITjIvSk4zU1Fnc2xMOTE0YktmaVRUREZBejlQbFFFTC9kU3YxSDh4bDNtdFd4aDFNY0ZPOUVKWGxSRGFLUURzeUtPNHZPSlc5ME5GRTZ5dzJ0amJjMkdlRjk1c2JzMEk5ZW5BYTZRd1FWZi9rSlFoQUQyQnpVREtnZ095ankxVEVoRUQ2c2ZrKzQxOGxReTNjL3VqOGF3OFVFelo2aElNQ2Q4Um9oQWt1bU10SWo5bTczbDJ5UFdvR0hWVFBheXdrQzdZajl0Qk0xTnhNZ2NyRHdSdGs0Uk8yV0hUN1FsNWtRQ0tkSmo2a051T1RleUVCWUJqTE1oR3orTzUvWUdhODRIRWlUWUVwWjZmRnp5MjZHRzJoV3RUeXRldVlyaFN5RzU2QmpzVC93UWVMUnl0cFRZM0Q3c0lNcVpuSjl6MUZEcmZ5akZsR2wyVE53OUJReXNiYXhPdXdZWVpzLzdJNkJBTmdrcUNrbldaQzcvQkJYdmFlS3dBbUM5NTlJK0czOUJVRTliRXhrTmxiUm9GUnlFdE56ditOSjkxRnVpc0czSkNTNnVZQmVSbmZ2OEFrQWZLVGVnOUVZYW1xbnNHZkFWN2QwZjlEZ2hIRVE1SXNQR0RJVWhnb1NqN29iTTRCdTV1aFEzL0NZRURUSGM5MkFzRnZESzRYR3J3VWVHQldCSFBsUytmNHgrQ3htbUh6MnNBR21TRk50NjVrd1pDNjRtbmFvV2x1MjMxMGxhWW44cjYyQXFzUjVkZmp5SzE4TUVkdXJkYWdsZHpmSnRqRlhsWnM3U3Q0UWhkUGl5ZTZUUGgyL1pBUUxVL0ZpcDVzN1RERU0xNkt0UldySzlobXhuUTdibWZhLys3cGExMFo4V0RQSzNOdUorTk4vUkFiUTV2SHgydVgwTG03L3c3Y0FFSC9odlpBK210N0o3ekd3N1l0UVl3bk5ONmRwZ3drR2pqclMzeVFvZW9ZdDFFbmN6bXRtSmZRWld6VWxQM0hsZzlXemxyOUlIMjNxM3RoR3RoK1FORUFORmV0dHhLZnNra0dPbExrOEFxb0tKd0RxT3hBYTZVekF4MDdwbFNTeU5CSlNHY285empuQzVnR2JEb0t2c01EdUJSNmJHUmxHekoraEZzR2EvSXp0NzhhSStXWjZkSmxaS3A0cEdJU3V2OXJWMHNBUzBNV0V3Q21mYXVPN29RWk1pYWtIVTM1TEJ4aXlKb09NZGRoVVdnY1p1QzhyNEtzdm43NVRUY1FYTEo3a1d0WWhHdUdxUGQ5ZFp1RmpCV1FITndvc1hZNXNuYkhGUXE3MkN2SFhoSWcrc2hReHljdUxPdVdZRXJ3Q0xaZUYyNGI3Rjc4cE83eHc0WDZsSUFSMDJoVU9mNTA4N1JsMG5PYWViNkNLNGkvS0EvRVp2NzZmdE9XWnRqd3hzbE5yMEUvdThyV1VtbmYzYW1mZzZVWm1CQWx1dW9qM0RkN1VWKzlJQUo2aVljRGZTSmxnbUlJbW9oamZJVU1KMjd6K29wajUwQWs5YWYyTENOcldyQkp2TW92QTFPZU5PK01GL013WnZuYUN4VGdHN0N3NFFmU1BGNkFZQ0dGdDIxTThQeVNaRmVWM3QyUnFxczVKTXpNWXpHUmdxNG8rVWFLUmdCZjlHSGkvOVg5SFhBM3d4a0NzZC9VaG5IU2gyelVWRGlyYWlvLzZuUDR5M1hKcXM4QUJmQUxBdENZVTdESFBNUFJqZ2NNNkFkL0hpU1hEQWJPZFNNa3ZHWlBBa0hzOHd1UVR5NlgyT3YvSkZ2Y1B1S2ZWMy9yOVEyOCc7XG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKFtbODIxNyxcImFwb3N0cm9waGVcIl0sWzgyNjAsXCJmcmFjdGlvbiBzbGFzaFwiXSxbMTI1MzksXCJtaWRkbGUgZG90XCJdXSk7XG5jb25zdCBOU01fTUFYID0gNDtcblxuZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XHJcblx0XHJcblx0Ly8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcclxuXHRsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XHJcblx0bGV0IHRvdGFsID0gMTtcclxuXHRsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xyXG5cdFx0YWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXHJcblx0bGV0IHNraXAgPSB1MTYoKTtcclxuXHRsZXQgcG9zX3BheWxvYWQgPSBwb3M7XHJcblx0cG9zICs9IHNraXA7XHJcblxyXG5cdGxldCByZWFkX3dpZHRoID0gMDtcclxuXHRsZXQgcmVhZF9idWZmZXIgPSAwOyBcclxuXHRmdW5jdGlvbiByZWFkX2JpdCgpIHtcclxuXHRcdGlmIChyZWFkX3dpZHRoID09IDApIHtcclxuXHRcdFx0Ly8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcclxuXHRcdFx0Ly8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcclxuXHRcdFx0cmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XHJcblx0XHRcdHJlYWRfd2lkdGggPSA4O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IE4gPSAzMTtcclxuXHRjb25zdCBGVUxMID0gMioqTjtcclxuXHRjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcclxuXHRjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xyXG5cdGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcclxuXHJcblx0Ly8gZmlsbCByZWdpc3RlclxyXG5cdGxldCByZWdpc3RlciA9IDA7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcclxuXHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbG93ID0gMDtcclxuXHRsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcclxuXHRcdHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxyXG5cdFx0XHRsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuXHRcdFx0aWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcclxuXHRcdFx0XHRlbmQgPSBtaWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhcnQgPSBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChzdGFydCA9PSAwKSBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXHJcblx0XHRzeW1ib2xzLnB1c2goc3RhcnQpO1xyXG5cdFx0bGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAgIC8gdG90YWwpO1xyXG5cdFx0bGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0KzFdIC8gdG90YWwpIC0gMTtcclxuXHRcdHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpICYgTUFTSztcclxuXHRcdFx0YiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoYSAmIH5iICYgUVJUUikge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgXiBIQUxGO1xyXG5cdFx0XHRiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcclxuXHRcdH1cclxuXHRcdGxvdyA9IGE7XHJcblx0XHRyYW5nZSA9IDEgKyBiIC0gYTtcclxuXHR9XHJcblx0bGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XHJcblx0cmV0dXJuIHN5bWJvbHMubWFwKHggPT4geyAvLyBpbmRleCBpbnRvIHBheWxvYWRcclxuXHRcdHN3aXRjaCAoeCAtIG9mZnNldCkge1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcclxuXHRcdH1cclxuXHR9KTtcclxufVx0XHJcblxyXG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXHJcbmZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0cmV0dXJuICgpID0+IHZbcG9zKytdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKHMpIHtcclxuXHRyZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKHVuc2FmZV9hdG9iKHMpKSk7XHJcbn1cclxuXHJcbi8vIHVuc2FmZSBpbiB0aGUgc2Vuc2U6XHJcbi8vIGV4cGVjdGVkIHdlbGwtZm9ybWVkIEJhc2U2NCB3L28gcGFkZGluZyBcclxuLy8gMjAyMjA5MjI6IGFkZGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vYWRyYWZmeS9lbnMtbm9ybWFsaXplLmpzL2lzc3Vlcy80XHJcbmZ1bmN0aW9uIHVuc2FmZV9hdG9iKHMpIHtcclxuXHRsZXQgbG9va3VwID0gW107XHJcblx0Wy4uLidBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10uZm9yRWFjaCgoYywgaSkgPT4gbG9va3VwW2MuY2hhckNvZGVBdCgwKV0gPSBpKTtcclxuXHRsZXQgbiA9IHMubGVuZ3RoO1xyXG5cdGxldCByZXQgPSBuZXcgVWludDhBcnJheSgoNiAqIG4pID4+IDMpO1xyXG5cdGZvciAobGV0IGkgPSAwLCBwb3MgPSAwLCB3aWR0aCA9IDAsIGNhcnJ5ID0gMDsgaSA8IG47IGkrKykge1xyXG5cdFx0Y2FycnkgPSAoY2FycnkgPDwgNikgfCBsb29rdXBbcy5jaGFyQ29kZUF0KGkpXTtcclxuXHRcdHdpZHRoICs9IDY7XHJcblx0XHRpZiAod2lkdGggPj0gOCkge1xyXG5cdFx0XHRyZXRbcG9zKytdID0gKGNhcnJ5ID4+ICh3aWR0aCAtPSA4KSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIGVnLiBbMCwxLDIsMy4uLl0gPT4gWzAsLTEsMSwtMiwuLi5dXHJcbmZ1bmN0aW9uIHNpZ25lZChpKSB7IFxyXG5cdHJldHVybiAoaSAmIDEpID8gKH5pID4+IDEpIDogKGkgPj4gMSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfZGVsdGFzKG4sIG5leHQpIHtcclxuXHRsZXQgdiA9IEFycmF5KG4pO1xyXG5cdGZvciAobGV0IGkgPSAwLCB4ID0gMDsgaSA8IG47IGkrKykgdltpXSA9IHggKz0gc2lnbmVkKG5leHQoKSk7XHJcblx0cmV0dXJuIHY7XHJcbn1cclxuXHJcbi8vIFsxMjNdWzVdID0+IFswIDNdIFsxIDFdIFswIDBdXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkKG5leHQsIHByZXYgPSAwKSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgeCA9IG5leHQoKTtcclxuXHRcdGxldCBuID0gbmV4dCgpO1xyXG5cdFx0aWYgKCFuKSBicmVhaztcclxuXHRcdHByZXYgKz0geDtcclxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRcdHJldC5wdXNoKHByZXYgKyBpKTtcclxuXHRcdH1cclxuXHRcdHByZXYgKz0gbiArIDE7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlYWRfc29ydGVkX2FycmF5cyhuZXh0KSB7XHJcblx0cmV0dXJuIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4geyBcclxuXHRcdGxldCB2ID0gcmVhZF9zb3J0ZWQobmV4dCk7XHJcblx0XHRpZiAodi5sZW5ndGgpIHJldHVybiB2O1xyXG5cdH0pO1xyXG59XHJcblxyXG4vLyByZXR1cm5zIG1hcCBvZiB4ID0+IHlzXHJcbmZ1bmN0aW9uIHJlYWRfbWFwcGVkKG5leHQpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpO1xyXG5cdFx0aWYgKHcgPT0gMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHdoaWxlICh0cnVlKSB7XHJcblx0XHRsZXQgdyA9IG5leHQoKSAtIDE7XHJcblx0XHRpZiAodyA8IDApIGJyZWFrO1xyXG5cdFx0cmV0LnB1c2gocmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQuZmxhdCgpO1xyXG59XHJcblxyXG4vLyByZWFkIHVudGlsIG5leHQgaXMgZmFsc3lcclxuLy8gcmV0dXJuIGFycmF5IG9mIHJlYWQgdmFsdWVzXHJcbmZ1bmN0aW9uIHJlYWRfYXJyYXlfd2hpbGUobmV4dCkge1xyXG5cdGxldCB2ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCh2Lmxlbmd0aCk7XHJcblx0XHRpZiAoIXgpIGJyZWFrO1xyXG5cdFx0di5wdXNoKHgpO1xyXG5cdH1cclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gcmVhZCB3IGNvbHVtbnMgb2YgbGVuZ3RoIG5cclxuLy8gcmV0dXJuIGFzIG4gcm93cyBvZiBsZW5ndGggd1xyXG5mdW5jdGlvbiByZWFkX3RyYW5zcG9zZWQobiwgdywgbmV4dCkge1xyXG5cdGxldCBtID0gQXJyYXkobikuZmlsbCgpLm1hcCgoKSA9PiBbXSk7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCB3OyBpKyspIHtcclxuXHRcdHJlYWRfZGVsdGFzKG4sIG5leHQpLmZvckVhY2goKHgsIGopID0+IG1bal0ucHVzaCh4KSk7XHJcblx0fVxyXG5cdHJldHVybiBtO1xyXG59XHJcbiBcclxuLy8gcmV0dXJucyBbW3gsIHlzXSwgW3grZHgsIHlzK2R5XSwgW3grMipkeCwgeXMrMipkeV0sIC4uLl1cclxuLy8gd2hlcmUgZHgvZHkgPSBzdGVwcywgbiA9IHJ1biBzaXplLCB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9saW5lYXJfdGFibGUodywgbmV4dCkge1xyXG5cdGxldCBkeCA9IDEgKyBuZXh0KCk7XHJcblx0bGV0IGR5ID0gbmV4dCgpO1xyXG5cdGxldCB2TiA9IHJlYWRfYXJyYXlfd2hpbGUobmV4dCk7XHJcblx0bGV0IG0gPSByZWFkX3RyYW5zcG9zZWQodk4ubGVuZ3RoLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLmZsYXRNYXAoKHYsIGkpID0+IHtcclxuXHRcdGxldCBbeCwgLi4ueXNdID0gdjtcclxuXHRcdHJldHVybiBBcnJheSh2TltpXSkuZmlsbCgpLm1hcCgoXywgaikgPT4ge1xyXG5cdFx0XHRsZXQgal9keSA9IGogKiBkeTtcclxuXHRcdFx0cmV0dXJuIFt4ICsgaiAqIGR4LCB5cy5tYXAoeSA9PiB5ICsgal9keSldO1xyXG5cdFx0fSk7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBbW3gsIHlzLi4uXSwgLi4uXVxyXG4vLyB3aGVyZSB3ID0gbGVuZ3RoIG9mIHlcclxuZnVuY3Rpb24gcmVhZF9yZXBsYWNlbWVudF90YWJsZSh3LCBuZXh0KSB7IFxyXG5cdGxldCBuID0gMSArIG5leHQoKTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZChuLCAxK3csIG5leHQpO1xyXG5cdHJldHVybiBtLm1hcCh2ID0+IFt2WzBdLCB2LnNsaWNlKDEpXSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiByZWFkX3RyaWUobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgc29ydGVkID0gcmVhZF9zb3J0ZWQobmV4dCk7IFxyXG5cdGV4cGFuZChkZWNvZGUoW10pLCBbXSk7XHJcblx0cmV0dXJuIHJldDsgLy8gbm90IHNvcnRlZFxyXG5cdGZ1bmN0aW9uIGRlY29kZShRKSB7IC8vIGNoYXJhY3RlcnMgdGhhdCBsZWFkIGludG8gdGhpcyBub2RlXHJcblx0XHRsZXQgUyA9IG5leHQoKTsgLy8gc3RhdGU6IHZhbGlkLCBzYXZlLCBjaGVja1xyXG5cdFx0bGV0IEIgPSByZWFkX2FycmF5X3doaWxlKCgpID0+IHsgLy8gYnVja2V0cyBsZWFkaW5nIHRvIG5ldyBub2Rlc1xyXG5cdFx0XHRsZXQgY3BzID0gcmVhZF9zb3J0ZWQobmV4dCkubWFwKGkgPT4gc29ydGVkW2ldKTtcclxuXHRcdFx0aWYgKGNwcy5sZW5ndGgpIHJldHVybiBkZWNvZGUoY3BzKTtcclxuXHRcdH0pO1xyXG5cdFx0cmV0dXJuIHtTLCBCLCBRfTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gZXhwYW5kKHtTLCBCfSwgY3BzLCBzYXZlZCkge1xyXG5cdFx0aWYgKFMgJiA0ICYmIHNhdmVkID09PSBjcHNbY3BzLmxlbmd0aC0xXSkgcmV0dXJuO1xyXG5cdFx0aWYgKFMgJiAyKSBzYXZlZCA9IGNwc1tjcHMubGVuZ3RoLTFdO1xyXG5cdFx0aWYgKFMgJiAxKSByZXQucHVzaChjcHMpOyBcclxuXHRcdGZvciAobGV0IGJyIG9mIEIpIHtcclxuXHRcdFx0Zm9yIChsZXQgY3Agb2YgYnIuUSkge1xyXG5cdFx0XHRcdGV4cGFuZChiciwgWy4uLmNwcywgY3BdLCBzYXZlZCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn1cblxuZnVuY3Rpb24gaGV4X2NwKGNwKSB7XHJcblx0cmV0dXJuIGNwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1b3RlX2NwKGNwKSB7XHJcblx0cmV0dXJuIGB7JHtoZXhfY3AoY3ApfX1gOyAvLyByYWZmeSBjb252ZW50aW9uOiBsaWtlIFwiXFx1e1h9XCIgdy9vIHRoZSBcIlxcdVwiXHJcbn1cclxuXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBsb2RlX2NwKHMpIHtcclxuXHRyZXR1cm4gWy4uLnNdLm1hcChjID0+IGMuY29kZVBvaW50QXQoMCkpO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGV4cGxvZGVfY3AocykgeyAvLyB0aGlzIGlzIGFib3V0IDJ4IGZhc3RlclxyXG5cdGxldCBjcHMgPSBbXTtcclxuXHRmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcclxuXHRcdGxldCBjcCA9IHMuY29kZVBvaW50QXQocG9zKTtcclxuXHRcdHBvcyArPSBjcCA8IDB4MTAwMDAgPyAxIDogMjtcclxuXHRcdGNwcy5wdXNoKGNwKTtcclxuXHR9XHJcblx0cmV0dXJuIGNwcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyX2Zyb21fY3BzKGNwcykge1xyXG5cdGNvbnN0IGNodW5rID0gNDA5NjtcclxuXHRsZXQgbGVuID0gY3BzLmxlbmd0aDtcclxuXHRpZiAobGVuIDwgY2h1bmspIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMpO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XHJcblx0XHRidWYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMuc2xpY2UoaSwgaSArPSBjaHVuaykpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZV9hcnJheXMoYSwgYikge1xyXG5cdGxldCBuID0gYS5sZW5ndGg7XHJcblx0bGV0IGMgPSBuIC0gYi5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGMgPT0gMCAmJiBpIDwgbjsgaSsrKSBjID0gYVtpXSAtIGJbaV07XHJcblx0cmV0dXJuIGM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5X3JlcGxhY2UodiwgYSwgYikge1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IG5leHQgPSB2LmluZGV4T2YoYSwgcHJldik7XHJcblx0XHRpZiAobmV4dCA8IDApIGJyZWFrO1xyXG5cdFx0dltuZXh0XSA9IGI7IFxyXG5cdFx0cHJldiA9IG5leHQgKyAxO1xyXG5cdH1cclxufVxuXG4vLyBjcmVhdGVkIDIwMjQtMDktMTNUMDY6NDI6NDUuNjc1WlxuLy8gY29tcHJlc3NlZCBiYXNlNjQtZW5jb2RlZCBibG9iIGZvciBpbmNsdWRlLW5mIGRhdGFcbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9ibG9iL21haW4vc3JjL21ha2UuanNcbi8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcyNzZWN1cml0eVxuLy8gU0hBLTI1NjogYTc5ZDVmOWIxODc5YTdiNDE2YWE2NTlmNGEzZDc4OGY4MGE4Y2Y1ZjBhYjk1NWE0NTY1OTJjMDJmNTU2YTI4Y1xudmFyIENPTVBSRVNTRUQgPSAnQUVVRFZnSExDR01BVHdEVUFESUFkQUFoQURRQUZBQXRBQlFBSVFBUEFDY0FEUUFTQUFvQUdBQUpBQklBQ1FBUkFBVUFDd0FGQUF3QUJRQVFBQU1BQndBRUFBb0FCUUFKQUFJQUNnQUJBQVFBRkFBTEFBSUFDd0FCQUFJQUFRQUhBQU1BQXdBRUFBc0FEQUFNQUF3QUN3QU5BQTBBQXdBS0FBa0FCQUFkQUFZQVp3RFRBZVlETXdDeENsOEI4eGhaQXFmb0MxOTBVR2NUaGdCdXJ3ZjdQVDA5UGIwOUFqZ0p1bThPakRsbHhIWVVLWEFQeHpxNnRBQkF4Z0s4eXNVdldBZ01QVDA5UFQwOVBTczZMVDJIY2dXWFd3RkxvU01FRUVsNVJGVk1Ldk8wWFE4RXhEZEpNbklnUGk4OXVqMDBNc3ZCWHhFUEFHUENEd0JuUUtvRWJ3UndCSEVFY2dSekJIUUVkUVIyQkhjRWVBUjZCSHNFZkFSK0JJQUVnZm5kQlFvQllnVUxBV0lGREFGaUJOY0UyQVRaQlJBRkVRVXZCZEFMRkFzVkRQY05CdzEzRFljT01BNHhEak1CNEJsbEhJMEIyZ3JiQU1EcEhMa1E3UUhWQVBSTlFRRm5HUlVFZzB5RUIydWFKRjhBSnBJQnBvYjVBRVJTTUFLTm9BWHFhUUxVQk1DekVpQytBWjRFV1JKSkZiRXU3UURRTEFSdEViZ0VDeER3QWIvUnlBazFBVjRuRDJjRVFRS1RBenNBR3BvYldnQWFoQUdQQ3J5c2R5ME9BS3dBZkZJY0JBUUZVbW9BL1B0WkFEa0JJYWRWajJVTVVneDVJbDRBTlFDOXZBSVRBZFFaV3hEekFMTjlBaHNaVndJY0dTa0NCQWdYT2hHN0FxTVo0TTcrMU0wVUFQRE5BV3NDK21jSkRlOEFBUUE5OXprRVhMSUN5UW96QW82bEFvYmNQNUp2alFMRnp3S0Q5Z1UvT0Q4RkVRQ3RFUUw2YlcrbkFLVUV2empESHN1UnlVdk9GSGNhY1V6NUFxSUZSU0Uya3pzQkVRQ3VhUUw1RFFUbGNnTzZ0d1NwVGlVZ0N3SUZDQVVYQkhRRXFRVjZzd0FWeFVsbVRtc0N3anFzUC93S0pRbVhiNzkzVWdaQkVCc25wUkQzRERNQnRRRTdEZTFMMkFUeEJqc0V5Ujk5R1JrUHpaV2NDS1V0M1F6dEp1TXVvWUJhSS9VcWd3WHRTL1E4M1F0TlVXZ1BXUXRsQ2VNNlk0Rk9BeUVCRFNLTEN0ME5PUWh0RVBNS3lXc041UkZGQnprRDFVbWFBS1VIQVFzUkhUVVZ0U1lRWXF3TENUbDNCdnNhOWd1UEpxOFRLWHI4QmRNYUlRWk5BU2thL3dEUEx1ZUZzRm94WEJ4UFh3WURDeVVqeHhTb1VDQU5KVUMzZUVnYUd3Y1ZKYWtDa1VOd1NvZFJOaDZUSWZZOFBRMW1MaE5SZkFmMVBBVVpUd3VCUEo1R3EwVU9FZEkralQxSUlrbE1MQVExZnl3dko0c0p6dytGRExsOGNnRlpDU0VKc1F4eEV6RVJGemZGQ0RrSEdTMlhKQ2NWQ0NGR2xXQ2FCUGVmQS9NVDBRTUxCVDhKUVFjVEE3VWNMUk11RlNrRkRZRWsxd0x6TnRVdXN3S1BWb0FCRndYTER5VWYzeEJRUitBTzZRaWJBbVVEZ3lYckFDMFZJUUFYSXBzSVEyTUFYNC9ZVXdVdXl3akhhbXdqZEFObkZPZGhFWE1Ia1E1WEI2Y2NNeFcvSE9Gd3lGNExoZ2dvbzY4Sld3RjFDWmtCWHdUakNBazFXNHlnSUVGblU0dFlHSnNnWVVFL1hmd0NNUXhsRlo5RXZZZDRBb3NQYXhJYkFUVUJjd2M1RFFFQ2R4SHRFV3NRbFFqcmhnUTF0VFA0T2lVRVR5R0RJQkVLSndOUGJNNExKeWI1RFBocEFhTVNZZ01NTkQxMzdtZXJZTFlrRi8wSEdUTEZRV0FoOFF1U1Q4ME1uQnJCR0VKVUxobmtCNzhEOHhyekorcEJWd1gvQTZNREV6cE5NKzRFdlF0cENJc0pQd0JKRHFNWEI5Y1lhZ3B4ak5BQk1Zc0J0NWtEVjVHREFtK1BCamNIQ3dCbkM0Y0ZlZVVBSFFLbkNLTUFCUURQQTFjQU9RS3RCNTBBR1FDRlFRRTlBeWN2QVNIbEFvOERrd2d4eXdHVkx3SHpLUVFid3d3VkFQYzNia29DdzdFQ2dHcG1vZ1hkV0FLT0FrazFBVTBsQkFWT1IxRURyM0hoQU5zQVN3WVQzMGNCRmF0S3l4cmpRd0hmYnlzQXh3RDdBQVUxQndWQkFjMEI4MjBBdHdGZkN6RUpvck8xQVUzcEtRQ0RBQlZyQWRjQ2lRRGRBRFVBZi9FQlV3Qk5CVm41QmRNQ1Qwa0JFVEVZSzFkaEFic0RId0V6QVEwQWVRYkxqYVhKQng4RWJRZlRBaEFiRmVFQzd5NEh0UUVESXQ4VHpVTEZBcjNlVmFGZ0FtU0JBbUpDVzAydld6Y2dBcUgzQW1pWUFtWUpBcCtFT0JzTEFtWTdBbVltQkc0RWZ3Ti9Fd04ra2prR09YY1hPWUk2SXlNQ2JCMENNalk0Q2dKdHh3SnRydStLTTJkRkt3Rm5BTjRBNFFCS0JRZVlESTBBL2d2Q0FBMjFBbmN2QW5haVB3SjVTME1DZUxvZFhOdEZya2JYQW53L0FucklBbjBKQW56d0JWa0ZJRWdBU0gxakpBS0JiUUtBQUFLQUJRSi9ya2xZU2xzVkYwck1BdEVCQXRETVN5Y0RpRThEaCtaRXhaRXlBdktoWFFNREE2NUx6a3d0SlFQUFRVeE5yd0tMUHdLSzJNRWJCeDFEWndXM0FvNDNBbzVjUUplQkFvN1pBbzVjZUZHMFV6VUtVdFJVaFFLVCt3S1REQURwQUJ4VkhsV3ZWZEFHTEJzcGxZWXk0WGhtUlRzNUFwZWZBdSt5V0NHb0FGa2xBcGFQQXBaOG5BQ3BXYXhhQ1lGTkFEc0NsclVDbGs1Y1JGelJBcG5MQXBsa1hNcGRCeGtDbkpzNXdqcWRBcHdXQXArYkFwNjRpZ0FkRHpFcUR3S2Q4UUtla2dDMVBXRTBZZThDbnRNQ29HNEJxUUtlbng4Q25rNmxZOGhrSnlVckFpZXZBaVorQXFEN0FxQk1BcUxkQXFIRUFxWXZBcVhPQXFmL0FIMENwL0pvZkdpeEFBTkphaHhxMFFLczR3S3NyZ0t0WndLdEFnSlhIUUpWM0FLeDRkY0RIMDVzbHdLeXZRMENzdWdYYk9CdFkyMUlYd01selFLMlhEcy9icEFES1VVQ3VGNEN1VWNWQXJrcWQzQTJjT0VDdlJrQ3U5cHdsZ015RVFLK2lISUNBek54QXI0YWN5SnpUd0xEeXdMREJIT0NkRXMxUlhUZ0F6eW5BenlhQXoyL0FzVjhBc1pIQXNZUWlRTElhVkVDeUVRQ3lVOEN5UzRDWkowQzNkSjRlV0Y0cm5rbFM5QURHS05uQWdKaDlCbnpsU1I3QzE2U1hyc1JBczlyQXM5c0wwdFQwdk1UbndER3JRTFBjd0VwNmdOT0VuNUxCUUxjSndMYmlnTFNUd05TWEFOVFh3RUJBMVdNZ0lrL0FNc1c3V0JGZ2h5QzA0TE9nNDBDMnNjQzJkNkVFSVJKcHp3RGhxVUFMd05rRG9aeFdma0FWUUxmWlFMZXVITjNBdUl2N1JRQjh6QW5BZlNiQWZMU2h3THI4d0xwY0hrQzZ2a0M2dVFBK1VjQnVRTHVpUUxybkphcWx3TUM3ajhEaGVDWWVYRGdjYUVDOHdNQWFRT09GcG1UQXZjVEE1RnVBNUtIQXZlWUF2blpBdmhtbWh5YXE3czNteDREbllNQy92b0JHd0E1bnh5ZnN3TUZqUU9tYWdPbTJRRFJ4UU1HYXFHSW9nVUpBd3hKQXRRQVB3TUE0VUVYVXdFUjh3TnJCNWRuQlFDVExTdTNyNzNiQVltWkZIOFJCRGtCK3lrRklRNmRDWjhBa3YwVHRSUXJ4UUwzTFNjQXBRQzNCYm1Pa1JjL3hxZHRRUzRVSm8wdUFVTUJnUHdCdFNZQWRRTU9CRzBBTEFJV0RLRUFBQW9DUFFKcUE5MERmZ1NSQVNCRkJTRjhDZ0FGQUVRQUV3QTJFZ0ozQVFBRjFRTnI3d3JGQWdEM0NwOG52N0czNVFHUklVRkNBZWtVZnhFMHdJa0FCQUFiQUZvQ1JRS0Vpd0FHT2xNNmxJMXRBTGc2anpyUUFJMDR3VHJjQUtVQTZBRExBVHFCT2pzNS9EbjVPM2FKT2xzN25vazZiemtZQVZZQk13RnNCUzgxWFRXZU5hMDFaalYxTmJZMXhUV0NOWkUxMGpYaE5aNDFyVFh1TmYwMXNqWEJOZ0kyRVRYR05kVTJGalluTmQ0MTdUWXVOajAyTGpVdElUWTZOajAyUERiSk53Z0VrRHhYTmpnMjNUY2dOdzgyeWlBM2lUY3dDZ1N3UEdjMkpEY1pOMnc2alRjaFF0UkRCMExnUXdzY0R3OEpteWh0S0ZGVkJnRHBmd0Rwc0FEK214UTkxd0xwTlNNQXJRQzlCYmVPa1JkTHhwdHpCTDhNREFNTUFRZ0RBQWtLQ3dzTENRb0dCQVZWQkkvRHZ3RHo5YjI5a2FVQ2IwUXRzUlROTHQ0ZUdCY1NIQU1aRmhZWkVoWUVBUkFFQlVFY1FSeEJIRUVjUVJ4QkhFRWFRUnhCSEVGQ1NUeEJQRWxJU1VoQk5rTTJRVFliTmtsSVNWbUJWSWdFTGdFYUpaa0M3YU1Bb1FDakJjR09teGROeHJzQnZ3R0pBYVFjRVowZVBDa2xNQUFoTXZBSU1BTDU0Z0M3Qm04RWVzY2p6UU1wQVJRcEtnRFVIcVN2QWo1R3F3cjdZck1VQUNUOUFOM3JscjNKRzltOHc5bElBWGx0cC92OGtmV2FJYWFSOU93cEFFUy9JM1pWYW1EWFNnQi9Vc09nQUc2RDB0cSs1Q0lxRTE1RmlBaFYzeUEyVmhDUTd0aittNnhYYUY1M0ZJZkdpL0lBWklza01HQWkyTVU3TURWSk5DYk16RVJ5SFppK29zZFB0bkZWYnZxNjUzTzhyd2FDeTRJQWY5T09vazY1QXFKVXRVcmlVZllzR1BQVmJlNmptMHM5bGJLbFBDVUtqZGtIc0ZzRWh2WDRrVDM5WkN0QUFid1Fkbi9oNFRwTzVoVEJ5V0FtcjVuK1d1d2hkZWd2NmJtdlg0THlPZXMzejIrY3VIdjJKRll3Vk1OdXEyZ3puOFlIVGpsVVFkMzlvc3lXZWk0TktsM0xBZGZ4bE84NzZoaDVFTnAvY092cHVJOWJGNTVndUV0aExMUE9YakQ0ZGt0VEgwNFA1VHZacldUTTBlNCtCSEp4ajdNTEFwWElGT3Mwc1dLaE5rRzhpd3VNNXdSODNteTZWM3dXMDZhYmhEelRYWWZPci9acEZYZ1h6bXY0ZDEyRkZ5UDAwL2RQR2JJVkdWNWFvOFV1Zkd6VXdwL0lIeDZ2L3dEV0pyOWlhb0N1bGhXd2xaN0E4cS9OTW9EMTIrbUJkTlJnSlluVGhSTHRNeDFCZ3d0dG44LzRRbjJDRGZPU3VwOUdWWEV2QTIxSUxncDBvd0hZeE5Pa3B3TFd6MEc3SytXUkVJRGpJelV6U244STk5Q3VKU21TcFB5SDBLZTYvTkVSWWlOeCszZG5jU2ViUG5PVW5uV0Q2MUFoSjFuL3RTTFptVTV3WU81R2ZnenlBWUptNlZMOTFMeFo4aEwxbGZ4aW1ReElETVJoSWVjUVpCbWVFNVIwWGxycHZ3cGxWckp3cGE4QkJDZHA5M0dQUDlseUJlWjJ6a1JyOTIwQ1IzY1liS3BLSGZvZ3ZtMG5WN1hkRHo2RWJqemx4QURDTWpTTFh1WHBJcHl1aXp5Mzl5WStJK0g5cm1wb0lGM1l3RWpsSDlNZ0dnV2NDTlRqSEVXTXFBYnBybjJPeDdyT0h1cGFWRTNsTnlnM250NVhhWklENlkrdW1sNUphK2FPUHUrQkkrRFpiaUpWZmFzcFVhZGFrV1VYNlRBNGRFVGtJcWRKSkhZblU0WjR5S3B0NXk4clZJYWhvTVVmOEE4a1d0QVFOQ1RianA3MWd4My96VmRxTnoxU3V0a3cwZ0ZJTVZtMkJGNFhkdi8wb2x3K05hRElSOUJiM0RQd2VaQTJLL2N3Ky9iK0F3eVdsOVpPUDY3QTluZXhtZVROamZkelBHZjlKNkU2Qk1QS2E1bEpoK3FOc2RVejNIQlVldlU3MWVRRkNxT2N4aUlZaGFjQWhoLzhQWDBKNURkU1ZpWjZXYXpERHg3Y3VrSk5wTWZFa1lMSjVBbzR2TG9WZDNkMjVQZzRxYVZhMnAyRDJMM1d2WVBKNVlmL0EvTVN4cHRqbGdYTC9LSnRQMlUwY1J2MkkwOUFUQWlXQ0pZdVJ3aWFwZUtGc3FtaTE4eU1NdWxEcDNIZGNJbGRxKzdqa3dzSlVPSExIQ3p6ekJ3NVhGdkwwQ0FtbzF1YjQ1Nno3emI3c2hrM0tQR0NMWnpyNDdvVDFrL2owNlhObkp2RzNVZHY2WHJQK3dzcVRCbFo1TWFOUHQ5Rk9zLzRCdC9qYS92YlZoVE5wQkZsOUdxN01xSU52R2xXS09Bd1F6d09aeStFelNkakFxS0pWVjJZY3NrVHVNOTRhSUsra2MvQVphWGlaTFBSRVVEcGtYSVY5NDdJRmZqKzg1VHJxUHFMZmtHY3hnYm9NUWpvc2YrYXorb2RMTlhkeXAxbUROR3NxU2RLL3BKMkNhMDRtdC80ZDZzMVgrbG5jT0VZYUdCQmVXNHBBcEdjamY3L1hKQ0ZiajNOM21GYitCdGxJY3c4WmlES29DbEZYOVJmMGJ4Q3F0THBpY09iS0p6QlZWSHIvNnU0c2lIMmhLNzVSTnY3dzlHZlRiaEpPUUJZaUZVWkFCeVk0cm4zN3RaQkhULy9rcUtzTmkzcnlMOUFxWEpSenFpTUlKTWhJTGpvaS9pOExWRXNidStJaDlic3lXMTZzZ1FxallMTzBxZGE2S2FDUEtqM0RRY3U2Q2ZWNWxLdGpTM1pDZHFMQVprT2V5OU1SK1F1dEpCR2l6L3IxNUdWRDZyQ1Z3SlI0VVVLQzRHTkprZkRmMDBPTVc4YVF0TFNBR0xYVjhNSWk5bWJibC9xUUVweENtMkw1aHV0Rlg0ZWtlTEg0UWdCV1VGS3MvMlZWTUt5NDZXdEZFNkFid2dtWW0vWjB5SGs1dmVESXJjbDJIcFZxYi9yU0UwUEM5RWJEekpFV3FlYVBoaDd2RjM2OVVtcTJrU2lCM3M1ckJJNmMvN045YmtSdTRoMm4rL2g1blN3eSs3bisvSSs2b1hRVkFObzJKYjV6RHd0aUJQZjF5U0N6SGRUNnlKU2hNenFTUlpmbnlrWDQ5Q2FGYXhob1ZGNFBCaEV1RUNKMVByRllTcG1IdXlZc2wxNERUQVY5WnhSbXMxWGlSL2tCcmpoWmppZE90MFVOZStHU21sN1hOZ3BWdzhZc1VUbVpYTFRLKzZpWW55Vy93WVIxVzRVWHdPaTE0eHBGUk9IYjZIY1p6a3NnRjVEYkwyQUZYektOd0hVMmFkamRBWStLQ3lNL2N3UlRCa2txL2EyMjdOSTBxNkRSMk1rTUNSdTYyMHQ3OWJHY1lVbUFDdHFOM21rLzB1TndkM0pTWEhxRTFremY2WXlqMFcyMDgzSk5EUm5JWERsZ0J4SjZ1ZjU4Tk4xZjZGUWlSQ1dCNGVnRjhRRHg3NEFpeFY4b1R5dzdQbHVJanIzL3JqL1d6Z3dQU3E0eFBvamFGN1YweHFHMnU1dGkyTDFoNnlZSHY3M0lzcnVrcjBrVVJESUVqQ2xCc0J4N2tkY1hVeGFZTVMwc3lUM3ltTHpEenNsTkRXUU9UMVRhbzFZTm1KSEFSVWVuaENrbVY5dHFDUEdJNUdxWmFScGtpUHh5am9uY1dqeU9IWUdxdmJ2UlgrQm4xcG43RWhSTlhhMWxxSlBtb2VONVZxZHFJRFBoRVZoRnN5RzBkNGlRRUlZWDB3WlViWTJYYlpXWWxwWi9sNjZJckREWTBxMUMxWXpCRHBIQzRoMDVZcUhRTHFTOWFueWwyMkpRNmxFdmp2ZEJ3TUhmRTd6MGx1Q1hEMzQvckZlRGEyVG1TZUVBeWtTcFlPNWoxRy9uc2dwUjNxbjBxYVFFbUxqbm5MZmN6K3Zlb1lxUG5ScW1SR3dDSjZGSjNHbS9aMS9hVlg1UFNiMDNNTW5qQWY0MXd3NTRzRDVrOEZya2ZCUCtLMGIxTXJZcGFwV2p0cFpmdmUySFZmNGlja1gzTEtTT2h1N3FJMVZkNGMxa05ybjJhankxdDR5OTNKaFY0Zm5XQ0txN09tRnBjcjdGamRKQ1hQVHFsMERycjE0SG8zWjg3K0dQUTRaL0RjVGlHcXR2WnhsUllpOGNOdWhYQUJ2ZVpJd05sL0JYMWh1aFZMYUZheDVPcXlwVXJRUnliOU9FM1NTa1BsRGR5NXVvNVhHZzJFSUdFakxZMU1PNWNyMWliZmlGV1Y3enNwY1Rna0JLa3dvNWpQeUFpbjA0THFpelpYYjJ0RFJnd0tKakd4NGNWazNuZ0FRaXh3Y3hqWUFnMlE3dm1VUi9ocHdJbk1kdzdPaEMycXlmNDF2VFBrdWRRQU9SUzBEZEx0T0dReGI0ZkgyVllHc3ZKQ2tlV1BlVXd0ZjEvdHVJaHpYRVRob0NaenpTSnFxalV0YmFQSTNudEhtM1Q1dWY4NDloR1VBMHpVOG5pNVcrRUVuMy8wWTZvVWhRRnc5ejBhR2prbGpCYkFsRlhjMHk4Mkcyd2tkN1ZkZ1dhNUtUZ0pKTmpOd1pNZm1kblVJVW4xSlU1TGlXWDVVWkVaYlZsS1NONzZtbG1qVVIya3UrZnVjVE5sTzRJQUFhaG5MakJobHZRTlI5cGU5c3dHQmdxMFlSN1AzVkN5SS9zZVl3UTRRQnp5OVgrSFBlUGdvRjhXZkthSjRNQk9oTENHSGFlNlo4eGtOWHduaTlRQUt2VE50VkE1Nng4WUpmbFovVnZPTlJTbHNTTG1pU3lOTW5UalRhRTFrbzgxemt6R0VuVndFaGpDemx3SXFweG1wREFxd3NFbXRwZHIzeHBjN2kvWlgzZjJUelQzTTBGZHhJRVF2TzFqZ21taU4rRDFZcE1kdUF6RWhCdGoyT0JrTU4vcnY2cDdUaDRwU0g2ZjVhSDNhVHZ3RlRsN0VPU2dHQVNJN3R0eU1laHpwbTRBVnlLK2JGRWFGZzlnblpzU1VQcHNiQWUvMFJGaHJIK0VYWjEyWjd0aGY0ZHpOMStTbitHOFFyREExVkthTjRJRnhEMXJRejlYcTlDb2lpOVM5L2hQYlRHanlCd0ZIM0gxVWRRdXo1S3NnUERFSHVhNC9rUGcyR3AvSUlJdHNhTFdCcWlUOVhINDVNaVF4U29zR0o1NkgvMEYyY2pjQ0ZkNzJsMTY2NVJOSFVSZEMzbHNwSTc3ZXNmSnNsK3JYWGFia0F5N3Z4RFhHL1hHR2NLcHdpS0RQRmZ2TUVnamtBSGlsNFphMUYzNlJueXh4dmRJQXp2Z2ZIOGtudWtZRGNrMDd0YysrRFA0VGRXZUk3SFh1cTVZbDZWVkZyVVF0ZjY0L2RrWGV3bEtaU0hRbzZZdkNTcFJFQjBHRHJ6K1lzMkdmTzhudzJTd3JZd2FmODhBaWZ6bFB2UDE3YmYxbUkzQXVjY0p2QWpaSXBCbXF2aGFyS0ZBZWJFalZLZkdBd3BRaldvWGxtOUxST3NxOWJDazFVZVEzQ0p4SnFwcnpzc1MvUTA0SmVTMVJlQ0N1YkwzSjdzeDg2c3BrUDRlTnBwOTVVRis4Szc0OGljSXM4dmRJTEZrbGs5c2tRcWkxU282Y3gzWDkwNnB2eTF2eitLaXBUSjhmaVZKeHNWNU1tVDBYd0EnO1xuXG4vLyBodHRwczovL3VuaWNvZGUub3JnL3JlcG9ydHMvdHIxNS9cclxuLy8gZm9yIHJlZmVyZW5jZSBpbXBsZW1lbnRhdGlvblxyXG4vLyBzZWU6IC9kZXJpdmUvbmYuanNcclxuXHJcblxyXG4vLyBhbGdvcml0aG1pYyBoYW5ndWxcclxuLy8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvdmVyc2lvbnMvVW5pY29kZTE1LjAuMC9jaDAzLnBkZiAocGFnZSAxNDQpXHJcbmNvbnN0IFMwID0gMHhBQzAwO1xyXG5jb25zdCBMMCA9IDB4MTEwMDtcclxuY29uc3QgVjAgPSAweDExNjE7XHJcbmNvbnN0IFQwID0gMHgxMUE3O1xyXG5jb25zdCBMX0NPVU5UID0gMTk7XHJcbmNvbnN0IFZfQ09VTlQgPSAyMTtcclxuY29uc3QgVF9DT1VOVCA9IDI4O1xyXG5jb25zdCBOX0NPVU5UID0gVl9DT1VOVCAqIFRfQ09VTlQ7XHJcbmNvbnN0IFNfQ09VTlQgPSBMX0NPVU5UICogTl9DT1VOVDtcclxuY29uc3QgUzEgPSBTMCArIFNfQ09VTlQ7XHJcbmNvbnN0IEwxID0gTDAgKyBMX0NPVU5UO1xyXG5jb25zdCBWMSA9IFYwICsgVl9DT1VOVDtcclxuY29uc3QgVDEgPSBUMCArIFRfQ09VTlQ7XHJcblxyXG5mdW5jdGlvbiB1bnBhY2tfY2MocGFja2VkKSB7XHJcblx0cmV0dXJuIChwYWNrZWQgPj4gMjQpICYgMHhGRjtcclxufVxyXG5mdW5jdGlvbiB1bnBhY2tfY3AocGFja2VkKSB7XHJcblx0cmV0dXJuIHBhY2tlZCAmIDB4RkZGRkZGO1xyXG59XHJcblxyXG5sZXQgU0hJRlRFRF9SQU5LLCBFWENMVVNJT05TLCBERUNPTVAsIFJFQ09NUDtcclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBuZl9kZWluaXQoKSB7XHJcbi8vIFx0aWYgKCFTSElGVEVEX1JBTkspIHJldHVybjtcclxuLy8gXHRTSElGVEVEX1JBTksgPSBFWENMVVNJT05TID0gREVDT01QID0gUkVDT01QID0gdW5kZWZpbmVkO1xyXG4vLyB9XHJcblxyXG5mdW5jdGlvbiBpbml0JDEoKSB7XHJcblx0Ly9jb25zb2xlLnRpbWUoJ25mJyk7XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEKTtcclxuXHRTSElGVEVEX1JBTksgPSBuZXcgTWFwKHJlYWRfc29ydGVkX2FycmF5cyhyKS5mbGF0TWFwKCh2LCBpKSA9PiB2Lm1hcCh4ID0+IFt4LCAoaSsxKSA8PCAyNF0pKSk7IC8vIHByZS1zaGlmdGVkXHJcblx0RVhDTFVTSU9OUyA9IG5ldyBTZXQocmVhZF9zb3J0ZWQocikpO1xyXG5cdERFQ09NUCA9IG5ldyBNYXAoKTtcclxuXHRSRUNPTVAgPSBuZXcgTWFwKCk7XHJcblx0Zm9yIChsZXQgW2NwLCBjcHNdIG9mIHJlYWRfbWFwcGVkKHIpKSB7XHJcblx0XHRpZiAoIUVYQ0xVU0lPTlMuaGFzKGNwKSAmJiBjcHMubGVuZ3RoID09IDIpIHtcclxuXHRcdFx0bGV0IFthLCBiXSA9IGNwcztcclxuXHRcdFx0bGV0IGJ1Y2tldCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdFx0YnVja2V0ID0gbmV3IE1hcCgpO1xyXG5cdFx0XHRcdFJFQ09NUC5zZXQoYSwgYnVja2V0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRidWNrZXQuc2V0KGIsIGNwKTtcclxuXHRcdH1cclxuXHRcdERFQ09NUC5zZXQoY3AsIGNwcy5yZXZlcnNlKCkpOyAvLyBzdG9yZWQgcmV2ZXJzZWRcclxuXHR9XHJcblx0Ly9jb25zb2xlLnRpbWVFbmQoJ25mJyk7XHJcblx0Ly8gMjAyMzA5MDU6IDExbXNcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfaGFuZ3VsKGNwKSB7XHJcblx0cmV0dXJuIGNwID49IFMwICYmIGNwIDwgUzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VfcGFpcihhLCBiKSB7XHJcblx0aWYgKGEgPj0gTDAgJiYgYSA8IEwxICYmIGIgPj0gVjAgJiYgYiA8IFYxKSB7XHJcblx0XHRyZXR1cm4gUzAgKyAoYSAtIEwwKSAqIE5fQ09VTlQgKyAoYiAtIFYwKSAqIFRfQ09VTlQ7XHJcblx0fSBlbHNlIGlmIChpc19oYW5ndWwoYSkgJiYgYiA+IFQwICYmIGIgPCBUMSAmJiAoYSAtIFMwKSAlIFRfQ09VTlQgPT0gMCkge1xyXG5cdFx0cmV0dXJuIGEgKyAoYiAtIFQwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IHJlY29tcCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdHJlY29tcCA9IHJlY29tcC5nZXQoYik7XHJcblx0XHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVjb21wO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvbXBvc2VkKGNwcykge1xyXG5cdGlmICghU0hJRlRFRF9SQU5LKSBpbml0JDEoKTtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGxldCBjaGVja19vcmRlciA9IGZhbHNlO1xyXG5cdGZ1bmN0aW9uIGFkZChjcCkge1xyXG5cdFx0bGV0IGNjID0gU0hJRlRFRF9SQU5LLmdldChjcCk7XHJcblx0XHRpZiAoY2MpIHtcclxuXHRcdFx0Y2hlY2tfb3JkZXIgPSB0cnVlO1xyXG5cdFx0XHRjcCB8PSBjYztcclxuXHRcdH1cclxuXHRcdHJldC5wdXNoKGNwKTtcclxuXHR9XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRpZiAoY3AgPCAweDgwKSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9IGVsc2UgaWYgKGlzX2hhbmd1bChjcCkpIHtcclxuXHRcdFx0XHRsZXQgc19pbmRleCA9IGNwIC0gUzA7XHJcblx0XHRcdFx0bGV0IGxfaW5kZXggPSBzX2luZGV4IC8gTl9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHZfaW5kZXggPSAoc19pbmRleCAlIE5fQ09VTlQpIC8gVF9DT1VOVCB8IDA7XHJcblx0XHRcdFx0bGV0IHRfaW5kZXggPSBzX2luZGV4ICUgVF9DT1VOVDtcclxuXHRcdFx0XHRhZGQoTDAgKyBsX2luZGV4KTtcclxuXHRcdFx0XHRhZGQoVjAgKyB2X2luZGV4KTtcclxuXHRcdFx0XHRpZiAodF9pbmRleCA+IDApIGFkZChUMCArIHRfaW5kZXgpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBtYXBwZWQgPSBERUNPTVAuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAobWFwcGVkKSB7XHJcblx0XHRcdFx0XHRidWYucHVzaCguLi5tYXBwZWQpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRhZGQoY3ApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWJ1Zi5sZW5ndGgpIGJyZWFrO1xyXG5cdFx0XHRjcCA9IGJ1Zi5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGNoZWNrX29yZGVyICYmIHJldC5sZW5ndGggPiAxKSB7XHJcblx0XHRsZXQgcHJldl9jYyA9IHVucGFja19jYyhyZXRbMF0pO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCByZXQubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0bGV0IGNjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHRcdGlmIChjYyA9PSAwIHx8IHByZXZfY2MgPD0gY2MpIHtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0bGV0IGogPSBpLTE7XHJcblx0XHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdFx0bGV0IHRtcCA9IHJldFtqKzFdO1xyXG5cdFx0XHRcdHJldFtqKzFdID0gcmV0W2pdO1xyXG5cdFx0XHRcdHJldFtqXSA9IHRtcDtcclxuXHRcdFx0XHRpZiAoIWopIGJyZWFrO1xyXG5cdFx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0Wy0tal0pO1xyXG5cdFx0XHRcdGlmIChwcmV2X2NjIDw9IGNjKSBicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gdW5wYWNrX2NjKHJldFtpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VkX2Zyb21fZGVjb21wb3NlZCh2KSB7XHJcblx0bGV0IHJldCA9IFtdO1xyXG5cdGxldCBzdGFjayA9IFtdO1xyXG5cdGxldCBwcmV2X2NwID0gLTE7XHJcblx0bGV0IHByZXZfY2MgPSAwO1xyXG5cdGZvciAobGV0IHBhY2tlZCBvZiB2KSB7XHJcblx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocGFja2VkKTtcclxuXHRcdGxldCBjcCA9IHVucGFja19jcChwYWNrZWQpO1xyXG5cdFx0aWYgKHByZXZfY3AgPT0gLTEpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0LnB1c2goY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKHByZXZfY2MgPiAwICYmIHByZXZfY2MgPj0gY2MpIHtcclxuXHRcdFx0aWYgKGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwLCAuLi5zdGFjayk7XHJcblx0XHRcdFx0c3RhY2subGVuZ3RoID0gMDtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNvbXBvc2VkID0gY29tcG9zZV9wYWlyKHByZXZfY3AsIGNwKTtcclxuXHRcdFx0aWYgKGNvbXBvc2VkID49IDApIHtcclxuXHRcdFx0XHRwcmV2X2NwID0gY29tcG9zZWQ7XHJcblx0XHRcdH0gZWxzZSBpZiAocHJldl9jYyA9PSAwICYmIGNjID09IDApIHtcclxuXHRcdFx0XHRyZXQucHVzaChwcmV2X2NwKTtcclxuXHRcdFx0XHRwcmV2X2NwID0gY3A7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhY2sucHVzaChjcCk7XHJcblx0XHRcdFx0cHJldl9jYyA9IGNjO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChwcmV2X2NwID49IDApIHtcclxuXHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcdFxyXG5cdH1cclxuXHRyZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vLyBub3RlOiBjcHMgY2FuIGJlIGl0ZXJhYmxlXHJcbmZ1bmN0aW9uIG5mZChjcHMpIHtcclxuXHRyZXR1cm4gZGVjb21wb3NlZChjcHMpLm1hcCh1bnBhY2tfY3ApO1xyXG59XHJcbmZ1bmN0aW9uIG5mYyhjcHMpIHtcclxuXHRyZXR1cm4gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKGRlY29tcG9zZWQoY3BzKSk7XHJcbn1cblxuY29uc3QgSFlQSEVOID0gMHgyRDtcclxuY29uc3QgU1RPUCA9IDB4MkU7XHJcbmNvbnN0IFNUT1BfQ0ggPSAnLic7XHJcbmNvbnN0IEZFMEYgPSAweEZFMEY7XHJcbmNvbnN0IFVOSVFVRV9QSCA9IDE7XHJcblxyXG4vLyAyMDIzMDkxMzogcmVwbGFjZSBbLi4udl0gd2l0aCBBcnJheV9mcm9tKHYpIHRvIGF2b2lkIGxhcmdlIHNwcmVhZHNcclxuY29uc3QgQXJyYXlfZnJvbSA9IHggPT4gQXJyYXkuZnJvbSh4KTsgLy8gQXJyYXkuZnJvbS5iaW5kKEFycmF5KTtcclxuXHJcbmZ1bmN0aW9uIGdyb3VwX2hhc19jcChnLCBjcCkge1xyXG5cdC8vIDIwMjMwOTEzOiBrZWVwIHByaW1hcnkgYW5kIHNlY29uZGFyeSBkaXN0aW5jdCBpbnN0ZWFkIG9mIGNyZWF0aW5nIHZhbGlkIHVuaW9uXHJcblx0cmV0dXJuIGcuUC5oYXMoY3ApIHx8IGcuUS5oYXMoY3ApO1xyXG59XHJcblxyXG5jbGFzcyBFbW9qaSBleHRlbmRzIEFycmF5IHtcclxuXHRnZXQgaXNfZW1vamkoKSB7IHJldHVybiB0cnVlOyB9IC8vIGZyZWUgdGFnZ2luZyBzeXN0ZW1cclxufVxyXG5cclxubGV0IE1BUFBFRCwgSUdOT1JFRCwgQ00sIE5TTSwgRVNDQVBFLCBORkNfQ0hFQ0ssIEdST1VQUywgV0hPTEVfVkFMSUQsIFdIT0xFX01BUCwgVkFMSUQsIEVNT0pJX0xJU1QsIEVNT0pJX1JPT1Q7XHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gZW5zX2RlaW5pdCgpIHtcclxuLy8gXHRuZl9kZWluaXQoKTtcclxuLy8gXHRpZiAoIU1BUFBFRCkgcmV0dXJuO1xyXG4vLyBcdE1BUFBFRCA9IElHTk9SRUQgPSBDTSA9IE5TTSA9IEVTQ0FQRSA9IE5GQ19DSEVDSyA9IEdST1VQUyA9IFdIT0xFX1ZBTElEID0gV0hPTEVfTUFQID0gVkFMSUQgPSBFTU9KSV9MSVNUID0gRU1PSklfUk9PVCA9IHVuZGVmaW5lZDtcclxuLy8gfVxyXG5cclxuZnVuY3Rpb24gaW5pdCgpIHtcclxuXHRpZiAoTUFQUEVEKSByZXR1cm47XHJcblx0XHJcblx0bGV0IHIgPSByZWFkX2NvbXByZXNzZWRfcGF5bG9hZChDT01QUkVTU0VEJDEpO1xyXG5cdGNvbnN0IHJlYWRfc29ydGVkX2FycmF5ID0gKCkgPT4gcmVhZF9zb3J0ZWQocik7XHJcblx0Y29uc3QgcmVhZF9zb3J0ZWRfc2V0ID0gKCkgPT4gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpKTtcclxuXHRjb25zdCBzZXRfYWRkX21hbnkgPSAoc2V0LCB2KSA9PiB2LmZvckVhY2goeCA9PiBzZXQuYWRkKHgpKTtcclxuXHJcblx0TUFQUEVEID0gbmV3IE1hcChyZWFkX21hcHBlZChyKSk7IFxyXG5cdElHTk9SRUQgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG5cclxuXHQvKlxyXG5cdC8vIGRpcmVjdCBpbmNsdWRlIGZyb20gcGF5bG9hZCBpcyBzbWFsbGVyIHRoYW4gdGhlIGRlY29tcHJlc3Npb24gY29kZVxyXG5cdGNvbnN0IEZFTkNFRCA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRsZXQgY3AgPSByKCk7XHJcblx0XHRpZiAoY3ApIHJldHVybiBbY3AsIHJlYWRfc3RyKHIoKSldO1xyXG5cdH0pKTtcclxuXHQqL1xyXG5cdC8vIDIwMjMwMjE3OiB3ZSBzdGlsbCBuZWVkIGFsbCBDTSBmb3IgcHJvcGVyIGVycm9yIGZvcm1hdHRpbmdcclxuXHQvLyBidXQgbm9ybSBvbmx5IG5lZWRzIE5TTSBzdWJzZXQgdGhhdCBhcmUgcG90ZW50aWFsbHktdmFsaWRcclxuXHRDTSA9IHJlYWRfc29ydGVkX2FycmF5KCk7XHJcblx0TlNNID0gbmV3IFNldChyZWFkX3NvcnRlZF9hcnJheSgpLm1hcChpID0+IENNW2ldKSk7XHJcblx0Q00gPSBuZXcgU2V0KENNKTtcclxuXHRcclxuXHRFU0NBUEUgPSByZWFkX3NvcnRlZF9zZXQoKTsgLy8gY2hhcmFjdGVycyB0aGF0IHNob3VsZCBub3QgYmUgcHJpbnRlZFxyXG5cdE5GQ19DSEVDSyA9IHJlYWRfc29ydGVkX3NldCgpOyAvLyBvbmx5IG5lZWRlZCB0byBpbGx1c3RyYXRlIGVuc190b2tlbml6ZSgpIHRyYW5zZm9ybWF0aW9uc1xyXG5cclxuXHRsZXQgY2h1bmtzID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIpO1xyXG5cdGxldCB1bnJlc3RyaWN0ZWQgPSByKCk7XHJcblx0Ly9jb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiBuZXcgU2V0KHJlYWRfc29ydGVkX2FycmF5KCkuZmxhdE1hcChpID0+IGNodW5rc1tpXSkuY29uY2F0KHJlYWRfc29ydGVkX2FycmF5KCkpKTtcclxuXHRjb25zdCByZWFkX2NodW5rZWQgPSAoKSA9PiB7XHJcblx0XHQvLyAyMDIzMDkyMTogYnVpbGQgc2V0IGluIHBhcnRzLCAyeCBmYXN0ZXJcclxuXHRcdGxldCBzZXQgPSBuZXcgU2V0KCk7XHJcblx0XHRyZWFkX3NvcnRlZF9hcnJheSgpLmZvckVhY2goaSA9PiBzZXRfYWRkX21hbnkoc2V0LCBjaHVua3NbaV0pKTtcclxuXHRcdHNldF9hZGRfbWFueShzZXQsIHJlYWRfc29ydGVkX2FycmF5KCkpO1xyXG5cdFx0cmV0dXJuIHNldDsgXHJcblx0fTtcclxuXHRHUk9VUFMgPSByZWFkX2FycmF5X3doaWxlKGkgPT4ge1xyXG5cdFx0Ly8gbWluaWZpZXIgcHJvcGVydHkgbWFuZ2xpbmcgc2VlbXMgdW5zYWZlXHJcblx0XHQvLyBzbyB0aGVzZSBhcmUgbWFudWFsbHkgcmVuYW1lZCB0byBzaW5nbGUgY2hhcnNcclxuXHRcdGxldCBOID0gcmVhZF9hcnJheV93aGlsZShyKS5tYXAoeCA9PiB4KzB4NjApO1xyXG5cdFx0aWYgKE4ubGVuZ3RoKSB7XHJcblx0XHRcdGxldCBSID0gaSA+PSB1bnJlc3RyaWN0ZWQ7IC8vIHVucmVzdHJpY3RlZCB0aGVuIHJlc3RyaWN0ZWRcclxuXHRcdFx0TlswXSAtPSAzMjsgLy8gY2FwaXRhbGl6ZVxyXG5cdFx0XHROID0gc3RyX2Zyb21fY3BzKE4pO1xyXG5cdFx0XHRpZiAoUikgTj1gUmVzdHJpY3RlZFske059XWA7XHJcblx0XHRcdGxldCBQID0gcmVhZF9jaHVua2VkKCk7IC8vIHByaW1hcnlcclxuXHRcdFx0bGV0IFEgPSByZWFkX2NodW5rZWQoKTsgLy8gc2Vjb25kYXJ5XHJcblx0XHRcdGxldCBNID0gIXIoKTsgLy8gbm90LXdoaXRlbGlzdGVkLCBjaGVjayBmb3IgTlNNXHJcblx0XHRcdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHRcdFx0LypcclxuXHRcdFx0bGV0IFYgPSBbLi4uUCwgLi4uUV0uc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gZGVyaXZlOiBzb3J0ZWQgdmFsaWRcclxuXHRcdFx0bGV0IE0gPSByKCktMTsgLy8gbnVtYmVyIG9mIGNvbWJpbmluZyBtYXJrXHJcblx0XHRcdGlmIChNIDwgMCkgeyAvLyB3aGl0ZWxpc3RlZFxyXG5cdFx0XHRcdE0gPSBuZXcgTWFwKHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0bGV0IGkgPSByKCk7XHJcblx0XHRcdFx0XHRpZiAoaSkgcmV0dXJuIFtWW2ktMV0sIHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0XHRcdFx0XHRsZXQgdiA9IHJlYWRfYXJyYXlfd2hpbGUocik7XHJcblx0XHRcdFx0XHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHYubWFwKHggPT4geC0xKTtcclxuXHRcdFx0XHRcdH0pXTtcclxuXHRcdFx0XHR9KSk7XHJcblx0XHRcdH0qL1xyXG5cdFx0XHRyZXR1cm4ge04sIFAsIFEsIE0sIFJ9O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHQvLyBkZWNvZGUgY29tcHJlc3NlZCB3aG9sZXNcclxuXHRXSE9MRV9WQUxJRCA9IHJlYWRfc29ydGVkX3NldCgpO1xyXG5cdFdIT0xFX01BUCA9IG5ldyBNYXAoKTtcclxuXHRsZXQgd2hvbGVzID0gcmVhZF9zb3J0ZWRfYXJyYXkoKS5jb25jYXQoQXJyYXlfZnJvbShXSE9MRV9WQUxJRCkpLnNvcnQoKGEsIGIpID0+IGEtYik7IC8vIG11c3QgYmUgc29ydGVkXHJcblx0d2hvbGVzLmZvckVhY2goKGNwLCBpKSA9PiB7XHJcblx0XHRsZXQgZCA9IHIoKTsgXHJcblx0XHRsZXQgdyA9IHdob2xlc1tpXSA9IGQgPyB3aG9sZXNbaS1kXSA6IHtWOiBbXSwgTTogbmV3IE1hcCgpfTtcclxuXHRcdHcuVi5wdXNoKGNwKTsgLy8gYWRkIHRvIG1lbWJlciBzZXRcclxuXHRcdGlmICghV0hPTEVfVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRXSE9MRV9NQVAuc2V0KGNwLCB3KTsgIC8vIHJlZ2lzdGVyIHdpdGggd2hvbGUgbWFwXHJcblx0XHR9XHJcblx0fSk7XHJcblxyXG5cdC8vIGNvbXB1dGUgY29uZnVzYWJsZS1leHRlbnQgY29tcGxlbWVudHNcclxuXHQvLyB1c2FnZTogV0hPTEVfTUFQLmdldChjcCkuTS5nZXQoY3ApID0gY29tcGxlbWVudCBzZXRcclxuXHRmb3IgKGxldCB7ViwgTX0gb2YgbmV3IFNldChXSE9MRV9NQVAudmFsdWVzKCkpKSB7XHJcblx0XHQvLyBjb25uZWN0IGFsbCBncm91cHMgdGhhdCBoYXZlIGVhY2ggd2hvbGUgY2hhcmFjdGVyXHJcblx0XHRsZXQgcmVjcyA9IFtdO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0XHRsZXQgZ3MgPSBHUk9VUFMuZmlsdGVyKGcgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSk7XHJcblx0XHRcdGxldCByZWMgPSByZWNzLmZpbmQoKHtHfSkgPT4gZ3Muc29tZShnID0+IEcuaGFzKGcpKSk7XHJcblx0XHRcdGlmICghcmVjKSB7XHJcblx0XHRcdFx0cmVjID0ge0c6IG5ldyBTZXQoKSwgVjogW119O1xyXG5cdFx0XHRcdHJlY3MucHVzaChyZWMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJlYy5WLnB1c2goY3ApO1xyXG5cdFx0XHRzZXRfYWRkX21hbnkocmVjLkcsIGdzKTtcclxuXHRcdH1cclxuXHRcdC8vIHBlciBjaGFyYWN0ZXIgY2FjaGUgZ3JvdXBzIHdoaWNoIGFyZSBub3QgYSBtZW1iZXIgb2YgdGhlIGV4dGVudFxyXG5cdFx0bGV0IHVuaW9uID0gcmVjcy5mbGF0TWFwKHggPT4gQXJyYXlfZnJvbSh4LkcpKTsgLy8gYWxsIG9mIHRoZSBncm91cHMgdXNlZCBieSB0aGlzIHdob2xlXHJcblx0XHRmb3IgKGxldCB7RywgVn0gb2YgcmVjcykge1xyXG5cdFx0XHRsZXQgY29tcGxlbWVudCA9IG5ldyBTZXQodW5pb24uZmlsdGVyKGcgPT4gIUcuaGFzKGcpKSk7IC8vIGdyb3VwcyBub3QgY292ZXJlZCBieSB0aGUgZXh0ZW50XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0XHRNLnNldChjcCwgY29tcGxlbWVudCk7IC8vIHRoaXMgaXMgdGhlIHNhbWUgcmVmZXJlbmNlXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGNvbXB1dGUgdmFsaWQgc2V0XHJcblx0Ly8gMjAyMzA5MjQ6IFZBTElEIHdhcyB1bmlvbiBidXQgY2FuIGJlIHJlLXVzZWRcclxuXHRWQUxJRCA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDErIGdyb3Vwc1xyXG5cdGxldCBtdWx0aSA9IG5ldyBTZXQoKTsgLy8gZXhpc3RzIGluIDIrIGdyb3Vwc1xyXG5cdGNvbnN0IGFkZF90b191bmlvbiA9IGNwID0+IFZBTElELmhhcyhjcCkgPyBtdWx0aS5hZGQoY3ApIDogVkFMSUQuYWRkKGNwKTtcclxuXHRmb3IgKGxldCBnIG9mIEdST1VQUykge1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5QKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdFx0Zm9yIChsZXQgY3Agb2YgZy5RKSBhZGRfdG9fdW5pb24oY3ApO1xyXG5cdH1cclxuXHQvLyBkdWFsIHB1cnBvc2UgV0hPTEVfTUFQOiByZXR1cm4gcGxhY2Vob2xkZXIgaWYgdW5pcXVlIG5vbi1jb25mdXNhYmxlXHJcblx0Zm9yIChsZXQgY3Agb2YgVkFMSUQpIHtcclxuXHRcdGlmICghV0hPTEVfTUFQLmhhcyhjcCkgJiYgIW11bHRpLmhhcyhjcCkpIHtcclxuXHRcdFx0V0hPTEVfTUFQLnNldChjcCwgVU5JUVVFX1BIKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gYWRkIGFsbCBkZWNvbXBvc2VkIHBhcnRzXHJcblx0Ly8gc2VlIGRlcml2ZTogXCJWYWxpZCBpcyBDbG9zZWQgKHZpYSBCcnV0ZS1mb3JjZSlcIlxyXG5cdHNldF9hZGRfbWFueShWQUxJRCwgbmZkKFZBTElEKSk7XHJcblx0XHJcblx0Ly8gZGVjb2RlIGVtb2ppXHJcblx0Ly8gMjAyMzA3MTk6IGVtb2ppIGFyZSBub3cgZnVsbHktZXhwYW5kZWQgdG8gYXZvaWQgcXVpcmsgbG9naWMgXHJcblx0RU1PSklfTElTVCA9IHJlYWRfdHJpZShyKS5tYXAodiA9PiBFbW9qaS5mcm9tKHYpKS5zb3J0KGNvbXBhcmVfYXJyYXlzKTtcclxuXHRFTU9KSV9ST09UID0gbmV3IE1hcCgpOyAvLyB0aGlzIGhhcyBhcHByb3ggN0sgbm9kZXMgKDIrIHBlciBlbW9qaSlcclxuXHRmb3IgKGxldCBjcHMgb2YgRU1PSklfTElTVCkge1xyXG5cdFx0Ly8gMjAyMzA3MTk6IGNoYW5nZSB0byAqc2xpZ2h0bHkqIHN0cmljdGVyIGFsZ29yaXRobSB3aGljaCBkaXNhbGxvd3MgXHJcblx0XHQvLyBpbnNlcnRpb24gb2YgbWlzcGxhY2VkIEZFMEYgaW4gZW1vamkgc2VxdWVuY2VzIChtYXRjaGluZyBFTlNJUC0xNSlcclxuXHRcdC8vIGV4YW1wbGU6IGJlYXV0aWZpZWQgW0EgQl0gKGVnLiBmbGFnIGVtb2ppKSBcclxuXHRcdC8vICBiZWZvcmU6IGFsbG93OiBbQSBGRTBGIEJdLCBlcnJvcjogW0EgRkUwRiBGRTBGIEJdIFxyXG5cdFx0Ly8gICBhZnRlcjogZXJyb3I6IGJvdGhcclxuXHRcdC8vIG5vdGU6IHRoaXMgY29kZSBub3cgbWF0Y2hlcyBFTlNOb3JtYWxpemUue2NzLGphdmF9IGxvZ2ljXHJcblx0XHRsZXQgcHJldiA9IFtFTU9KSV9ST09UXTtcclxuXHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRsZXQgbmV4dCA9IHByZXYubWFwKG5vZGUgPT4ge1xyXG5cdFx0XHRcdGxldCBjaGlsZCA9IG5vZGUuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoIWNoaWxkKSB7XHJcblx0XHRcdFx0XHQvLyBzaG91bGQgdGhpcyBiZSBvYmplY3Q/IFxyXG5cdFx0XHRcdFx0Ly8gKG1vc3QgaGF2ZSAxLTIgaXRlbXMsIGZldyBoYXZlIG1hbnkpXHJcblx0XHRcdFx0XHQvLyAyMDIzMDcxOTogbm8sIHY4IGRlZmF1bHQgbWFwIGlzIDQ/XHJcblx0XHRcdFx0XHRjaGlsZCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0XHRcdG5vZGUuc2V0KGNwLCBjaGlsZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGlmIChjcCA9PT0gRkUwRikge1xyXG5cdFx0XHRcdHByZXYucHVzaCguLi5uZXh0KTsgLy8gbGVzcyB0aGFuIDIwIGVsZW1lbnRzXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJldiA9IG5leHQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGZvciAobGV0IHggb2YgcHJldikge1xyXG5cdFx0XHR4LlYgPSBjcHM7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbjogXCIke3N0cl9mcm9tX2NwcyhjcHMuc2xpY2UoMCwgNCkpfVwiYCk7IC8vIHRoaXMgY2FuIG9ubHkgYmUgYXNjaWkgc28gY2FudCBiZSBiaWRpXHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIGNoZWNrX2xlYWRpbmdfdW5kZXJzY29yZShjcHMpIHtcclxuXHRjb25zdCBVTkRFUlNDT1JFID0gMHg1RjtcclxuXHRmb3IgKGxldCBpID0gY3BzLmxhc3RJbmRleE9mKFVOREVSU0NPUkUpOyBpID4gMDsgKSB7XHJcblx0XHRpZiAoY3BzWy0taV0gIT09IFVOREVSU0NPUkUpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCd1bmRlcnNjb3JlIGFsbG93ZWQgb25seSBhdCBzdGFydCcpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG4vLyBjaGVjayB0aGF0IGEgZmVuY2VkIGNwIGlzIG5vdCBsZWFkaW5nLCB0cmFpbGluZywgb3IgdG91Y2hpbmcgYW5vdGhlciBmZW5jZWQgY3BcclxuZnVuY3Rpb24gY2hlY2tfZmVuY2VkKGNwcykge1xyXG5cdGxldCBjcCA9IGNwc1swXTtcclxuXHRsZXQgcHJldiA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdGlmIChwcmV2KSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGxlYWRpbmcgJHtwcmV2fWApO1xyXG5cdGxldCBuID0gY3BzLmxlbmd0aDtcclxuXHRsZXQgbGFzdCA9IC0xOyAvLyBwcmV2ZW50cyB0cmFpbGluZyBmcm9tIHRocm93aW5nXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBuOyBpKyspIHtcclxuXHRcdGNwID0gY3BzW2ldO1xyXG5cdFx0bGV0IG1hdGNoID0gRkVOQ0VELmdldChjcCk7XHJcblx0XHRpZiAobWF0Y2gpIHtcclxuXHRcdFx0Ly8gc2luY2UgY3BzWzBdIGlzbid0IGZlbmNlZCwgY3BzWzFdIGNhbm5vdCB0aHJvd1xyXG5cdFx0XHRpZiAobGFzdCA9PSBpKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYCR7cHJldn0gKyAke21hdGNofWApO1xyXG5cdFx0XHRsYXN0ID0gaSArIDE7XHJcblx0XHRcdHByZXYgPSBtYXRjaDtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKGxhc3QgPT0gbikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGB0cmFpbGluZyAke3ByZXZ9YCk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBpZiBjcHMgZXhjZWVkIG1heCwgbWlkZGxlIHRydW5jYXRlIHdpdGggZWxsaXBzaXNcclxuLy8gcXVvdGVyKGNwKSA9PiBzdHJpbmcsIGVnLiAzMDAwID0+IFwiezMwMDB9XCJcclxuLy8gbm90ZTogaW4gaHRtbCwgeW91J2QgY2FsbCB0aGlzIGZ1bmN0aW9uIHRoZW4gcmVwbGFjZSBbPD4mXSB3aXRoIGVudGl0aWVzXHJcbmZ1bmN0aW9uIHNhZmVfc3RyX2Zyb21fY3BzKGNwcywgbWF4ID0gSW5maW5pdHksIHF1b3RlciA9IHF1b3RlX2NwKSB7XHJcblx0Ly9pZiAoTnVtYmVyLmlzSW50ZWdlcihjcHMpKSBjcHMgPSBbY3BzXTtcclxuXHQvL2lmICghQXJyYXkuaXNBcnJheShjcHMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBjb2RlcG9pbnRzYCk7XHJcblx0bGV0IGJ1ZiA9IFtdO1xyXG5cdGlmIChpc19jb21iaW5pbmdfbWFyayhjcHNbMF0pKSBidWYucHVzaCgn4peMJyk7XHJcblx0aWYgKGNwcy5sZW5ndGggPiBtYXgpIHtcclxuXHRcdG1heCA+Pj0gMTtcclxuXHRcdGNwcyA9IFsuLi5jcHMuc2xpY2UoMCwgbWF4KSwgMHgyMDI2LCAuLi5jcHMuc2xpY2UoLW1heCldO1xyXG5cdH1cclxuXHRsZXQgcHJldiA9IDA7XHJcblx0bGV0IG4gPSBjcHMubGVuZ3RoO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaV07XHJcblx0XHRpZiAoc2hvdWxkX2VzY2FwZShjcCkpIHtcclxuXHRcdFx0YnVmLnB1c2goc3RyX2Zyb21fY3BzKGNwcy5zbGljZShwcmV2LCBpKSkpO1xyXG5cdFx0XHRidWYucHVzaChxdW90ZXIoY3ApKTtcclxuXHRcdFx0cHJldiA9IGkgKyAxO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIG4pKSk7XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuLy8gbm90ZTogc2V0KHMpIGNhbm5vdCBiZSBleHBvc2VkIGJlY2F1c2UgdGhleSBjYW4gYmUgbW9kaWZpZWRcclxuLy8gbm90ZTogT2JqZWN0LmZyZWV6ZSgpIGRvZXNuJ3Qgd29ya1xyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCwgb25seV9uc20pIHsgLy8gMjAyNDAxMjc6IGFkZCBleHRyYSBhcmd1bWVudFxyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gb25seV9uc20gPyBOU00uaGFzKGNwKSA6IENNLmhhcyhjcCk7XHJcbn1cclxuZnVuY3Rpb24gc2hvdWxkX2VzY2FwZShjcCkge1xyXG5cdGluaXQoKTtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbi8vIHJldHVybiBhbGwgc3VwcG9ydGVkIGVtb2ppIGFzIGZ1bGx5LXF1YWxpZmllZCBlbW9qaSBcclxuLy8gb3JkZXJlZCBieSBsZW5ndGggdGhlbiBsZXhpY29ncmFwaGljIFxyXG5mdW5jdGlvbiBlbnNfZW1vamkoKSB7XHJcblx0aW5pdCgpO1xyXG5cdHJldHVybiBFTU9KSV9MSVNULm1hcCh4ID0+IHguc2xpY2UoKSk7IC8vIGVtb2ppIGFyZSBleHBvc2VkIHNvIGNvcHlcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX25vcm1hbGl6ZV9mcmFnbWVudChmcmFnLCBkZWNvbXBvc2UpIHtcclxuXHRpbml0KCk7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHModG9rZW5zX2Zyb21fc3RyKGV4cGxvZGVfY3AobGFiZWwpLCBuZiwgZmlsdGVyX2ZlMGYpLmZsYXQoKSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KG5hbWUsIG5mYywgZmlsdGVyX2ZlMGYpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX2JlYXV0aWZ5KG5hbWUpIHtcclxuXHRsZXQgbGFiZWxzID0gc3BsaXQobmFtZSwgbmZjLCB4ID0+IHgpOyAvLyBlbW9qaSBub3QgZXhwb3NlZFxyXG5cdGZvciAobGV0IHt0eXBlLCBvdXRwdXQsIGVycm9yfSBvZiBsYWJlbHMpIHtcclxuXHRcdGlmIChlcnJvcikgYnJlYWs7IC8vIGZsYXR0ZW4gd2lsbCB0aHJvd1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgYXJyYXlfcmVwbGFjZShvdXRwdXQsIDB4M0JFLCAweDM5RSk7XHJcblxyXG5cdFx0Ly8gMjAyMjEyMTM6IGZpeGVzIGJpZGkgc3ViZG9tYWluIGlzc3VlLCBidXQgYnJlYWtzIGludmFyaWFudCAoMjAwRSBpcyBkaXNhbGxvd2VkKVxyXG5cdFx0Ly8gY291bGQgYmUgZml4ZWQgd2l0aCBzcGVjaWFsIGNhc2UgZm9yOiAyRCAoLikgKyAyMDBFIChMVFIpXHJcblx0XHQvLyBodHRwczovL2Rpc2N1c3MuZW5zLmRvbWFpbnMvdC9iaWRpLWxhYmVsLW9yZGVyaW5nLXNwb29mLzE1ODI0XHJcblx0XHQvL291dHB1dC5zcGxpY2UoMCwgMCwgMHgyMDBFKTtcclxuXHR9XHJcblx0cmV0dXJuIGZsYXR0ZW4obGFiZWxzKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0cmV0dXJuIHNwbGl0KG5hbWUsIG5mYywgcHJlc2VydmVfZW1vamkgPyB4ID0+IHguc2xpY2UoKSA6IGZpbHRlcl9mZTBmKTsgLy8gZW1vamkgYXJlIGV4cG9zZWQgc28gY29weVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChuYW1lLCBuZiwgZWYpIHtcclxuXHRpZiAoIW5hbWUpIHJldHVybiBbXTsgLy8gMjAyMzA3MTk6IGVtcHR5IG5hbWUgYWxsb3dhbmNlXHJcblx0aW5pdCgpO1xyXG5cdGxldCBvZmZzZXQgPSAwO1xyXG5cdC8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjQ2LyNWYWxpZGl0eV9Dcml0ZXJpYVxyXG5cdC8vIDQuKSBcIlRoZSBsYWJlbCBtdXN0IG5vdCBjb250YWluIGEgVSswMDJFICggLiApIEZVTEwgU1RPUC5cIlxyXG5cdHJldHVybiBuYW1lLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiB7XHJcblx0XHRsZXQgaW5wdXQgPSBleHBsb2RlX2NwKGxhYmVsKTtcclxuXHRcdGxldCBpbmZvID0ge1xyXG5cdFx0XHRpbnB1dCxcclxuXHRcdFx0b2Zmc2V0LCAvLyBjb2RlcG9pbnQsIG5vdCBzdWJzdHJpbmchXHJcblx0XHR9O1xyXG5cdFx0b2Zmc2V0ICs9IGlucHV0Lmxlbmd0aCArIDE7IC8vICsgc3RvcFxyXG5cdFx0dHJ5IHtcclxuXHRcdFx0Ly8gMS4pIFwiVGhlIGxhYmVsIG11c3QgYmUgaW4gVW5pY29kZSBOb3JtYWxpemF0aW9uIEZvcm0gTkZDXCJcclxuXHRcdFx0bGV0IHRva2VucyA9IGluZm8udG9rZW5zID0gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpO1xyXG5cdFx0XHRsZXQgdG9rZW5fY291bnQgPSB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0XHRsZXQgdHlwZTtcclxuXHRcdFx0aWYgKCF0b2tlbl9jb3VudCkgeyAvLyB0aGUgbGFiZWwgd2FzIGVmZmVjdGl2ZWx5IGVtcHR5IChjb3VsZCBvZiBoYWQgaWdub3JlZCBjaGFyYWN0ZXJzKVxyXG5cdFx0XHRcdC8vbm9ybSA9IFtdO1xyXG5cdFx0XHRcdC8vdHlwZSA9ICdOb25lJzsgLy8gdXNlIHRoaXMgaW5zdGVhZCBvZiBuZXh0IG1hdGNoLCBcIkFTQ0lJXCJcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBlbXB0eSBsYWJlbGApO1xyXG5cdFx0XHR9IFxyXG5cdFx0XHRsZXQgbm9ybSA9IGluZm8ub3V0cHV0ID0gdG9rZW5zLmZsYXQoKTtcclxuXHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRsZXQgZW1vamkgPSBpbmZvLmVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IHRva2Vuc1swXS5pc19lbW9qaTsgLy8gc2FtZSBhczogdG9rZW5zLnNvbWUoeCA9PiB4LmlzX2Vtb2ppKTtcclxuXHRcdFx0aWYgKCFlbW9qaSAmJiBub3JtLmV2ZXJ5KGNwID0+IGNwIDwgMHg4MCkpIHsgLy8gc3BlY2lhbCBjYXNlIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRjaGVja19sYWJlbF9leHRlbnNpb24obm9ybSk7IC8vIG9ubHkgbmVlZGVkIGZvciBhc2NpaVxyXG5cdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgY21cclxuXHRcdFx0XHQvLyBjYW50IGhhdmUgd2hvbGVzXHJcblx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0dHlwZSA9ICdBU0NJSSc7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdGlmICghY2hhcnMubGVuZ3RoKSB7IC8vIHRoZXJlcyBubyB0ZXh0LCBqdXN0IGVtb2ppXHJcblx0XHRcdFx0XHR0eXBlID0gJ0Vtb2ppJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gNS4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGJlZ2luIHdpdGggYSBjb21iaW5pbmcgbWFyaywgdGhhdCBpczogR2VuZXJhbF9DYXRlZ29yeT1NYXJrLlwiXHJcblx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgdG9rZW5fY291bnQ7IGkrKykgeyAvLyB3ZSd2ZSBhbHJlYWR5IGNoZWNrZWQgdGhlIGZpcnN0IHRva2VuXHJcblx0XHRcdFx0XHRcdGxldCBjcHMgPSB0b2tlbnNbaV07XHJcblx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0Ly8gYmlkaV9xcSgpIG5vdCBuZWVkZWQgc2luY2UgZW1vamkgaXMgTFRSIGFuZCBjcHMgaXMgYSBDTVxyXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yX3BsYWNlbWVudChgZW1vamkgKyBjb21iaW5pbmcgbWFyazogXCIke3N0cl9mcm9tX2Nwcyh0b2tlbnNbaS0xXSl9ICsgJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3BzWzBdXSl9XCJgKTsgXHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGNoZWNrX2ZlbmNlZChub3JtKTtcclxuXHRcdFx0XHRcdGxldCB1bmlxdWUgPSBBcnJheV9mcm9tKG5ldyBTZXQoY2hhcnMpKTtcclxuXHRcdFx0XHRcdGxldCBbZ10gPSBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKTsgLy8gdGFrZSB0aGUgZmlyc3QgbWF0Y2hcclxuXHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHQvLyBhbHRlcm5hdGl2ZTogY291bGQgZm9ybSBhIGh5YnJpZCB0eXBlOiBMYXRpbi9KYXBhbmVzZS8uLi5cdFxyXG5cdFx0XHRcdFx0Y2hlY2tfZ3JvdXAoZywgY2hhcnMpOyAvLyBuZWVkIHRleHQgaW4gb3JkZXJcclxuXHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHR0eXBlID0gZy5OO1xyXG5cdFx0XHRcdFx0Ly8gMjAyMzAxMjE6IGNvbnNpZGVyIGV4cG9zaW5nIHJlc3RyaWN0ZWQgZmxhZ1xyXG5cdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0Ly8gb3IgZXZlbiBiZXR0ZXI6IHR5cGUuZW5kc1dpdGgoJ10nKVxyXG5cdFx0XHRcdFx0Ly9pZiAoZy5SKSBpbmZvLnJlc3RyaWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpbmZvLnR5cGUgPSB0eXBlO1xyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdGluZm8uZXJyb3IgPSBlcnI7IC8vIHVzZSBmdWxsIGVycm9yIG9iamVjdFxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGluZm87XHJcblx0fSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX3dob2xlKGdyb3VwLCB1bmlxdWUpIHtcclxuXHRsZXQgbWFrZXI7XHJcblx0bGV0IHNoYXJlZCA9IFtdO1xyXG5cdGZvciAobGV0IGNwIG9mIHVuaXF1ZSkge1xyXG5cdFx0bGV0IHdob2xlID0gV0hPTEVfTUFQLmdldChjcCk7XHJcblx0XHRpZiAod2hvbGUgPT09IFVOSVFVRV9QSCkgcmV0dXJuOyAvLyB1bmlxdWUsIG5vbi1jb25mdXNhYmxlXHJcblx0XHRpZiAod2hvbGUpIHtcclxuXHRcdFx0bGV0IHNldCA9IHdob2xlLk0uZ2V0KGNwKTsgLy8gZ3JvdXBzIHdoaWNoIGhhdmUgYSBjaGFyYWN0ZXIgdGhhdCBsb29rLWxpa2UgdGhpcyBjaGFyYWN0ZXJcclxuXHRcdFx0bWFrZXIgPSBtYWtlciA/IG1ha2VyLmZpbHRlcihnID0+IHNldC5oYXMoZykpIDogQXJyYXlfZnJvbShzZXQpO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYWluaW5nIGdyb3Vwc1xyXG5cdFx0Ly8gY29udGFpbiB0aGUgc2hhcmVkIGNoYXJhY3RlcnMgdG9vXHJcblx0XHRmb3IgKGxldCBnIG9mIG1ha2VyKSB7XHJcblx0XHRcdGlmIChzaGFyZWQuZXZlcnkoY3AgPT4gZ3JvdXBfaGFzX2NwKGcsIGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpO1xyXG5cdFx0aWYgKCFncy5sZW5ndGgpIHtcclxuXHRcdFx0aWYgKCFHUk9VUFMuc29tZShnID0+IGdyb3VwX2hhc19jcChnLCBjcCkpKSB7IFxyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdC8vIDIwMjMwNzE2OiBjaGFuZ2UgdG8gbW9yZSBleGFjdCBzdGF0ZW1lbnQsIHNlZTogRU5TTm9ybWFsaXplLntjcyxqYXZhfVxyXG5cdFx0XHRcdC8vIG5vdGU6IHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGEgY29tcG9zaXRpb25cclxuXHRcdFx0XHQvLyAyMDIzMDcyMDogY2hhbmdlIHRvIGZ1bGwgY2hlY2tcclxuXHRcdFx0XHR0aHJvdyBlcnJvcl9kaXNhbGxvd2VkKGNwKTsgLy8gdGhpcyBzaG91bGQgYmUgcmFyZVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIHRoZXJlIGlzIG5vIGdyb3VwIHRoYXQgY29udGFpbnMgYWxsIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRcdFx0XHQvLyB0aHJvdyB1c2luZyB0aGUgaGlnaGVzdCBwcmlvcml0eSBncm91cCB0aGF0IG1hdGNoZWRcclxuXHRcdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI21peGVkX3NjcmlwdF9jb25mdXNhYmxlc1xyXG5cdFx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihncm91cHNbMF0sIGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Z3JvdXBzID0gZ3M7XHJcblx0XHRpZiAoZ3MubGVuZ3RoID09IDEpIGJyZWFrOyAvLyB0aGVyZSBpcyBvbmx5IG9uZSBncm91cCBsZWZ0XHJcblx0fVxyXG5cdC8vIHRoZXJlIGFyZSBhdCBsZWFzdCAxIGdyb3VwKHMpIHdpdGggYWxsIG9mIHRoZXNlIGNoYXJhY3RlcnNcclxuXHRyZXR1cm4gZ3JvdXBzO1xyXG59XHJcblxyXG4vLyB0aHJvdyBvbiBmaXJzdCBlcnJvclxyXG5mdW5jdGlvbiBmbGF0dGVuKHNwbGl0KSB7XHJcblx0cmV0dXJuIHNwbGl0Lm1hcCgoe2lucHV0LCBlcnJvciwgb3V0cHV0fSkgPT4ge1xyXG5cdFx0aWYgKGVycm9yKSB7XHJcblx0XHRcdC8vIGRvbid0IHByaW50IGxhYmVsIGFnYWluIGlmIGp1c3QgYSBzaW5nbGUgbGFiZWxcclxuXHRcdFx0bGV0IG1zZyA9IGVycm9yLm1lc3NhZ2U7XHJcblx0XHRcdC8vIGJpZGlfcXEoKSBvbmx5IG5lY2Vzc2FyeSBpZiBtc2cgaXMgZGlnaXRzXHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihzcGxpdC5sZW5ndGggPT0gMSA/IG1zZyA6IGBJbnZhbGlkIGxhYmVsICR7YmlkaV9xcShzYWZlX3N0cl9mcm9tX2NwcyhpbnB1dCwgNjMpKX06ICR7bXNnfWApOyBcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHJfZnJvbV9jcHMob3V0cHV0KTtcclxuXHR9KS5qb2luKFNUT1BfQ0gpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBlcnJvcl9kaXNhbGxvd2VkKGNwKSB7XHJcblx0Ly8gVE9ETzogYWRkIGNwIHRvIGVycm9yP1xyXG5cdHJldHVybiBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZF9jcChjcCl9YCk7IFxyXG59XHJcbmZ1bmN0aW9uIGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCkge1xyXG5cdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdGxldCBnZyA9IEdST1VQUy5maW5kKGcgPT4gZy5QLmhhcyhjcCkpOyAvLyBvbmx5IGNoZWNrIHByaW1hcnlcclxuXHRpZiAoZ2cpIHtcclxuXHRcdHF1b3RlZCA9IGAke2dnLk59ICR7cXVvdGVkfWA7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgbWl4dHVyZTogJHtnLk59ICsgJHtxdW90ZWR9YCk7XHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfcGxhY2VtZW50KHdoZXJlKSB7XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBwbGFjZW1lbnQ6ICR7d2hlcmV9YCk7XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IGNwcy5sZW5ndGggPiAwXHJcbi8vIGFzc3VtcHRpb246IGNwc1swXSBpc24ndCBhIENNXHJcbi8vIGFzc3VtcHRpb246IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXNuJ3QgYW4gZW1vamlcclxuZnVuY3Rpb24gY2hlY2tfZ3JvdXAoZywgY3BzKSB7XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRpZiAoIWdyb3VwX2hhc19jcChnLCBjcCkpIHtcclxuXHRcdFx0Ly8gZm9yIHdoaXRlbGlzdGVkIHNjcmlwdHMsIHRoaXMgd2lsbCB0aHJvdyBpbGxlZ2FsIG1peHR1cmUgb24gaW52YWxpZCBjbSwgZWcuIFwiZXszMDB9ezMwMH1cIlxyXG5cdFx0XHQvLyBhdCB0aGUgbW9tZW50LCBpdCdzIHVubmVjZXNzYXJ5IHRvIGludHJvZHVjZSBhbiBleHRyYSBlcnJvciB0eXBlXHJcblx0XHRcdC8vIHVudGlsIHRoZXJlIGV4aXN0cyBhIHdoaXRlbGlzdGVkIG11bHRpLWNoYXJhY3RlclxyXG5cdFx0XHQvLyAgIGVnLiBpZiAoTSA8IDAgJiYgaXNfY29tYmluaW5nX21hcmsoY3ApKSB7IC4uLiB9XHJcblx0XHRcdC8vIHRoZXJlIGFyZSAzIGNhc2VzOlxyXG5cdFx0XHQvLyAgIDEuIGlsbGVnYWwgY20gZm9yIHdyb25nIGdyb3VwID0+IG1peHR1cmUgZXJyb3JcclxuXHRcdFx0Ly8gICAyLiBpbGxlZ2FsIGNtIGZvciBzYW1lIGdyb3VwID0+IGNtIGVycm9yXHJcblx0XHRcdC8vICAgICAgIHJlcXVpcmVzIHNldCBvZiB3aGl0ZWxpc3QgY20gcGVyIGdyb3VwOiBcclxuXHRcdFx0Ly8gICAgICAgIGVnLiBuZXcgU2V0KFsuLi5nLlAsIC4uLmcuUV0uZmxhdE1hcChuZmMpLmZpbHRlcihjcCA9PiBDTS5oYXMoY3ApKSlcclxuXHRcdFx0Ly8gICAzLiB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vaWYgKE0gPj0gMCkgeyAvLyB3ZSBoYXZlIGEga25vd24gZml4ZWQgY20gY291bnRcclxuXHRpZiAoZy5NKSB7IC8vIHdlIG5lZWQgdG8gY2hlY2sgZm9yIE5TTVxyXG5cdFx0bGV0IGRlY29tcG9zZWQgPSBuZmQoY3BzKTtcclxuXHRcdGZvciAobGV0IGkgPSAxLCBlID0gZGVjb21wb3NlZC5sZW5ndGg7IGkgPCBlOyBpKyspIHsgLy8gc2VlOiBhc3N1bXB0aW9uXHJcblx0XHRcdC8vIDIwMjMwMjEwOiBidWdmaXg6IHVzaW5nIGNwcyBpbnN0ZWFkIG9mIGRlY29tcG9zZWQgaC90IENhcmJvbjIyNVxyXG5cdFx0XHQvKlxyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6ICR7Zy5OfSAke2JpZGlfcXEoc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHRcdCovXHJcblx0XHRcdC8vIDIwMjMwMjE3OiBzd2l0Y2ggdG8gTlNNIGNvdW50aW5nXHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jT3B0aW9uYWxfRGV0ZWN0aW9uXHJcblx0XHRcdGlmIChOU00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHRmb3IgKGxldCBjcDsgaiA8IGUgJiYgTlNNLmhhcyhjcCA9IGRlY29tcG9zZWRbal0pOyBqKyspIHtcclxuXHRcdFx0XHRcdC8vIGEuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgdGhlIHNhbWUgbm9uc3BhY2luZyBtYXJrLlxyXG5cdFx0XHRcdFx0Zm9yIChsZXQgayA9IGk7IGsgPCBqOyBrKyspIHsgLy8gTyhuXjIpIGJ1dCBuIDwgMTAwXHJcblx0XHRcdFx0XHRcdGlmIChkZWNvbXBvc2VkW2tdID09IGNwKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkdXBsaWNhdGUgbm9uLXNwYWNpbmcgbWFya3M6ICR7cXVvdGVkX2NwKGNwKX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBwYXJzZSB0byBlbmQgc28gd2UgaGF2ZSBmdWxsIG5zbSBjb3VudFxyXG5cdFx0XHRcdC8vIGIuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgbW9yZSB0aGFuIDQgbm9uc3BhY2luZyBtYXJrcyAoZ2M9TW4gb3IgZ2M9TWUpLlxyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE5TTV9NQVgpIHtcclxuXHRcdFx0XHRcdC8vIG5vdGU6IHRoaXMgc2xpY2Ugc3RhcnRzIHdpdGggYSBiYXNlIGNoYXIgb3Igc3BhY2luZy1tYXJrIGNtXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYGV4Y2Vzc2l2ZSBub24tc3BhY2luZyBtYXJrczogJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSkpfSAoJHtqLWl9LyR7TlNNX01BWH0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHQvKlxyXG5cdGxldCBjbV93aGl0ZWxpc3QgPSBNIGluc3RhbmNlb2YgTWFwO1xyXG5cdGZvciAobGV0IGkgPSAwLCBlID0gY3BzLmxlbmd0aDsgaSA8IGU7ICkge1xyXG5cdFx0bGV0IGNwID0gY3BzW2krK107XHJcblx0XHRsZXQgc2VxcyA9IGNtX3doaXRlbGlzdCAmJiBNLmdldChjcCk7XHJcblx0XHRpZiAoc2VxcykgeyBcclxuXHRcdFx0Ly8gbGlzdCBvZiBjb2RlcG9pbnRzIHRoYXQgY2FuIGZvbGxvd1xyXG5cdFx0XHQvLyBpZiB0aGlzIGV4aXN0cywgdGhpcyB3aWxsIGFsd2F5cyBiZSAxK1xyXG5cdFx0XHRsZXQgaiA9IGk7XHJcblx0XHRcdHdoaWxlIChqIDwgZSAmJiBDTS5oYXMoY3BzW2pdKSkgaisrO1xyXG5cdFx0XHRsZXQgY21zID0gY3BzLnNsaWNlKGksIGopO1xyXG5cdFx0XHRsZXQgbWF0Y2ggPSBzZXFzLmZpbmQoc2VxID0+ICFjb21wYXJlX2FycmF5cyhzZXEsIGNtcykpO1xyXG5cdFx0XHRpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY29tYmluaW5nIG1hcmsgc2VxdWVuY2U6IFwiJHtzYWZlX3N0cl9mcm9tX2NwcyhbY3AsIC4uLmNtc10pfVwiYCk7XHJcblx0XHRcdGkgPSBqO1xyXG5cdFx0fSBlbHNlIGlmICghVi5oYXMoY3ApKSB7XHJcblx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdGxldCBxdW90ZWQgPSBxdW90ZWRfY3AoY3ApO1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdFx0XHRsZXQgdSA9IFVOSVFVRS5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmICh1ICYmIHUgIT09IGcpIHtcclxuXHRcdFx0XHRcdC8vIGlmIGJvdGggc2NyaXB0cyBhcmUgcmVzdHJpY3RlZCB0aGlzIGVycm9yIGlzIGNvbmZ1c2luZ1xyXG5cdFx0XHRcdFx0Ly8gYmVjYXVzZSB3ZSBkb24ndCBkaWZmZXJlbnRpYXRlIFJlc3RyaWN0ZWRBIGZyb20gUmVzdHJpY3RlZEIgXHJcblx0XHRcdFx0XHRpZiAoIXUuUikgcXVvdGVkID0gYCR7cXVvdGVkfSBpcyAke3UuTn1gO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCAke2cuTn0gY2hhcmFjdGVyOiAke3F1b3RlZH1gKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYGRpc2FsbG93ZWQgY2hhcmFjdGVyOiAke3F1b3RlZH0gKGV4cGVjdGVkICR7Zy5OfSlgKTtcclxuXHRcdFx0Ly90aHJvdyBuZXcgRXJyb3IoYCR7Zy5OfSBkb2VzIG5vdCBhbGxvdzogJHtxdW90ZWR9YCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmICghY21fd2hpdGVsaXN0KSB7XHJcblx0XHRsZXQgZGVjb21wb3NlZCA9IG5mZChjcHMpO1xyXG5cdFx0Zm9yIChsZXQgaSA9IDEsIGUgPSBkZWNvbXBvc2VkLmxlbmd0aDsgaSA8IGU7IGkrKykgeyAvLyB3ZSBrbm93IGl0IGNhbid0IGJlIGNtIGxlYWRpbmdcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiBcIiR7c3RyX2Zyb21fY3BzKGRlY29tcG9zZWQuc2xpY2UoaS0xLCBqKSl9XCIgKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHQqL1xyXG59XHJcblxyXG4vLyBnaXZlbiBhIGxpc3Qgb2YgY29kZXBvaW50c1xyXG4vLyByZXR1cm5zIGEgbGlzdCBvZiBsaXN0cywgd2hlcmUgZW1vamkgYXJlIGEgZnVsbHktcXVhbGlmaWVkIChhcyBBcnJheSBzdWJjbGFzcylcclxuLy8gZWcuIGV4cGxvZGVfY3AoXCJhYmPwn5KpZFwiKSA9PiBbWzYxLCA2MiwgNjNdLCBFbW9qaVsxRjRBOSwgRkUwRl0sIFs2NF1dXHJcbi8vIDIwMjMwODE4OiByZW5hbWUgZm9yICdwcm9jZXNzJyBuYW1lIGNvbGxpc2lvbiBoL3QgSmF2YXJvbWVcclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2FkcmFmZnkvZW5zLW5vcm1hbGl6ZS5qcy9pc3N1ZXMvMjNcclxuZnVuY3Rpb24gdG9rZW5zX2Zyb21fc3RyKGlucHV0LCBuZiwgZWYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGNoYXJzID0gW107XHJcblx0aW5wdXQgPSBpbnB1dC5zbGljZSgpLnJldmVyc2UoKTsgLy8gZmxpcCBzbyB3ZSBjYW4gcG9wXHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0XHRcdFx0Y2hhcnMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXQucHVzaChlZihlbW9qaSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChWQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0Y2hhcnMucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdGNoYXJzLnB1c2goLi4uY3BzKTsgLy8gbGVzcyB0aGFuIDEwIGVsZW1lbnRzXHJcblx0XHRcdFx0fSBlbHNlIGlmICghSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0XHQvLyAyMDIzMDkxMjogdW5pY29kZSAxNS4xIGNoYW5nZWQgdGhlIG9yZGVyIG9mIHByb2Nlc3Npbmcgc3VjaCB0aGF0XHJcblx0XHRcdFx0XHQvLyBkaXNhbGxvd2VkIHBhcnRzIGFyZSBvbmx5IHJlamVjdGVkIGFmdGVyIE5GQ1xyXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0XHRcdFx0XHQvLyB0aGlzIGRvZXNuJ3QgaW1wYWN0IG5vcm1hbGl6YXRpb24gYXMgb2YgdG9kYXlcclxuXHRcdFx0XHRcdC8vIHRlY2huaWNhbGx5LCB0aGlzIGVycm9yIGNhbiBiZSByZW1vdmVkIGFzIHRoZSBncm91cCBsb2dpYyB3aWxsIGFwcGx5IHNpbWlsYXIgbG9naWNcclxuXHRcdFx0XHRcdC8vIGhvd2V2ZXIgdGhlIGVycm9yIHR5cGUgbWlnaHQgYmUgbGVzcyBjbGVhclxyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcl9mZTBmKGNwcykge1xyXG5cdHJldHVybiBjcHMuZmlsdGVyKGNwID0+IGNwICE9IEZFMEYpO1xyXG59XHJcblxyXG4vLyBnaXZlbiBhcnJheSBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgdGhlIGxvbmdlc3QgdmFsaWQgZW1vamkgc2VxdWVuY2UgKG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaClcclxuLy8gKk1VVEFURVMqIHRoZSBzdXBwbGllZCBhcnJheVxyXG4vLyBkaXNhbGxvd3MgaW50ZXJsZWF2ZWQgaWdub3JlZCBjaGFyYWN0ZXJzXHJcbi8vIGZpbGxzIChvcHRpb25hbCkgZWF0ZW4gYXJyYXkgd2l0aCBtYXRjaGVkIGNvZGVwb2ludHNcclxuZnVuY3Rpb24gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChjcHMsIGVhdGVuKSB7XHJcblx0bGV0IG5vZGUgPSBFTU9KSV9ST09UO1xyXG5cdGxldCBlbW9qaTtcclxuXHRsZXQgcG9zID0gY3BzLmxlbmd0aDtcclxuXHR3aGlsZSAocG9zKSB7XHJcblx0XHRub2RlID0gbm9kZS5nZXQoY3BzWy0tcG9zXSk7XHJcblx0XHRpZiAoIW5vZGUpIGJyZWFrO1xyXG5cdFx0bGV0IHtWfSA9IG5vZGU7XHJcblx0XHRpZiAoVikgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcclxuXHRcdFx0ZW1vamkgPSBWO1xyXG5cdFx0XHRpZiAoZWF0ZW4pIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gKG9wdGlvbmFsKSBjb3B5IGlucHV0LCB1c2VkIGZvciBlbnNfdG9rZW5pemUoKVxyXG5cdFx0XHRjcHMubGVuZ3RoID0gcG9zOyAvLyB0cnVuY2F0ZVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gZW1vamk7XHJcbn1cclxuXHJcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4vLyB0b2tlbml6ZXIgXHJcblxyXG5jb25zdCBUWV9WQUxJRCA9ICd2YWxpZCc7XHJcbmNvbnN0IFRZX01BUFBFRCA9ICdtYXBwZWQnO1xyXG5jb25zdCBUWV9JR05PUkVEID0gJ2lnbm9yZWQnO1xyXG5jb25zdCBUWV9ESVNBTExPV0VEID0gJ2Rpc2FsbG93ZWQnO1xyXG5jb25zdCBUWV9FTU9KSSA9ICdlbW9qaSc7XHJcbmNvbnN0IFRZX05GQyA9ICduZmMnO1xyXG5jb25zdCBUWV9TVE9QID0gJ3N0b3AnO1xyXG5cclxuZnVuY3Rpb24gZW5zX3Rva2VuaXplKG5hbWUsIHtcclxuXHRuZiA9IHRydWUsIC8vIGNvbGxhcHNlIHVubm9ybWFsaXplZCBydW5zIGludG8gYSBzaW5nbGUgdG9rZW5cclxufSA9IHt9KSB7XHJcblx0aW5pdCgpO1xyXG5cdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobmFtZSkucmV2ZXJzZSgpO1xyXG5cdGxldCBlYXRlbiA9IFtdO1xyXG5cdGxldCB0b2tlbnMgPSBbXTtcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHJcblx0XHRsZXQgZW1vamkgPSBjb25zdW1lX2Vtb2ppX3JldmVyc2VkKGlucHV0LCBlYXRlbik7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0dG9rZW5zLnB1c2goe1xyXG5cdFx0XHRcdHR5cGU6IFRZX0VNT0pJLFxyXG5cdFx0XHRcdGVtb2ppOiBlbW9qaS5zbGljZSgpLCAvLyBjb3B5IGVtb2ppXHJcblx0XHRcdFx0aW5wdXQ6IGVhdGVuLFxyXG5cdFx0XHRcdGNwczogZmlsdGVyX2ZlMGYoZW1vamkpXHJcblx0XHRcdH0pO1xyXG5cdFx0XHRlYXRlbiA9IFtdOyAvLyByZXNldCBidWZmZXJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGxldCBjcCA9IGlucHV0LnBvcCgpO1xyXG5cdFx0XHRpZiAoY3AgPT0gU1RPUCkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9TVE9QLCBjcH0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfVkFMSUQsIGNwczogW2NwXX0pO1xyXG5cdFx0XHR9IGVsc2UgaWYgKElHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9JR05PUkVELCBjcH0pO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGxldCBjcHMgPSBNQVBQRUQuZ2V0KGNwKTtcclxuXHRcdFx0XHRpZiAoY3BzKSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfTUFQUEVELCBjcCwgY3BzOiBjcHMuc2xpY2UoKX0pO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR0b2tlbnMucHVzaCh7dHlwZTogVFlfRElTQUxMT1dFRCwgY3B9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG5mKSB7XHJcblx0XHRmb3IgKGxldCBpID0gMCwgc3RhcnQgPSAtMTsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgdG9rZW4gPSB0b2tlbnNbaV07XHJcblx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodG9rZW4udHlwZSkpIHtcclxuXHRcdFx0XHRpZiAocmVxdWlyZXNfY2hlY2sodG9rZW4uY3BzKSkgeyAvLyBub3JtYWxpemF0aW9uIG1pZ2h0IGJlIG5lZWRlZFxyXG5cdFx0XHRcdFx0bGV0IGVuZCA9IGkgKyAxO1xyXG5cdFx0XHRcdFx0Zm9yIChsZXQgcG9zID0gZW5kOyBwb3MgPCB0b2tlbnMubGVuZ3RoOyBwb3MrKykgeyAvLyBmaW5kIGFkamFjZW50IHRleHRcclxuXHRcdFx0XHRcdFx0bGV0IHt0eXBlLCBjcHN9ID0gdG9rZW5zW3Bvc107XHJcblx0XHRcdFx0XHRcdGlmIChpc192YWxpZF9vcl9tYXBwZWQodHlwZSkpIHtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIXJlcXVpcmVzX2NoZWNrKGNwcykpIGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGVuZCA9IHBvcyArIDE7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAodHlwZSAhPT0gVFlfSUdOT1JFRCkgeyAvLyB8fCB0eXBlICE9PSBUWV9ESVNBTExPV0VEKSB7IFxyXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoc3RhcnQgPCAwKSBzdGFydCA9IGk7XHJcblx0XHRcdFx0XHRsZXQgc2xpY2UgPSB0b2tlbnMuc2xpY2Uoc3RhcnQsIGVuZCk7XHJcblx0XHRcdFx0XHRsZXQgY3BzMCA9IHNsaWNlLmZsYXRNYXAoeCA9PiBpc192YWxpZF9vcl9tYXBwZWQoeC50eXBlKSA/IHguY3BzIDogW10pOyAvLyBzdHJpcCBqdW5rIHRva2Vuc1xyXG5cdFx0XHRcdFx0bGV0IGNwcyA9IG5mYyhjcHMwKTtcclxuXHRcdFx0XHRcdGlmIChjb21wYXJlX2FycmF5cyhjcHMsIGNwczApKSB7IC8vIGJ1bmRsZSBpbnRvIGFuIG5mYyB0b2tlblxyXG5cdFx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCwge1xyXG5cdFx0XHRcdFx0XHRcdHR5cGU6IFRZX05GQywgXHJcblx0XHRcdFx0XHRcdFx0aW5wdXQ6IGNwczAsIC8vIHRoZXJlIGFyZSAzIHN0YXRlczogdG9rZW5zMCA9PShwcm9jZXNzKT0+IGlucHV0ID09KG5mYyk9PiB0b2tlbnMvY3BzXHJcblx0XHRcdFx0XHRcdFx0Y3BzLCBcclxuXHRcdFx0XHRcdFx0XHR0b2tlbnMwOiBjb2xsYXBzZV92YWxpZF90b2tlbnMoc2xpY2UpLFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczogZW5zX3Rva2VuaXplKHN0cl9mcm9tX2NwcyhjcHMpLCB7bmY6IGZhbHNlfSlcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdGkgPSBzdGFydDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7IFxyXG5cdFx0XHRcdFx0XHRpID0gZW5kIC0gMTsgLy8gc2tpcCB0byBlbmQgb2Ygc2xpY2VcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHN0YXJ0ID0gLTE7IC8vIHJlc2V0XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gaTsgLy8gcmVtZW1iZXIgbGFzdFxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmICh0b2tlbi50eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIDIwMjIxMDI0OiBpcyB0aGlzIGNvcnJlY3Q/XHJcblx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSB7XHJcblx0cmV0dXJuIHR5cGUgPT0gVFlfVkFMSUQgfHwgdHlwZSA9PSBUWV9NQVBQRUQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcXVpcmVzX2NoZWNrKGNwcykge1xyXG5cdHJldHVybiBjcHMuc29tZShjcCA9PiBORkNfQ0hFQ0suaGFzKGNwKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbGxhcHNlX3ZhbGlkX3Rva2Vucyh0b2tlbnMpIHtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG5cdFx0aWYgKHRva2Vuc1tpXS50eXBlID09IFRZX1ZBTElEKSB7XHJcblx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdHdoaWxlIChqIDwgdG9rZW5zLmxlbmd0aCAmJiB0b2tlbnNbal0udHlwZSA9PSBUWV9WQUxJRCkgaisrO1xyXG5cdFx0XHR0b2tlbnMuc3BsaWNlKGksIGogLSBpLCB7dHlwZTogVFlfVkFMSUQsIGNwczogdG9rZW5zLnNsaWNlKGksIGopLmZsYXRNYXAoeCA9PiB4LmNwcyl9KTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHRva2VucztcclxufVxuXG5leHBvcnQgeyBlbnNfYmVhdXRpZnksIGVuc19lbW9qaSwgZW5zX25vcm1hbGl6ZSwgZW5zX25vcm1hbGl6ZV9mcmFnbWVudCwgZW5zX3NwbGl0LCBlbnNfdG9rZW5pemUsIGlzX2NvbWJpbmluZ19tYXJrLCBuZmMsIG5mZCwgc2FmZV9zdHJfZnJvbV9jcHMsIHNob3VsZF9lc2NhcGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@adraffy/ens-normalize/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/curves/abstract/utils.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/curves/abstract/utils.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * @module\n */\n__exportStar(__webpack_require__(/*! ../utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/curves/utils.js\"), exports);\n// TODO\n// @deprecated use `@noble/curves/utils.js`\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2Fic3RyYWN0L3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxvRkFBYTtBQUNsQztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGFic3RyYWN0XFx1dGlscy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAbW9kdWxlXG4gKi9cbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHMuanNcIiksIGV4cG9ydHMpO1xuLy8gVE9ET1xuLy8gQGRlcHJlY2F0ZWQgdXNlIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/curves/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/curves/esm/utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/curves/esm/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _validateObject: () => (/* binding */ _validateObject),\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes),\n/* harmony export */   anumber: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if ((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDb0s7QUFDckI7QUFDL0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ087QUFDUCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDTztBQUNQLElBQUksOERBQU87QUFDWCx1QkFBdUIsa0VBQVc7QUFDbEM7QUFDTztBQUNQLFdBQVcsa0VBQVc7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxrRUFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtFQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hELDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1FQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsK0RBQVE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUNuRCw4REFBOEQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXLFdBQVcsWUFBWSxJQUFJO0FBQ3BELGtDQUFrQyxvQkFBb0IsSUFBSSxhQUFhLEdBQUc7QUFDMUU7QUFDQSxrQ0FBa0MsVUFBVSxJQUFJLFNBQVM7QUFDekQsa0NBQWtDLG9CQUFvQixJQUFJLFNBQVM7QUFDbkUsa0NBQWtDLDJCQUEyQjtBQUM3RCxrQ0FBa0Msd0JBQXdCO0FBQ25EO0FBQ1A7QUFDQTtBQUNPLHVEQUF1RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFVBQVUseUJBQXlCLGFBQWEsUUFBUSxRQUFRO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGVzbVxcdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMgYXMgYWJ5dGVzXywgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4XywgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXNfLCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNfLCBpc0J5dGVzIGFzIGlzQnl0ZXNfLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuZXhwb3J0IHsgYWJ5dGVzLCBhbnVtYmVyLCBieXRlc1RvSGV4LCBieXRlc1RvVXRmOCwgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMsIGlzQnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcywgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBib29sZWFuIGV4cGVjdGVkLCBnb3QgJyArIHZhbHVlKTtcbn1cbi8vIFVzZWQgaW4gd2VpZXJzdHJhc3MsIGRlclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlc18oYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlc18obi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzXyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlc18oaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY2F1c2U6ICcgKyBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc0J5dGVzXyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXknKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG9mIGxlbmd0aCAnICsgZXhwZWN0ZWRMZW5ndGggKyAnIGV4cGVjdGVkLCBnb3QgJyArIGxlbik7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZGlmZiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBkaWZmIHw9IGFbaV0gXiBiW2ldO1xuICAgIHJldHVybiBkaWZmID09PSAwO1xufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG4vLyBleHBvcnQgY29uc3QgdXRmOFRvQnl0ZXM6IHR5cGVvZiB1dGY4VG9CeXRlc18gPSB1dGY4VG9CeXRlc187XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbi8vIGV4cG9ydCBjb25zdCBieXRlc1RvVXRmODogdHlwZW9mIGJ5dGVzVG9VdGY4XyA9IGJ5dGVzVG9VdGY4Xztcbi8vIElzIHBvc2l0aXZlIGJpZ2ludFxuY29uc3QgaXNQb3NCaWcgPSAobikgPT4gdHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuO1xuZXhwb3J0IGZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFJblJhbmdlKHRpdGxlLCBuLCBtaW4sIG1heCkge1xuICAgIC8vIFdoeSBtaW4gPD0gbiA8IG1heCBhbmQgbm90IGEgKG1pbiA8IG4gPCBtYXgpIE9SIGIgKG1pbiA8PSBuIDw9IG1heCk/XG4gICAgLy8gY29uc2lkZXIgUD0yNTZuLCBtaW49MG4sIG1heD1QXG4gICAgLy8gLSBhIGZvciBtaW49MCB3b3VsZCByZXF1aXJlIC0xOiAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIC0xbiwgUClgXG4gICAgLy8gLSBiIHdvdWxkIGNvbW1vbmx5IHJlcXVpcmUgc3VidHJhY3Rpb246ICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQIC0gMW4pYFxuICAgIC8vIC0gb3VyIHdheSBpcyB0aGUgY2xlYW5lc3Q6ICAgICAgICAgICAgICAgYGluUmFuZ2UoJ3gnLCB4LCAwbiwgUClcbiAgICBpZiAoIWluUmFuZ2UobiwgbWluLCBtYXgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkICcgKyB0aXRsZSArICc6ICcgKyBtaW4gKyAnIDw9IG4gPCAnICsgbWF4ICsgJywgZ290ICcgKyBuKTtcbn1cbi8vIEJpdCBvcGVyYXRpb25zXG4vKipcbiAqIENhbGN1bGF0ZXMgYW1vdW50IG9mIGJpdHMgaW4gYSBiaWdpbnQuXG4gKiBTYW1lIGFzIGBuLnRvU3RyaW5nKDIpLmxlbmd0aGBcbiAqIFRPRE86IG1lcmdlIHdpdGggbkxlbmd0aCBpbiBtb2R1bGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRTZXQobiwgcG9zLCB2YWx1ZSkge1xuICAgIHJldHVybiBuIHwgKCh2YWx1ZSA/IF8xbiA6IF8wbikgPDwgQmlnSW50KHBvcykpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgbWFzayBmb3IgTiBiaXRzLiBOb3QgdXNpbmcgKiogb3BlcmF0b3Igd2l0aCBiaWdpbnRzIGJlY2F1c2Ugb2Ygb2xkIGVuZ2luZXMuXG4gKiBTYW1lIGFzIEJpZ0ludChgMGIke0FycmF5KGkpLmZpbGwoJzEnKS5qb2luKCcnKX1gKVxuICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzFuIDw8IEJpZ0ludChuKSkgLSBfMW47XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGNvbnN0IHU4biA9IChsZW4pID0+IG5ldyBVaW50OEFycmF5KGxlbik7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuICAgIGNvbnN0IHU4b2YgPSAoYnl0ZSkgPT4gVWludDhBcnJheS5vZihieXRlKTsgLy8gYW5vdGhlciBzaG9ydGN1dFxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKDApKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4b2YoMHgwMCksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThvZigweDAxKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlc18oLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzXyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSAnICsgU3RyaW5nKGZpZWxkTmFtZSkgKyAnIGlzIGludmFsaWQuIEV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGFzaCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdmFsaWRhdGVPYmplY3Qob2JqZWN0LCBmaWVsZHMsIG9wdEZpZWxkcyA9IHt9KSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgb3B0aW9ucyBvYmplY3QnKTtcbiAgICBmdW5jdGlvbiBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgZXhwZWN0ZWRUeXBlLCBpc09wdCkge1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0ICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdHlwZW9mIHZhbDtcbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IGV4cGVjdGVkVHlwZSB8fCB2YWwgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmFtIFwiJHtmaWVsZE5hbWV9XCIgaXMgaW52YWxpZDogZXhwZWN0ZWQgJHtleHBlY3RlZFR5cGV9LCBnb3QgJHtjdXJyZW50fWApO1xuICAgIH1cbiAgICBPYmplY3QuZW50cmllcyhmaWVsZHMpLmZvckVhY2goKFtrLCB2XSkgPT4gY2hlY2tGaWVsZChrLCB2LCBmYWxzZSkpO1xuICAgIE9iamVjdC5lbnRyaWVzKG9wdEZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIHRydWUpKTtcbn1cbi8qKlxuICogdGhyb3dzIG5vdCBpbXBsZW1lbnRlZCBlcnJvclxuICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/curves/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/curves/utils.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/curves/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.notImplemented = exports.bitMask = exports.utf8ToBytes = exports.randomBytes = exports.isBytes = exports.hexToBytes = exports.concatBytes = exports.bytesToUtf8 = exports.bytesToHex = exports.anumber = exports.abytes = void 0;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.equalBytes = equalBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.isHash = isHash;\nexports._validateObject = _validateObject;\nexports.memoized = memoized;\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\nvar utils_js_2 = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\nObject.defineProperty(exports, \"abytes\", ({ enumerable: true, get: function () { return utils_js_2.abytes; } }));\nObject.defineProperty(exports, \"anumber\", ({ enumerable: true, get: function () { return utils_js_2.anumber; } }));\nObject.defineProperty(exports, \"bytesToHex\", ({ enumerable: true, get: function () { return utils_js_2.bytesToHex; } }));\nObject.defineProperty(exports, \"bytesToUtf8\", ({ enumerable: true, get: function () { return utils_js_2.bytesToUtf8; } }));\nObject.defineProperty(exports, \"concatBytes\", ({ enumerable: true, get: function () { return utils_js_2.concatBytes; } }));\nObject.defineProperty(exports, \"hexToBytes\", ({ enumerable: true, get: function () { return utils_js_2.hexToBytes; } }));\nObject.defineProperty(exports, \"isBytes\", ({ enumerable: true, get: function () { return utils_js_2.isBytes; } }));\nObject.defineProperty(exports, \"randomBytes\", ({ enumerable: true, get: function () { return utils_js_2.randomBytes; } }));\nObject.defineProperty(exports, \"utf8ToBytes\", ({ enumerable: true, get: function () { return utils_js_2.utf8ToBytes; } }));\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0, utils_js_1.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0, utils_js_1.abytes)(bytes);\n    return hexToNumber((0, utils_js_1.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0, utils_js_1.hexToBytes)(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0, utils_js_1.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = (0, utils_js_1.hexToBytes)(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if ((0, utils_js_1.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len) => new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte) => Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0, utils_js_1.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || (0, utils_js_1.isBytes)(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== 'object')\n        throw new Error('expected valid options object');\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined)\n            return;\n        const current = typeof val;\n        if (current !== expectedType || val === null)\n            throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n    throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLGVBQWUsR0FBRyxtQkFBbUIsR0FBRyxtQkFBbUIsR0FBRyxlQUFlLEdBQUcsa0JBQWtCLEdBQUcsbUJBQW1CLEdBQUcsbUJBQW1CLEdBQUcsa0JBQWtCLEdBQUcsZUFBZSxHQUFHLGNBQWM7QUFDL04sYUFBYTtBQUNiLDJCQUEyQjtBQUMzQixtQkFBbUI7QUFDbkIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCLDBCQUEwQjtBQUMxQixtQkFBbUI7QUFDbkIsa0JBQWtCO0FBQ2xCLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2Qsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QixjQUFjO0FBQ2QsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsK0ZBQXdCO0FBQ25ELGlCQUFpQixtQkFBTyxDQUFDLCtGQUF3QjtBQUNqRCwwQ0FBeUMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDOUcsMkNBQTBDLEVBQUUscUNBQXFDLDhCQUE4QixFQUFDO0FBQ2hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCwrQ0FBOEMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDeEgsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILDhDQUE2QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUN0SCwyQ0FBMEMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDaEgsK0NBQThDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3hILCtDQUE4QyxFQUFFLHFD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bW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RJbXBsZW1lbnRlZCA9IGV4cG9ydHMuYml0TWFzayA9IGV4cG9ydHMudXRmOFRvQnl0ZXMgPSBleHBvcnRzLnJhbmRvbUJ5dGVzID0gZXhwb3J0cy5pc0J5dGVzID0gZXhwb3J0cy5oZXhUb0J5dGVzID0gZXhwb3J0cy5jb25jYXRCeXRlcyA9IGV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBleHBvcnRzLmJ5dGVzVG9IZXggPSBleHBvcnRzLmFudW1iZXIgPSBleHBvcnRzLmFieXRlcyA9IHZvaWQgMDtcbmV4cG9ydHMuYWJvb2wgPSBhYm9vbDtcbmV4cG9ydHMubnVtYmVyVG9IZXhVbnBhZGRlZCA9IG51bWJlclRvSGV4VW5wYWRkZWQ7XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGJ5dGVzVG9OdW1iZXJCRTtcbmV4cG9ydHMuYnl0ZXNUb051bWJlckxFID0gYnl0ZXNUb051bWJlckxFO1xuZXhwb3J0cy5udW1iZXJUb0J5dGVzQkUgPSBudW1iZXJUb0J5dGVzQkU7XG5leHBvcnRzLm51bWJlclRvQnl0ZXNMRSA9IG51bWJlclRvQnl0ZXNMRTtcbmV4cG9ydHMubnVtYmVyVG9WYXJCeXRlc0JFID0gbnVtYmVyVG9WYXJCeXRlc0JFO1xuZXhwb3J0cy5lbnN1cmVCeXRlcyA9IGVuc3VyZUJ5dGVzO1xuZXhwb3J0cy5lcXVhbEJ5dGVzID0gZXF1YWxCeXRlcztcbmV4cG9ydHMuaW5SYW5nZSA9IGluUmFuZ2U7XG5leHBvcnRzLmFJblJhbmdlID0gYUluUmFuZ2U7XG5leHBvcnRzLmJpdExlbiA9IGJpdExlbjtcbmV4cG9ydHMuYml0R2V0ID0gYml0R2V0O1xuZXhwb3J0cy5iaXRTZXQgPSBiaXRTZXQ7XG5leHBvcnRzLmNyZWF0ZUhtYWNEcmJnID0gY3JlYXRlSG1hY0RyYmc7XG5leHBvcnRzLnZhbGlkYXRlT2JqZWN0ID0gdmFsaWRhdGVPYmplY3Q7XG5leHBvcnRzLmlzSGFzaCA9IGlzSGFzaDtcbmV4cG9ydHMuX3ZhbGlkYXRlT2JqZWN0ID0gX3ZhbGlkYXRlT2JqZWN0O1xuZXhwb3J0cy5tZW1vaXplZCA9IG1lbW9pemVkO1xuLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHMuanNcIik7XG52YXIgdXRpbHNfanNfMiA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3V0aWxzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWJ5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmFieXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFudW1iZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuYW51bWJlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9IZXhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuYnl0ZXNUb0hleDsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ5dGVzVG9VdGY4XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmJ5dGVzVG9VdGY4OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29uY2F0Qnl0ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzX2pzXzIuY29uY2F0Qnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJoZXhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmhleFRvQnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLmlzQnl0ZXM7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyYW5kb21CeXRlc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfanNfMi5yYW5kb21CeXRlczsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInV0ZjhUb0J5dGVzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc19qc18yLnV0ZjhUb0J5dGVzOyB9IH0pO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5mdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgYm9vbGVhbiBleHBlY3RlZCwgZ290ICcgKyB2YWx1ZSk7XG59XG4vLyBVc2VkIGluIHdlaWVyc3RyYXNzLCBkZXJcbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICByZXR1cm4gaGV4ID09PSAnJyA/IF8wbiA6IEJpZ0ludCgnMHgnICsgaGV4KTsgLy8gQmlnIEVuZGlhblxufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb0hleCkoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgICgwLCB1dGlsc19qc18xLmFieXRlcykoYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcigoMCwgdXRpbHNfanNfMS5ieXRlc1RvSGV4KShVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5oZXhUb0J5dGVzKShuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNMRShuLCBsZW4pIHtcbiAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikucmV2ZXJzZSgpO1xufVxuLy8gVW5wYWRkZWQsIHJhcmVseSB1c2VkXG5mdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5oZXhUb0J5dGVzKShudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAncHJpdmF0ZSBrZXknXG4gKiBAcGFyYW0gaGV4IGhleCBzdHJpbmcgb3IgVWludDhBcnJheVxuICogQHBhcmFtIGV4cGVjdGVkTGVuZ3RoIG9wdGlvbmFsLCB3aWxsIGNvbXBhcmUgdG8gcmVzdWx0IGFycmF5J3MgbGVuZ3RoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSAoMCwgdXRpbHNfanNfMS5oZXhUb0J5dGVzKShoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKCgwLCB1dGlsc19qc18xLmlzQnl0ZXMpKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IHV0ZjhUb0J5dGVzOiB0eXBlb2YgdXRmOFRvQnl0ZXNfID0gdXRmOFRvQnl0ZXNfO1xuLyoqXG4gKiBDb252ZXJ0cyBieXRlcyB0byBzdHJpbmcgdXNpbmcgVVRGOCBlbmNvZGluZy5cbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KFVpbnQ4QXJyYXkuZnJvbShbOTcsIDk4LCA5OV0pKSAvLyAnYWJjJ1xuICovXG4vLyBleHBvcnQgY29uc3QgYnl0ZXNUb1V0Zjg6IHR5cGVvZiBieXRlc1RvVXRmOF8gPSBieXRlc1RvVXRmOF87XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG4gICAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcbiAgICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gICAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgJyArIHRpdGxlICsgJzogJyArIG1pbiArICcgPD0gbiA8ICcgKyBtYXggKyAnLCBnb3QgJyArIG4pO1xufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICogVE9ETzogbWVyZ2Ugd2l0aCBuTGVuZ3RoIGluIG1vZHVsYXJcbiAqL1xuZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmZ1bmN0aW9uIGJpdEdldChuLCBwb3MpIHtcbiAgICByZXR1cm4gKG4gPj4gQmlnSW50KHBvcykpICYgXzFuO1xufVxuLyoqXG4gKiBTZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8xbiA8PCBCaWdJbnQobikpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBjb25zdCB1OG4gPSAobGVuKSA9PiBuZXcgVWludDhBcnJheShsZW4pOyAvLyBjcmVhdGVzIFVpbnQ4QXJyYXlcbiAgICBjb25zdCB1OG9mID0gKGJ5dGUpID0+IFVpbnQ4QXJyYXkub2YoYnl0ZSk7IC8vIGFub3RoZXIgc2hvcnRjdXRcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigwKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OG9mKDB4MDApLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4b2YoMHgwMSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgKDAsIHV0aWxzX2pzXzEuaXNCeXRlcykodmFsKSxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB2YWxpZGF0b3IgZnVuY3Rpb24nKTtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdGlvbmFsICYmIHZhbCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIWNoZWNrVmFsKHZhbCwgb2JqZWN0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbSAnICsgU3RyaW5nKGZpZWxkTmFtZSkgKyAnIGlzIGludmFsaWQuIEV4cGVjdGVkICcgKyB0eXBlICsgJywgZ290ICcgKyB2YWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuZnVuY3Rpb24gaXNIYXNoKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pO1xufVxuZnVuY3Rpb24gX3ZhbGlkYXRlT2JqZWN0KG9iamVjdCwgZmllbGRzLCBvcHRGaWVsZHMgPSB7fSkge1xuICAgIGlmICghb2JqZWN0IHx8IHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIG9wdGlvbnMgb2JqZWN0Jyk7XG4gICAgZnVuY3Rpb24gY2hlY2tGaWVsZChmaWVsZE5hbWUsIGV4cGVjdGVkVHlwZSwgaXNPcHQpIHtcbiAgICAgICAgY29uc3QgdmFsID0gb2JqZWN0W2ZpZWxkTmFtZV07XG4gICAgICAgIGlmIChpc09wdCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHR5cGVvZiB2YWw7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBleHBlY3RlZFR5cGUgfHwgdmFsID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwYXJhbSBcIiR7ZmllbGROYW1lfVwiIGlzIGludmFsaWQ6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7Y3VycmVudH1gKTtcbiAgICB9XG4gICAgT2JqZWN0LmVudHJpZXMoZmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgZmFsc2UpKTtcbiAgICBPYmplY3QuZW50cmllcyhvcHRGaWVsZHMpLmZvckVhY2goKFtrLCB2XSkgPT4gY2hlY2tGaWVsZChrLCB2LCB0cnVlKSk7XG59XG4vKipcbiAqIHRocm93cyBub3QgaW1wbGVtZW50ZWQgZXJyb3JcbiAqL1xuY29uc3Qgbm90SW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5leHBvcnRzLm5vdEltcGxlbWVudGVkID0gbm90SW1wbGVtZW50ZWQ7XG4vKipcbiAqIE1lbW9pemVzIChjYWNoZXMpIGNvbXB1dGF0aW9uIHJlc3VsdC5cbiAqIFVzZXMgV2Vha01hcDogdGhlIHZhbHVlIGlzIGdvaW5nIGF1dG8tY2xlYW5lZCBieSBHQyBhZnRlciBsYXN0IHJlZmVyZW5jZSBpcyByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/curves/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_md.js":
/*!***************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/_md.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SHA512_IV = exports.SHA384_IV = exports.SHA224_IV = exports.SHA256_IV = exports.HashMD = void 0;\nexports.setBigUint64 = setBigUint64;\nexports.Chi = Chi;\nexports.Maj = Maj;\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends utils_ts_1.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0, utils_ts_1.createView)(this.buffer);\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0, utils_ts_1.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aexists)(this);\n        (0, utils_ts_1.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0, utils_ts_1.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0, utils_ts_1.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\nexports.HashMD = HashMD;\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexports.SHA256_IV = Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexports.SHA224_IV = Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexports.SHA384_IV = Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexports.SHA512_IV = Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL19tZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxjQUFjO0FBQzlGLG9CQUFvQjtBQUNwQixXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXF9tZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0hBNTEyX0lWID0gZXhwb3J0cy5TSEEzODRfSVYgPSBleHBvcnRzLlNIQTIyNF9JViA9IGV4cG9ydHMuU0hBMjU2X0lWID0gZXhwb3J0cy5IYXNoTUQgPSB2b2lkIDA7XG5leHBvcnRzLnNldEJpZ1VpbnQ2NCA9IHNldEJpZ1VpbnQ2NDtcbmV4cG9ydHMuQ2hpID0gQ2hpO1xuZXhwb3J0cy5NYWogPSBNYWo7XG4vKipcbiAqIEludGVybmFsIE1lcmtsZS1EYW1nYXJkIGhhc2ggdXRpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IHV0aWxzX3RzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8qKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0LiBodHRwczovL2Nhbml1c2UuY29tL21kbi1qYXZhc2NyaXB0X2J1aWx0aW5zX2RhdGF2aWV3X3NldGJpZ3VpbnQ2NCAqL1xuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8qKiBDaG9pY2U6IGEgPyBiIDogYyAqL1xuZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5mdW5jdGlvbiBNYWooYSwgYiwgYykge1xuICAgIHJldHVybiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG59XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuY2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX3RzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoOiB3ZSBoYXZlIGF0IGxlYXN0IG9uZSBibG9jayBpbiBpbnB1dCwgY2FzdCBpdCB0byB2aWV3IGFuZCBwcm9jZXNzXG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhVmlldyA9ICgwLCB1dGlsc190c18xLmNyZWF0ZVZpZXcpKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFleGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG5leHBvcnRzLkhhc2hNRCA9IEhhc2hNRDtcbi8qKlxuICogSW5pdGlhbCBTSEEtMiBzdGF0ZTogZnJhY3Rpb25hbCBwYXJ0cyBvZiBzcXVhcmUgcm9vdHMgb2YgZmlyc3QgMTYgcHJpbWVzIDIuLjUzLlxuICogQ2hlY2sgb3V0IGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgIGZvciByZWNvbXB1dGF0aW9uIGd1aWRlLlxuICovXG4vKiogSW5pdGlhbCBTSEEyNTYgc3RhdGUuIEJpdHMgMC4uMzIgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnRzLlNIQTI1Nl9JViA9IFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTksXG5dKTtcbi8qKiBJbml0aWFsIFNIQTIyNCBzdGF0ZS4gQml0cyAzMi4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEyMjRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGMxMDU5ZWQ4LCAweDM2N2NkNTA3LCAweDMwNzBkZDE3LCAweGY3MGU1OTM5LCAweGZmYzAwYjMxLCAweDY4NTgxNTExLCAweDY0Zjk4ZmE3LCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEzODQgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIzLi41MyAqL1xuZXhwb3J0cy5TSEEzODRfSVYgPSBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LCAweDYyOWEyOTJhLCAweDM2N2NkNTA3LCAweDkxNTkwMTVhLCAweDMwNzBkZDE3LCAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsIDB4OGViNDRhODcsIDB4Njg1ODE1MTEsIDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcsIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQsXG5dKTtcbi8qKiBJbml0aWFsIFNIQTUxMiBzdGF0ZS4gQml0cyAwLi42NCBvZiBmcmFjIHBhcnQgb2Ygc3FydCBvZiBwcmltZXMgMi4uMTkgKi9cbmV4cG9ydHMuU0hBNTEyX0lWID0gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCwgMHhiYjY3YWU4NSwgMHg4NGNhYTczYiwgMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiwgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLCAweDliMDU2ODhjLCAweDJiM2U2YzFmLCAweDFmODNkOWFiLCAweGZiNDFiZDZiLCAweDViZTBjZDE5LCAweDEzN2UyMTc5LFxuXSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fbWQuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_md.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_u64.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/_u64.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.toBig = exports.shrSL = exports.shrSH = exports.rotrSL = exports.rotrSH = exports.rotrBL = exports.rotrBH = exports.rotr32L = exports.rotr32H = exports.rotlSL = exports.rotlSH = exports.rotlBL = exports.rotlBH = exports.add5L = exports.add5H = exports.add4L = exports.add4H = exports.add3L = exports.add3H = void 0;\nexports.add = add;\nexports.fromBig = fromBig;\nexports.split = split;\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\nexports.toBig = toBig;\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nexports.shrSH = shrSH;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.shrSL = shrSL;\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nexports.rotrSH = rotrSH;\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\nexports.rotrSL = rotrSL;\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nexports.rotrBH = rotrBH;\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\nexports.rotrBL = rotrBL;\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nexports.rotr32H = rotr32H;\nconst rotr32L = (h, _l) => h;\nexports.rotr32L = rotr32L;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nexports.rotlSH = rotlSH;\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\nexports.rotlSL = rotlSL;\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nexports.rotlBH = rotlBH;\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\nexports.rotlBL = rotlBL;\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nexports.add3L = add3L;\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nexports.add3H = add3H;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nexports.add4L = add4L;\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nexports.add4H = add4H;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nexports.add5L = add5L;\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\nexports.add5H = add5H;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexports[\"default\"] = u64;\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL191NjQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYTtBQUN6VCxXQUFXO0FBQ1gsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxfdTY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50b0JpZyA9IGV4cG9ydHMuc2hyU0wgPSBleHBvcnRzLnNoclNIID0gZXhwb3J0cy5yb3RyU0wgPSBleHBvcnRzLnJvdHJTSCA9IGV4cG9ydHMucm90ckJMID0gZXhwb3J0cy5yb3RyQkggPSBleHBvcnRzLnJvdHIzMkwgPSBleHBvcnRzLnJvdHIzMkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RsQkwgPSBleHBvcnRzLnJvdGxCSCA9IGV4cG9ydHMuYWRkNUwgPSBleHBvcnRzLmFkZDVIID0gZXhwb3J0cy5hZGQ0TCA9IGV4cG9ydHMuYWRkNEggPSBleHBvcnRzLmFkZDNMID0gZXhwb3J0cy5hZGQzSCA9IHZvaWQgMDtcbmV4cG9ydHMuYWRkID0gYWRkO1xuZXhwb3J0cy5mcm9tQmlnID0gZnJvbUJpZztcbmV4cG9ydHMuc3BsaXQgPSBzcGxpdDtcbi8qKlxuICogSW50ZXJuYWwgaGVscGVycyBmb3IgdTY0LiBCaWdVaW50NjRBcnJheSBpcyB0b28gc2xvdyBhcyBwZXIgMjAyNSwgc28gd2UgaW1wbGVtZW50IGl0IHVzaW5nIFVpbnQzMkFycmF5LlxuICogQHRvZG8gcmUtY2hlY2sgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MjIxMjU4OFxuICogQG1vZHVsZVxuICovXG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0gbHN0Lmxlbmd0aDtcbiAgICBsZXQgQWggPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobGVuKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgaCwgbCB9ID0gZnJvbUJpZyhsc3RbaV0sIGxlKTtcbiAgICAgICAgW0FoW2ldLCBBbFtpXV0gPSBbaCwgbF07XG4gICAgfVxuICAgIHJldHVybiBbQWgsIEFsXTtcbn1cbmNvbnN0IHRvQmlnID0gKGgsIGwpID0+IChCaWdJbnQoaCA+Pj4gMCkgPDwgXzMybikgfCBCaWdJbnQobCA+Pj4gMCk7XG5leHBvcnRzLnRvQmlnID0gdG9CaWc7XG4vLyBmb3IgU2hpZnQgaW4gWzAsIDMyKVxuY29uc3Qgc2hyU0ggPSAoaCwgX2wsIHMpID0+IGggPj4+IHM7XG5leHBvcnRzLnNoclNIID0gc2hyU0g7XG5jb25zdCBzaHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnNoclNMID0gc2hyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdHJTSCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gcykgfCAobCA8PCAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdHJTSCA9IHJvdHJTSDtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG5leHBvcnRzLnJvdHJTTCA9IHJvdHJTTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuZXhwb3J0cy5yb3RyQkggPSByb3RyQkg7XG5jb25zdCByb3RyQkwgPSAoaCwgbCwgcykgPT4gKGggPj4+IChzIC0gMzIpKSB8IChsIDw8ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90ckJMID0gcm90ckJMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5leHBvcnRzLnJvdHIzMkggPSByb3RyMzJIO1xuY29uc3Qgcm90cjMyTCA9IChoLCBfbCkgPT4gaDtcbmV4cG9ydHMucm90cjMyTCA9IHJvdHIzMkw7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNIID0gcm90bFNIO1xuY29uc3Qgcm90bFNMID0gKGgsIGwsIHMpID0+IChsIDw8IHMpIHwgKGggPj4+ICgzMiAtIHMpKTtcbmV4cG9ydHMucm90bFNMID0gcm90bFNMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmV4cG9ydHMucm90bEJIID0gcm90bEJIO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCTCA9IHJvdGxCTDtcbi8vIEpTIHVzZXMgMzItYml0IHNpZ25lZCBpbnRlZ2VycyBmb3IgYml0d2lzZSBvcGVyYXRpb25zIHdoaWNoIG1lYW5zIHdlIGNhbm5vdFxuLy8gc2ltcGxlIHRha2UgY2Fycnkgb3V0IG9mIGxvdyBiaXQgc3VtIGJ5IHNoaWZ0LCB3ZSBuZWVkIHRvIHVzZSBkaXZpc2lvbi5cbmZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmV4cG9ydHMuYWRkM0wgPSBhZGQzTDtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuZXhwb3J0cy5hZGQzSCA9IGFkZDNIO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDRMID0gYWRkNEw7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNEggPSBhZGQ0SDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDVMID0gYWRkNUw7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkNUggPSBhZGQ1SDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_u64.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/cryptoNode.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/cryptoNode.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.crypto = void 0;\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */\n// @ts-ignore\nconst nc = __webpack_require__(/*! node:crypto */ \"node:crypto\");\nexports.crypto = nc && typeof nc === 'object' && 'webcrypto' in nc\n    ? nc.webcrypto\n    : nc && typeof nc === 'object' && 'randomBytes' in nc\n        ? nc\n        : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2NyeXB0b05vZGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsZ0NBQWE7QUFDaEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGNyeXB0b05vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmNvbnN0IG5jID0gcmVxdWlyZShcIm5vZGU6Y3J5cHRvXCIpO1xuZXhwb3J0cy5jcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_md.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/_md.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: () => (/* binding */ Chi),\n/* harmony export */   HashMD: () => (/* binding */ HashMD),\n/* harmony export */   Maj: () => (/* binding */ Maj),\n/* harmony export */   SHA224_IV: () => (/* binding */ SHA224_IV),\n/* harmony export */   SHA256_IV: () => (/* binding */ SHA256_IV),\n/* harmony export */   SHA384_IV: () => (/* binding */ SHA384_IV),\n/* harmony export */   SHA512_IV: () => (/* binding */ SHA512_IV),\n/* harmony export */   setBigUint64: () => (/* binding */ setBigUint64)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n/** Choice: a ? b : c */\nfunction Chi(a, b, c) {\n    return (a & b) ^ (~a & c);\n}\n/** Majority function, true if any two inputs is true. */\nfunction Maj(a, b, c) {\n    return (a & b) ^ (a & c) ^ (b & c);\n}\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(data);\n        const { view, buffer, blockLen } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aexists)(this);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aoutput)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.clean)(this.buffer.subarray(pos));\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.destroyed = destroyed;\n        to.finished = finished;\n        to.length = length;\n        to.pos = pos;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n    clone() {\n        return this._cloneInto();\n    }\n}\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nconst SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nconst SHA224_IV = /* @__PURE__ */ Uint32Array.from([\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nconst SHA384_IV = /* @__PURE__ */ Uint32Array.from([\n    0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n    0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nconst SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n    0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDd0Y7QUFDeEY7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmLGVBQWUsa0RBQU87QUFDdEIsUUFBUSxpREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGtEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCO0FBQy9DLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcX21kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgTWVya2xlLURhbWdhcmQgaGFzaCB1dGlscy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgSGFzaCwgYWJ5dGVzLCBhZXhpc3RzLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKiogUG9seWZpbGwgZm9yIFNhZmFyaSAxNC4gaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tamF2YXNjcmlwdF9idWlsdGluc19kYXRhdmlld19zZXRiaWd1aW50NjQgKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLyoqIENob2ljZTogYSA/IGIgOiBjICovXG5leHBvcnQgZnVuY3Rpb24gQ2hpKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeICh+YSAmIGMpO1xufVxuLyoqIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXRzIGlzIHRydWUuICovXG5leHBvcnQgZnVuY3Rpb24gTWFqKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xufVxuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBhb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgY2xlYW4odGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKSk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW5cbiAgICAgICAgLy8gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWwgU0hBLTIgc3RhdGU6IGZyYWN0aW9uYWwgcGFydHMgb2Ygc3F1YXJlIHJvb3RzIG9mIGZpcnN0IDE2IHByaW1lcyAyLi41My5cbiAqIENoZWNrIG91dCBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYCBmb3IgcmVjb21wdXRhdGlvbiBndWlkZS5cbiAqL1xuLyoqIEluaXRpYWwgU0hBMjU2IHN0YXRlLiBCaXRzIDAuLjMyIG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyLi4xOSAqL1xuZXhwb3J0IGNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5LFxuXSk7XG4vKiogSW5pdGlhbCBTSEEyMjQgc3RhdGUuIEJpdHMgMzIuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjMTA1OWVkOCwgMHgzNjdjZDUwNywgMHgzMDcwZGQxNywgMHhmNzBlNTkzOSwgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCxcbl0pO1xuLyoqIEluaXRpYWwgU0hBMzg0IHN0YXRlLiBCaXRzIDAuLjY0IG9mIGZyYWMgcGFydCBvZiBzcXJ0IG9mIHByaW1lcyAyMy4uNTMgKi9cbmV4cG9ydCBjb25zdCBTSEEzODRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHhjYmJiOWQ1ZCwgMHhjMTA1OWVkOCwgMHg2MjlhMjkyYSwgMHgzNjdjZDUwNywgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNywgMHgxNTJmZWNkOCwgMHhmNzBlNTkzOSxcbiAgICAweDY3MzMyNjY3LCAweGZmYzAwYjMxLCAweDhlYjQ0YTg3LCAweDY4NTgxNTExLCAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LCAweDQ3YjU0ODFkLCAweGJlZmE0ZmE0LFxuXSk7XG4vKiogSW5pdGlhbCBTSEE1MTIgc3RhdGUuIEJpdHMgMC4uNjQgb2YgZnJhYyBwYXJ0IG9mIHNxcnQgb2YgcHJpbWVzIDIuLjE5ICovXG5leHBvcnQgY29uc3QgU0hBNTEyX0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NmEwOWU2NjcsIDB4ZjNiY2M5MDgsIDB4YmI2N2FlODUsIDB4ODRjYWE3M2IsIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsIDB4YTU0ZmY1M2EsIDB4NWYxZDM2ZjEsXG4gICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSwgMHg5YjA1Njg4YywgMHgyYjNlNmMxZiwgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YiwgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSxcbl0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js":
/*!********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: () => (/* binding */ add),\n/* harmony export */   add3H: () => (/* binding */ add3H),\n/* harmony export */   add3L: () => (/* binding */ add3L),\n/* harmony export */   add4H: () => (/* binding */ add4H),\n/* harmony export */   add4L: () => (/* binding */ add4L),\n/* harmony export */   add5H: () => (/* binding */ add5H),\n/* harmony export */   add5L: () => (/* binding */ add5L),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   fromBig: () => (/* binding */ fromBig),\n/* harmony export */   rotlBH: () => (/* binding */ rotlBH),\n/* harmony export */   rotlBL: () => (/* binding */ rotlBL),\n/* harmony export */   rotlSH: () => (/* binding */ rotlSH),\n/* harmony export */   rotlSL: () => (/* binding */ rotlSL),\n/* harmony export */   rotr32H: () => (/* binding */ rotr32H),\n/* harmony export */   rotr32L: () => (/* binding */ rotr32L),\n/* harmony export */   rotrBH: () => (/* binding */ rotrBH),\n/* harmony export */   rotrBL: () => (/* binding */ rotrBL),\n/* harmony export */   rotrSH: () => (/* binding */ rotrSH),\n/* harmony export */   rotrSL: () => (/* binding */ rotrSL),\n/* harmony export */   shrSH: () => (/* binding */ shrSH),\n/* harmony export */   shrSL: () => (/* binding */ shrSL),\n/* harmony export */   split: () => (/* binding */ split),\n/* harmony export */   toBig: () => (/* binding */ toBig)\n/* harmony export */ });\n/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0IsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnTDtBQUNoTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcX3U2NC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEludGVybmFsIGhlbHBlcnMgZm9yIHU2NC4gQmlnVWludDY0QXJyYXkgaXMgdG9vIHNsb3cgYXMgcGVyIDIwMjUsIHNvIHdlIGltcGxlbWVudCBpdCB1c2luZyBVaW50MzJBcnJheS5cbiAqIEB0b2RvIHJlLWNoZWNrIGh0dHBzOi8vaXNzdWVzLmNocm9taXVtLm9yZy9pc3N1ZXMvNDIyMTI1ODhcbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGxzdC5sZW5ndGg7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgbGV0IEFsID0gbmV3IFVpbnQzMkFycmF5KGxlbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGFkZCwgYWRkM0gsIGFkZDNMLCBhZGQ0SCwgYWRkNEwsIGFkZDVILCBhZGQ1TCwgZnJvbUJpZywgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCByb3RyMzJILCByb3RyMzJMLCByb3RyQkgsIHJvdHJCTCwgcm90clNILCByb3RyU0wsIHNoclNILCBzaHJTTCwgc3BsaXQsIHRvQmlnIH07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0IGRlZmF1bHQgdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: () => (/* binding */ crypto)\n/* harmony export */ });\n/* harmony import */ var node_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:crypto */ \"node:crypto\");\n/**\n * Internal webcrypto alias.\n * We prefer WebCrypto aka globalThis.crypto, which exists in node.js 16+.\n * Falls back to Node.js built-in crypto for Node.js <=v14.\n * See utils.ts for details.\n * @module\n */\n// @ts-ignore\n\nconst crypto = /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"webcrypto\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n    ? node_crypto__WEBPACK_IMPORTED_MODULE_0__.webcrypto\n    : /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) && typeof /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2))) === 'object' && \"randomBytes\" in /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n        ? /*#__PURE__*/ (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (node_crypto__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(node_crypto__WEBPACK_IMPORTED_MODULE_0__, 2)))\n        : undefined;\n//# sourceMappingURL=cryptoNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDa0M7QUFDM0IsZUFBZSwyTUFBRSxXQUFXLDJNQUFFLGlCQUFpQiwwTkFBaUI7QUFDdkUsTUFBTSxrREFBWTtBQUNsQixNQUFNLDJNQUFFLFdBQVcsMk1BQUUsaUJBQWlCLDROQUFtQjtBQUN6RCxVQUFVLDJNQUFFO0FBQ1o7QUFDQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxjcnlwdG9Ob2RlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgd2ViY3J5cHRvIGFsaWFzLlxuICogV2UgcHJlZmVyIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBub2RlLmpzIDE2Ky5cbiAqIEZhbGxzIGJhY2sgdG8gTm9kZS5qcyBidWlsdC1pbiBjcnlwdG8gZm9yIE5vZGUuanMgPD12MTQuXG4gKiBTZWUgdXRpbHMudHMgZm9yIGRldGFpbHMuXG4gKiBAbW9kdWxlXG4gKi9cbi8vIEB0cy1pZ25vcmVcbmltcG9ydCAqIGFzIG5jIGZyb20gJ25vZGU6Y3J5cHRvJztcbmV4cG9ydCBjb25zdCBjcnlwdG8gPSBuYyAmJiB0eXBlb2YgbmMgPT09ICdvYmplY3QnICYmICd3ZWJjcnlwdG8nIGluIG5jXG4gICAgPyBuYy53ZWJjcnlwdG9cbiAgICA6IG5jICYmIHR5cGVvZiBuYyA9PT0gJ29iamVjdCcgJiYgJ3JhbmRvbUJ5dGVzJyBpbiBuY1xuICAgICAgICA/IG5jXG4gICAgICAgIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvTm9kZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MD5: () => (/* binding */ MD5),\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   SHA1: () => (/* binding */ SHA1),\n/* harmony export */   md5: () => (/* binding */ md5),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160),\n/* harmony export */   sha1: () => (/* binding */ sha1)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\n\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nconst sha1 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nconst md5 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nconst ripemd160 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9sZWdhY3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiwwQ0FBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQyx3QkFBd0IsK0NBQUk7QUFDNUI7QUFDQSxjQUFjLGdCQUFnQjtBQUM5Qix3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLDJDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSTtBQUMzQjtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHVEQUFZO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sa0JBQWtCLDBDQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkNBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwrQ0FBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw0QkFBNEIsdURBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdCQUF3QiwwQ0FBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDO0FBQ0EsMERBQTBEO0FBQzFELHNEQUFzRDtBQUN0RCxrRUFBa0U7QUFDbEUsNEJBQTRCLFFBQVE7QUFDcEMsNEJBQTRCLCtDQUFJO0FBQ2hDLHVDQUF1QywrQ0FBSSxnQ0FBZ0M7QUFDM0U7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDLDRCQUE0QiwrQ0FBSTtBQUNoQyx1Q0FBdUMsK0NBQUksZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFLO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyx1REFBWTtBQUNyRCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxsZWdhY3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG5cblNIQTEgKFJGQyAzMTc0KSwgTUQ1IChSRkMgMTMyMSkgYW5kIFJJUEVNRDE2MCAoUkZDIDIyODYpIGxlZ2FjeSwgd2VhayBoYXNoIGZ1bmN0aW9ucy5cbkRvbid0IHVzZSB0aGVtIGluIGEgbmV3IHByb3RvY29sLiBXaGF0IFwid2Vha1wiIG1lYW5zOlxuXG4tIENvbGxpc2lvbnMgY2FuIGJlIG1hZGUgd2l0aCAyXjE4IGVmZm9ydCBpbiBNRDUsIDJeNjAgaW4gU0hBMSwgMl44MCBpbiBSSVBFTUQxNjAuXG4tIE5vIHByYWN0aWNhbCBwcmUtaW1hZ2UgYXR0YWNrcyAob25seSB0aGVvcmV0aWNhbCwgMl4xMjMuNClcbi0gSE1BQyBzZWVtcyBraW5kYSBvazogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MTUxXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IENoaSwgSGFzaE1ELCBNYWogfSBmcm9tIFwiLi9fbWQuanNcIjtcbmltcG9ydCB7IGNsZWFuLCBjcmVhdGVIYXNoZXIsIHJvdGwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLyoqIEluaXRpYWwgU0hBMSBzdGF0ZSAqL1xuY29uc3QgU0hBMV9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwLFxuXSk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBTSEExX1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbi8qKiBTSEExIGxlZ2FjeSBoYXNoIGNsYXNzLiAqL1xuZXhwb3J0IGNsYXNzIFNIQTEgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMjAsIDgsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5BID0gU0hBMV9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTFfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEExX0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMV9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTFfSVZbNF0gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFXTtcbiAgICB9XG4gICAgc2V0KEEsIEIsIEMsIEQsIEUpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMV9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspXG4gICAgICAgICAgICBTSEExX1dbaV0gPSByb3RsKFNIQTFfV1tpIC0gM10gXiBTSEExX1dbaSAtIDhdIF4gU0hBMV9XW2kgLSAxNF0gXiBTSEExX1dbaSAtIDE2XSwgMSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIEs7XG4gICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgICAgICAgICAgRiA9IENoaShCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg1YTgyNzk5OTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCA0MCkge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4NmVkOWViYTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNjApIHtcbiAgICAgICAgICAgICAgICBGID0gTWFqKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIEsgPSAweDhmMWJiY2RjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBLID0gMHhjYTYyYzFkNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFQgPSAocm90bChBLCA1KSArIEYgKyBFICsgSyArIFNIQTFfV1tpXSkgfCAwO1xuICAgICAgICAgICAgRSA9IEQ7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSByb3RsKEIsIDMwKTtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IFQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBMV9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59XG4vKiogU0hBMSAoUkZDIDMxNzQpIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLiBJdCB3YXMgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuLiAqL1xuZXhwb3J0IGNvbnN0IHNoYTEgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEExKCkpO1xuLyoqIFBlci1yb3VuZCBjb25zdGFudHMgKi9cbmNvbnN0IHAzMiA9IC8qIEBfX1BVUkVfXyAqLyBNYXRoLnBvdygyLCAzMik7XG5jb25zdCBLID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDY0IH0sIChfLCBpKSA9PiBNYXRoLmZsb29yKHAzMiAqIE1hdGguYWJzKE1hdGguc2luKGkgKyAxKSkpKTtcbi8qKiBtZDUgaW5pdGlhbCBzdGF0ZTogc2FtZSBhcyBzaGExLCBidXQgNCB1MzIgaW5zdGVhZCBvZiA1LiAqL1xuY29uc3QgTUQ1X0lWID0gLyogQF9fUFVSRV9fICovIFNIQTFfSVYuc2xpY2UoMCwgNCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBNRDVfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuLyoqIE1ENSBsZWdhY3kgaGFzaCBjbGFzcy4gKi9cbmV4cG9ydCBjbGFzcyBNRDUgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMTYsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLkEgPSBNRDVfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBNRDVfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBNRDVfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBNRDVfSVZbM10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBEXTtcbiAgICB9XG4gICAgc2V0KEEsIEIsIEMsIEQpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBNRDVfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIGcsIHM7XG4gICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgRiA9IENoaShCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBnID0gaTtcbiAgICAgICAgICAgICAgICBzID0gWzcsIDEyLCAxNywgMjJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgRiA9IENoaShELCBCLCBDKTtcbiAgICAgICAgICAgICAgICBnID0gKDUgKiBpICsgMSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzUsIDksIDE0LCAyMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgICAgICAgICBGID0gQiBeIEMgXiBEO1xuICAgICAgICAgICAgICAgIGcgPSAoMyAqIGkgKyA1KSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNCwgMTEsIDE2LCAyM107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBGID0gQyBeIChCIHwgfkQpO1xuICAgICAgICAgICAgICAgIGcgPSAoNyAqIGkpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs2LCAxMCwgMTUsIDIxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEYgPSBGICsgQSArIEtbaV0gKyBNRDVfV1tnXTtcbiAgICAgICAgICAgIEEgPSBEO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBCICsgcm90bChGLCBzW2kgJSA0XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBjbGVhbihNRDVfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDApO1xuICAgICAgICBjbGVhbih0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuLyoqXG4gKiBNRDUgKFJGQyAxMzIxKSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi5cbiAqIE1ENSBhcmNoaXRlY3R1cmUgaXMgc2ltaWxhciB0byBTSEExLCB3aXRoIHNvbWUgZGlmZmVyZW5jZXM6XG4gKiAtIFJlZHVjZWQgb3V0cHV0IGxlbmd0aDogMTYgYnl0ZXMgKDEyOCBiaXQpIGluc3RlYWQgb2YgMjBcbiAqIC0gNjQgcm91bmRzLCBpbnN0ZWFkIG9mIDgwXG4gKiAtIExpdHRsZS1lbmRpYW46IGNvdWxkIGJlIGZhc3RlciwgYnV0IHdpbGwgcmVxdWlyZSBtb3JlIGNvZGVcbiAqIC0gTm9uLWxpbmVhciBpbmRleCBzZWxlY3Rpb246IGh1Z2Ugc3BlZWQtdXAgZm9yIHVucm9sbFxuICogLSBQZXIgcm91bmQgY29uc3RhbnRzOiBtb3JlIG1lbW9yeSBhY2Nlc3NlcywgYWRkaXRpb25hbCBzcGVlZC11cCBmb3IgdW5yb2xsXG4gKi9cbmV4cG9ydCBjb25zdCBtZDUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBNRDUoKSk7XG4vLyBSSVBFTUQtMTYwXG5jb25zdCBSaG8xNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDhBcnJheS5mcm9tKFtcbiAgICA3LCA0LCAxMywgMSwgMTAsIDYsIDE1LCAzLCAxMiwgMCwgOSwgNSwgMiwgMTQsIDExLCA4LFxuXSk7XG5jb25zdCBJZDE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gVWludDhBcnJheS5mcm9tKG5ldyBBcnJheSgxNikuZmlsbCgwKS5tYXAoKF8sIGkpID0+IGkpKSkoKTtcbmNvbnN0IFBpMTYwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBJZDE2MC5tYXAoKGkpID0+ICg5ICogaSArIDUpICUgMTYpKSgpO1xuY29uc3QgaWR4TFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBMID0gW0lkMTYwXTtcbiAgICBjb25zdCBSID0gW1BpMTYwXTtcbiAgICBjb25zdCByZXMgPSBbTCwgUl07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspXG4gICAgICAgIGZvciAobGV0IGogb2YgcmVzKVxuICAgICAgICAgICAgai5wdXNoKGpbaV0ubWFwKChrKSA9PiBSaG8xNjBba10pKTtcbiAgICByZXR1cm4gcmVzO1xufSkoKTtcbmNvbnN0IGlkeEwgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzBdKSgpO1xuY29uc3QgaWR4UiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaWR4TFJbMV0pKCk7XG4vLyBjb25zdCBbaWR4TCwgaWR4Ul0gPSBpZHhMUjtcbmNvbnN0IHNoaWZ0czE2MCA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gICAgWzExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOF0sXG4gICAgWzEyLCAxMywgMTEsIDE1LCA2LCA5LCA5LCA3LCAxMiwgMTUsIDExLCAxMywgNywgOCwgNywgN10sXG4gICAgWzEzLCAxNSwgMTQsIDExLCA3LCA3LCA2LCA4LCAxMywgMTQsIDEzLCAxMiwgNSwgNSwgNiwgOV0sXG4gICAgWzE0LCAxMSwgMTIsIDE0LCA4LCA2LCA1LCA1LCAxNSwgMTIsIDE1LCAxNCwgOSwgOSwgOCwgNl0sXG4gICAgWzE1LCAxMiwgMTMsIDEzLCA5LCA1LCA4LCA2LCAxNCwgMTEsIDEyLCAxMSwgOCwgNiwgNSwgNV0sXG5dLm1hcCgoaSkgPT4gVWludDhBcnJheS5mcm9tKGkpKTtcbmNvbnN0IHNoaWZ0c0wxNjAgPSAvKiBAX19QVVJFX18gKi8gaWR4TC5tYXAoKGlkeCwgaSkgPT4gaWR4Lm1hcCgoaikgPT4gc2hpZnRzMTYwW2ldW2pdKSk7XG5jb25zdCBzaGlmdHNSMTYwID0gLyogQF9fUFVSRV9fICovIGlkeFIubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3QgS2wxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHgwMDAwMDAwMCwgMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhhOTUzZmQ0ZSxcbl0pO1xuY29uc3QgS3IxNjAgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg1MGEyOGJlNiwgMHg1YzRkZDEyNCwgMHg2ZDcwM2VmMywgMHg3YTZkNzZlOSwgMHgwMDAwMDAwMCxcbl0pO1xuLy8gSXQncyBjYWxsZWQgZigpIGluIHNwZWMuXG5mdW5jdGlvbiByaXBlbWRfZihncm91cCwgeCwgeSwgeikge1xuICAgIGlmIChncm91cCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDEpXG4gICAgICAgIHJldHVybiAoeCAmIHkpIHwgKH54ICYgeik7XG4gICAgaWYgKGdyb3VwID09PSAyKVxuICAgICAgICByZXR1cm4gKHggfCB+eSkgXiB6O1xuICAgIGlmIChncm91cCA9PT0gMylcbiAgICAgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmIH56KTtcbiAgICByZXR1cm4geCBeICh5IHwgfnopO1xufVxuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgQlVGXzE2MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoMTYpO1xuZXhwb3J0IGNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRl8xNjBbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2wxNjBbZ3JvdXBdLCBoYnIgPSBLcjE2MFtncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0wxNjBbZ3JvdXBdLCBzciA9IHNoaWZ0c1IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKHJvdGwoYWwgKyByaXBlbWRfZihncm91cCwgYmwsIGNsLCBkbCkgKyBCVUZfMTYwW3JsW2ldXSArIGhibCwgc2xbaV0pICsgZWwpIHwgMDtcbiAgICAgICAgICAgICAgICBhbCA9IGVsLCBlbCA9IGRsLCBkbCA9IHJvdGwoY2wsIDEwKSB8IDAsIGNsID0gYmwsIGJsID0gdGw7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gMiBsb29wcyBhcmUgMTAlIGZhc3RlclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHIgPSAocm90bChhciArIHJpcGVtZF9mKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZfMTYwW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9IHJvdGwoY3IsIDEwKSB8IDAsIGNyID0gYnIsIGJyID0gdHI7IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIHRoaXMuc2V0KCh0aGlzLmgxICsgY2wgKyBkcikgfCAwLCAodGhpcy5oMiArIGRsICsgZXIpIHwgMCwgKHRoaXMuaDMgKyBlbCArIGFyKSB8IDAsICh0aGlzLmg0ICsgYWwgKyBicikgfCAwLCAodGhpcy5oMCArIGJsICsgY3IpIHwgMCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKEJVRl8xNjApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuLyoqXG4gKiBSSVBFTUQtMTYwIC0gYSBsZWdhY3kgaGFzaCBmdW5jdGlvbiBmcm9tIDE5OTBzLlxuICogKiBodHRwczovL2hvbWVzLmVzYXQua3VsZXV2ZW4uYmUvfmJvc3NlbGFlL3JpcGVtZDE2MC5odG1sXG4gKiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG4gKi9cbmV4cG9ydCBjb25zdCByaXBlbWQxNjAgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3kuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RIPEMD160: () => (/* binding */ RIPEMD160),\n/* harmony export */   ripemd160: () => (/* binding */ ripemd160)\n/* harmony export */ });\n/* harmony import */ var _legacy_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./legacy.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/legacy.js\");\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst RIPEMD160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nconst ripemd160 = _legacy_js__WEBPACK_IMPORTED_MODULE_0__.ripemd160;\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9yaXBlbWQxNjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDK0U7QUFDL0U7QUFDTyxrQkFBa0IsaURBQVU7QUFDbkM7QUFDTyxrQkFBa0IsaURBQVU7QUFDbkMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxccmlwZW1kMTYwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogUklQRU1ELTE2MCBsZWdhY3kgaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG4gKiBAbW9kdWxlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5pbXBvcnQgeyBSSVBFTUQxNjAgYXMgUklQRU1EMTYwbiwgcmlwZW1kMTYwIGFzIHJpcGVtZDE2MG4gfSBmcm9tIFwiLi9sZWdhY3kuanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9sZWdhY3lgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFJJUEVNRDE2MCA9IFJJUEVNRDE2MG47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCByaXBlbWQxNjAgPSByaXBlbWQxNjBuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js":
/*!********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   SHA384: () => (/* binding */ SHA384),\n/* harmony export */   SHA512: () => (/* binding */ SHA512),\n/* harmony export */   SHA512_224: () => (/* binding */ SHA512_224),\n/* harmony export */   SHA512_256: () => (/* binding */ SHA512_256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256),\n/* harmony export */   sha384: () => (/* binding */ sha384),\n/* harmony export */   sha512: () => (/* binding */ sha512),\n/* harmony export */   sha512_224: () => (/* binding */ sha512_224),\n/* harmony export */   sha512_256: () => (/* binding */ sha512_256)\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\n\n\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n    }\n}\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[0] | 0;\n        this.B = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[1] | 0;\n        this.C = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[2] | 0;\n        this.D = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[3] | 0;\n        this.E = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[4] | 0;\n        this.F = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[5] | 0;\n        this.G = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[6] | 0;\n        this.H = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA224_IV[7] | 0;\n    }\n}\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_2__.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_2__.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_2__.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[0] | 0;\n        this.Al = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[1] | 0;\n        this.Bh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[2] | 0;\n        this.Bl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[3] | 0;\n        this.Ch = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[4] | 0;\n        this.Cl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[5] | 0;\n        this.Dh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[6] | 0;\n        this.Dl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[7] | 0;\n        this.Eh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[8] | 0;\n        this.El = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[9] | 0;\n        this.Fh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[10] | 0;\n        this.Fl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[11] | 0;\n        this.Gh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[12] | 0;\n        this.Gl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[13] | 0;\n        this.Hh = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[14] | 0;\n        this.Hl = _md_js__WEBPACK_IMPORTED_MODULE_0__.SHA384_IV[15] | 0;\n    }\n}\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3dGO0FBQ3ZEO0FBQ3NCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCLGlCQUFpQiw2Q0FBUztBQUMxQixpQkFBaUIsNkNBQVM7QUFDMUIsaUJBQWlCLDZDQUFTO0FBQzFCO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQscUNBQXFDLDJDQUFHO0FBQ3hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQsaUNBQWlDLDJDQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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WTtBQUNsRDtBQUNPLCtCQUErQix1REFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1DQUFtQyx1REFBWTtBQUN0RCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcZXNtXFxzaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMiBoYXNoIGZ1bmN0aW9uLiBBLmsuYS4gc2hhMjU2LCBzaGEzODQsIHNoYTUxMiwgc2hhNTEyXzIyNCwgc2hhNTEyXzI1Ni5cbiAqIFNIQTI1NiBpcyB0aGUgZmFzdGVzdCBoYXNoIGltcGxlbWVudGFibGUgaW4gSlMsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogQ2hlY2sgb3V0IFtSRkMgNDYzNF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjM0KSBhbmRcbiAqIFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgQ2hpLCBIYXNoTUQsIE1haiwgU0hBMjI0X0lWLCBTSEEyNTZfSVYsIFNIQTM4NF9JViwgU0hBNTEyX0lWIH0gZnJvbSBcIi4vX21kLmpzXCI7XG5pbXBvcnQgKiBhcyB1NjQgZnJvbSBcIi4vX3U2NC5qc1wiO1xuaW1wb3J0IHsgY2xlYW4sIGNyZWF0ZUhhc2hlciwgcm90ciB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vKipcbiAqIFJvdW5kIGNvbnN0YW50czpcbiAqIEZpcnN0IDMyIGJpdHMgb2YgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLyoqIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXIuIFwiV1wiIGNvbWVzIHN0cmFpZ2h0IGZyb20gc3BlYy4gKi9cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5leHBvcnQgY2xhc3MgU0hBMjU2IGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSAzMikge1xuICAgICAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm90cihXMTUsIDcpIF4gcm90cihXMTUsIDE4KSBeIChXMTUgPj4+IDMpO1xuICAgICAgICAgICAgY29uc3QgczEgPSByb3RyKFcyLCAxNykgXiByb3RyKFcyLCAxOSkgXiAoVzIgPj4+IDEwKTtcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gKHMxICsgU0hBMjU2X1dbaSAtIDddICsgczAgKyBTSEEyNTZfV1tpIC0gMTZdKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA2NCByb3VuZHNcbiAgICAgICAgbGV0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTEgPSByb3RyKEUsIDYpIF4gcm90cihFLCAxMSkgXiByb3RyKEUsIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSByb3RyKEEsIDIpIF4gcm90cihBLCAxMykgXiByb3RyKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArIE1haihBLCBCLCBDKSkgfCAwO1xuICAgICAgICAgICAgSCA9IEc7XG4gICAgICAgICAgICBHID0gRjtcbiAgICAgICAgICAgIEYgPSBFO1xuICAgICAgICAgICAgRSA9IChEICsgVDEpIHwgMDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQTtcbiAgICAgICAgICAgIEEgPSAoVDEgKyBUMikgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgIEEgPSAoQSArIHRoaXMuQSkgfCAwO1xuICAgICAgICBCID0gKEIgKyB0aGlzLkIpIHwgMDtcbiAgICAgICAgQyA9IChDICsgdGhpcy5DKSB8IDA7XG4gICAgICAgIEQgPSAoRCArIHRoaXMuRCkgfCAwO1xuICAgICAgICBFID0gKEUgKyB0aGlzLkUpIHwgMDtcbiAgICAgICAgRiA9IChGICsgdGhpcy5GKSB8IDA7XG4gICAgICAgIEcgPSAoRyArIHRoaXMuRykgfCAwO1xuICAgICAgICBIID0gKEggKyB0aGlzLkgpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIGNsZWFuKFNIQTI1Nl9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkEgPSBTSEEyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyMjRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyMjRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyMjRfSVZbN10gfCAwO1xuICAgIH1cbn1cbi8vIFNIQTItNTEyIGlzIHNsb3dlciB0aGFuIHNoYTI1NiBpbiBqcyBiZWNhdXNlIHU2NCBvcGVyYXRpb25zIGFyZSBzbG93LlxuLy8gUm91bmQgY29udGFudHNcbi8vIEZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgSzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdTY0LnNwbGl0KFtcbiAgICAnMHg0MjhhMmY5OGQ3MjhhZTIyJywgJzB4NzEzNzQ0OTEyM2VmNjVjZCcsICcweGI1YzBmYmNmZWM0ZDNiMmYnLCAnMHhlOWI1ZGJhNTgxODlkYmJjJyxcbiAgICAnMHgzOTU2YzI1YmYzNDhiNTM4JywgJzB4NTlmMTExZjFiNjA1ZDAxOScsICcweDkyM2Y4MmE0YWYxOTRmOWInLCAnMHhhYjFjNWVkNWRhNmQ4MTE4JyxcbiAgICAnMHhkODA3YWE5OGEzMDMwMjQyJywgJzB4MTI4MzViMDE0NTcwNmZiZScsICcweDI0MzE4NWJlNGVlNGIyOGMnLCAnMHg1NTBjN2RjM2Q1ZmZiNGUyJyxcbiAgICAnMHg3MmJlNWQ3NGYyN2I4OTZmJywgJzB4ODBkZWIxZmUzYjE2OTZiMScsICcweDliZGMwNmE3MjVjNzEyMzUnLCAnMHhjMTliZjE3NGNmNjkyNjk0JyxcbiAgICAnMHhlNDliNjljMTllZjE0YWQyJywgJzB4ZWZiZTQ3ODYzODRmMjVlMycsICcweDBmYzE5ZGM2OGI4Y2Q1YjUnLCAnMHgyNDBjYTFjYzc3YWM5YzY1JyxcbiAgICAnMHgyZGU5MmM2ZjU5MmIwMjc1JywgJzB4NGE3NDg0YWE2ZWE2ZTQ4MycsICcweDVjYjBhOWRjYmQ0MWZiZDQnLCAnMHg3NmY5ODhkYTgzMTE1M2I1JyxcbiAgICAnMHg5ODNlNTE1MmVlNjZkZmFiJywgJzB4YTgzMWM2NmQyZGI0MzIxMCcsICcweGIwMDMyN2M4OThmYjIxM2YnLCAnMHhiZjU5N2ZjN2JlZWYwZWU0JyxcbiAgICAnMHhjNmUwMGJmMzNkYTg4ZmMyJywgJzB4ZDVhNzkxNDc5MzBhYTcyNScsICcweDA2Y2E2MzUxZTAwMzgyNmYnLCAnMHgxNDI5Mjk2NzBhMGU2ZTcwJyxcbiAgICAnMHgyN2I3MGE4NTQ2ZDIyZmZjJywgJzB4MmUxYjIxMzg1YzI2YzkyNicsICcweDRkMmM2ZGZjNWFjNDJhZWQnLCAnMHg1MzM4MGQxMzlkOTViM2RmJyxcbiAgICAnMHg2NTBhNzM1NDhiYWY2M2RlJywgJzB4NzY2YTBhYmIzYzc3YjJhOCcsICcweDgxYzJjOTJlNDdlZGFlZTYnLCAnMHg5MjcyMmM4NTE0ODIzNTNiJyxcbiAgICAnMHhhMmJmZThhMTRjZjEwMzY0JywgJzB4YTgxYTY2NGJiYzQyMzAwMScsICcweGMyNGI4YjcwZDBmODk3OTEnLCAnMHhjNzZjNTFhMzA2NTRiZTMwJyxcbiAgICAnMHhkMTkyZTgxOWQ2ZWY1MjE4JywgJzB4ZDY5OTA2MjQ1NTY1YTkxMCcsICcweGY0MGUzNTg1NTc3MTIwMmEnLCAnMHgxMDZhYTA3MDMyYmJkMWI4JyxcbiAgICAnMHgxOWE0YzExNmI4ZDJkMGM4JywgJzB4MWUzNzZjMDg1MTQxYWI1MycsICcweDI3NDg3NzRjZGY4ZWViOTknLCAnMHgzNGIwYmNiNWUxOWI0OGE4JyxcbiAgICAnMHgzOTFjMGNiM2M1Yzk1YTYzJywgJzB4NGVkOGFhNGFlMzQxOGFjYicsICcweDViOWNjYTRmNzc2M2UzNzMnLCAnMHg2ODJlNmZmM2Q2YjJiOGEzJyxcbiAgICAnMHg3NDhmODJlZTVkZWZiMmZjJywgJzB4NzhhNTYzNmY0MzE3MmY2MCcsICcweDg0Yzg3ODE0YTFmMGFiNzInLCAnMHg4Y2M3MDIwODFhNjQzOWVjJyxcbiAgICAnMHg5MGJlZmZmYTIzNjMxZTI4JywgJzB4YTQ1MDZjZWJkZTgyYmRlOScsICcweGJlZjlhM2Y3YjJjNjc5MTUnLCAnMHhjNjcxNzhmMmUzNzI1MzJiJyxcbiAgICAnMHhjYTI3M2VjZWVhMjY2MTljJywgJzB4ZDE4NmI4YzcyMWMwYzIwNycsICcweGVhZGE3ZGQ2Y2RlMGViMWUnLCAnMHhmNTdkNGY3ZmVlNmVkMTc4JyxcbiAgICAnMHgwNmYwNjdhYTcyMTc2ZmJhJywgJzB4MGE2MzdkYzVhMmM4OThhNicsICcweDExM2Y5ODA0YmVmOTBkYWUnLCAnMHgxYjcxMGIzNTEzMWM0NzFiJyxcbiAgICAnMHgyOGRiNzdmNTIzMDQ3ZDg0JywgJzB4MzJjYWFiN2I0MGM3MjQ5MycsICcweDNjOWViZTBhMTVjOWJlYmMnLCAnMHg0MzFkNjdjNDljMTAwZDRjJyxcbiAgICAnMHg0Y2M1ZDRiZWNiM2U0MmI2JywgJzB4NTk3ZjI5OWNmYzY1N2UyYScsICcweDVmY2I2ZmFiM2FkNmZhZWMnLCAnMHg2YzQ0MTk4YzRhNDc1ODE3J1xuXS5tYXAobiA9PiBCaWdJbnQobikpKSkoKTtcbmNvbnN0IFNIQTUxMl9LaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlswXSkoKTtcbmNvbnN0IFNIQTUxMl9LbCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSzUxMlsxXSkoKTtcbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJzXG5jb25zdCBTSEE1MTJfV19IID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jb25zdCBTSEE1MTJfV19MID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5leHBvcnQgY2xhc3MgU0hBNTEyIGV4dGVuZHMgSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSA2NCkge1xuICAgICAgICBzdXBlcigxMjgsIG91dHB1dExlbiwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSBTSEE1MTJfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gU0hBNTEyX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFNIQTUxMl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBTSEE1MTJfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gU0hBNTEyX0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFNIQTUxMl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBTSEE1MTJfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gU0hBNTEyX0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFNIQTUxMl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBTSEE1MTJfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gU0hBNTEyX0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBTSEE1MTJfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFNIQTUxMl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gU0hBNTEyX0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBTSEE1MTJfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFNIQTUxMl9JVlsxNV0gfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgY2xlYW4oU0hBNTEyX1dfSCwgU0hBNTEyX1dfTCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFuKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDQ4KTtcbiAgICAgICAgdGhpcy5BaCA9IFNIQTM4NF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBTSEEzODRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gU0hBMzg0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFNIQTM4NF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBTSEEzODRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gU0hBMzg0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFNIQTM4NF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBTSEEzODRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gU0hBMzg0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFNIQTM4NF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBTSEEzODRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFNIQTM4NF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gU0hBMzg0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBTSEEzODRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFNIQTM4NF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gU0hBMzg0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuLyoqXG4gKiBUcnVuY2F0ZWQgU0hBNTEyLzI1NiBhbmQgU0hBNTEyLzIyNC5cbiAqIFNIQTUxMl9JViBpcyBYT1JlZCB3aXRoIDB4YTVhNWE1YTVhNWE1YTVhNSwgdGhlbiB1c2VkIGFzIFwiaW50ZXJtZWRpYXJ5XCIgSVYgb2YgU0hBNTEyL3QuXG4gKiBUaGVuIHQgaGFzaGVzIHN0cmluZyB0byBwcm9kdWNlIHJlc3VsdCBJVi5cbiAqIFNlZSBgdGVzdC9taXNjL3NoYTItZ2VuLWl2LmpzYC5cbiAqL1xuLyoqIFNIQTUxMi8yMjQgSVYgKi9cbmNvbnN0IFQyMjRfSVYgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg4YzNkMzdjOCwgMHgxOTU0NGRhMiwgMHg3M2UxOTk2NiwgMHg4OWRjZDRkNiwgMHgxZGZhYjdhZSwgMHgzMmZmOWM4MiwgMHg2NzlkZDUxNCwgMHg1ODJmOWZjZixcbiAgICAweDBmNmQyYjY5LCAweDdiZDQ0ZGE4LCAweDc3ZTM2ZjczLCAweDA0YzQ4OTQyLCAweDNmOWQ4NWE4LCAweDZhMWQzNmM4LCAweDExMTJlNmFkLCAweDkxZDY5MmExLFxuXSk7XG4vKiogU0hBNTEyLzI1NiBJViAqL1xuY29uc3QgVDI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDIyMzEyMTk0LCAweGZjMmJmNzJjLCAweDlmNTU1ZmEzLCAweGM4NGM2NGMyLCAweDIzOTNiODZiLCAweDZmNTNiMTUxLCAweDk2Mzg3NzE5LCAweDU5NDBlYWJkLFxuICAgIDB4OTYyODNlZTIsIDB4YTg4ZWZmZTMsIDB4YmU1ZTFlMjUsIDB4NTM4NjM5OTIsIDB4MmIwMTk5ZmMsIDB4MmM4NWI4YWEsIDB4MGViNzJkZGMsIDB4ODFjNTJjYTIsXG5dKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMjgpO1xuICAgICAgICB0aGlzLkFoID0gVDIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjI0X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyMjRfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjI0X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyMjRfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjI0X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyMjRfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDIyNF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjI0X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjI0X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjI0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjI0X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjI0X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjI0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigzMik7XG4gICAgICAgIHRoaXMuQWggPSBUMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IFQyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gVDI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBUMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IFQyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gVDI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBUMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IFQyNTZfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gVDI1Nl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBUMjU2X0lWWzldIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IFQyNTZfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IFQyNTZfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IFQyNTZfSVZbMTJdIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IFQyNTZfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IFQyNTZfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IFQyNTZfSVZbMTVdIHwgMDtcbiAgICB9XG59XG4vKipcbiAqIFNIQTItMjU2IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC5cbiAqXG4gKiBJdCBpcyB0aGUgZmFzdGVzdCBKUyBoYXNoLCBldmVuIGZhc3RlciB0aGFuIEJsYWtlMy5cbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICovXG5leHBvcnQgY29uc3Qgc2hhMjU2ID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuLyoqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNCAqL1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTIyNCgpKTtcbi8qKiBTSEEyLTUxMiBoYXNoIGZ1bmN0aW9uIGZyb20gUkZDIDQ2MzQuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUhhc2hlcigoKSA9PiBuZXcgU0hBNTEyKCkpO1xuLyoqIFNIQTItMzg0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNC4gKi9cbmV4cG9ydCBjb25zdCBzaGEzODQgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vKipcbiAqIFNIQTItNTEyLzI1NiBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG4vKipcbiAqIFNIQTItNTEyLzIyNCBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVIYXNoZXIoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA224: () => (/* binding */ SHA224),\n/* harmony export */   SHA256: () => (/* binding */ SHA256),\n/* harmony export */   sha224: () => (/* binding */ sha224),\n/* harmony export */   sha256: () => (/* binding */ sha256)\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha2.js\");\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\n\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha256 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst SHA224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nconst sha224 = _sha2_js__WEBPACK_IMPORTED_MODULE_0__.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN3RztBQUN4RztBQUNPLGVBQWUsNENBQU87QUFDN0I7QUFDTyxlQUFlLDRDQUFPO0FBQzdCO0FBQ08sZUFBZSw0Q0FBTztBQUM3QjtBQUNPLGVBQWUsNENBQU87QUFDN0IiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGVzbVxcc2hhMjU2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU0hBMi0yNTYgYS5rLmEuIHNoYTI1Ni4gSW4gSlMsIGl0IGlzIHRoZSBmYXN0ZXN0IGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICpcbiAqIFRvIGJyZWFrIHNoYTI1NiB1c2luZyBiaXJ0aGRheSBhdHRhY2ssIGF0dGFja2VycyBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMuXG4gKiBCVEMgbmV0d29yayBpcyBkb2luZyAyXjcwIGhhc2hlcy9zZWMgKDJeOTUgaGFzaGVzL3llYXIpIGFzIHBlciAyMDI1LlxuICpcbiAqIENoZWNrIG91dCBbRklQUyAxODAtNF0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZikuXG4gKiBAbW9kdWxlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5pbXBvcnQgeyBTSEEyMjQgYXMgU0hBMjI0biwgc2hhMjI0IGFzIHNoYTIyNG4sIFNIQTI1NiBhcyBTSEEyNTZuLCBzaGEyNTYgYXMgc2hhMjU2biwgfSBmcm9tIFwiLi9zaGEyLmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3QgU0hBMjU2ID0gU0hBMjU2bjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9zaGEyYCBtb2R1bGUgKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSBzaGEyNTZuO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBpbXBvcnQgZnJvbSBgbm9ibGUvaGFzaGVzL3NoYTJgIG1vZHVsZSAqL1xuZXhwb3J0IGNvbnN0IFNIQTIyNCA9IFNIQTIyNG47XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gc2hhMjI0bjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTI1Ni5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha256.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js":
/*!********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: () => (/* binding */ Keccak),\n/* harmony export */   keccakP: () => (/* binding */ keccakP),\n/* harmony export */   keccak_224: () => (/* binding */ keccak_224),\n/* harmony export */   keccak_256: () => (/* binding */ keccak_256),\n/* harmony export */   keccak_384: () => (/* binding */ keccak_384),\n/* harmony export */   keccak_512: () => (/* binding */ keccak_512),\n/* harmony export */   sha3_224: () => (/* binding */ sha3_224),\n/* harmony export */   sha3_256: () => (/* binding */ sha3_256),\n/* harmony export */   sha3_384: () => (/* binding */ sha3_384),\n/* harmony export */   sha3_512: () => (/* binding */ sha3_512),\n/* harmony export */   shake128: () => (/* binding */ shake128),\n/* harmony export */   shake256: () => (/* binding */ shake256)\n/* harmony export */ });\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\n\n// prettier-ignore\n\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(B);\n}\n/** Keccak sponge function. */\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this, false);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createHasher)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nconst sha3_224 = /* @__PURE__ */ (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nconst sha3_256 = /* @__PURE__ */ (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nconst sha3_384 = /* @__PURE__ */ (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nconst sha3_512 = /* @__PURE__ */ (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nconst keccak_224 = /* @__PURE__ */ (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nconst keccak_256 = /* @__PURE__ */ (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nconst keccak_384 = /* @__PURE__ */ (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nconst keccak_512 = /* @__PURE__ */ (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nconst shake128 = /* @__PURE__ */ (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nconst shake256 = /* @__PURE__ */ (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRTtBQUNsRTtBQUNpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0QscUNBQXFDLCtDQUFNLFlBQVksK0NBQU07QUFDN0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnREFBSztBQUNUO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFVO0FBQ2xCO0FBQ0EsUUFBUSxxREFBVTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixlQUFlLGtEQUFPO0FBQ3RCLFFBQVEsaURBQU07QUFDZCxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZixRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsdURBQVk7QUFDekQ7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUCxrREFBa0Qsc0RBQVcsV0FBVztBQUN4RTtBQUNPO0FBQ1A7QUFDTztBQUNQIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHNoYTMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTSEEzIChrZWNjYWspIGhhc2ggZnVuY3Rpb24sIGJhc2VkIG9uIGEgbmV3IFwiU3BvbmdlIGZ1bmN0aW9uXCIgZGVzaWduLlxuICogRGlmZmVyZW50IGZyb20gb2xkZXIgaGFzaGVzLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTLTIwMl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjIwMi5wZGYpLFxuICogW1dlYnNpdGVdKGh0dHBzOi8va2VjY2FrLnRlYW0va2VjY2FrLmh0bWwpLFxuICogW3RoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIFNIQS0zIGFuZCBLZWNjYWtdKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNTcyNy93aGF0LWFyZS10aGUta2V5LWRpZmZlcmVuY2VzLWJldHdlZW4tdGhlLWRyYWZ0LXNoYS0zLXN0YW5kYXJkLWFuZC10aGUta2VjY2FrLXN1YikuXG4gKlxuICogQ2hlY2sgb3V0IGBzaGEzLWFkZG9uc2AgbW9kdWxlIGZvciBjU0hBS0UsIGsxMiwgYW5kIG90aGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gXCIuL191NjQuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuaW1wb3J0IHsgYWJ5dGVzLCBhZXhpc3RzLCBhbnVtYmVyLCBhb3V0cHV0LCBjbGVhbiwgY3JlYXRlSGFzaGVyLCBjcmVhdGVYT0ZlciwgSGFzaCwgc3dhcDMySWZCRSwgdG9CeXRlcywgdTMyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIE5vIF9fUFVSRV9fIGFubm90YXRpb25zIGluIHNoYTMgaGVhZGVyOlxuLy8gRVZFUllUSElORyBpcyBpbiBmYWN0IHVzZWQgb24gZXZlcnkgZXhwb3J0LlxuLy8gVmFyaW91cyBwZXIgcm91bmQgY29uc3RhbnRzIGNhbGN1bGF0aW9uc1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgXzduID0gQmlnSW50KDcpO1xuY29uc3QgXzI1Nm4gPSBCaWdJbnQoMjU2KTtcbmNvbnN0IF8weDcxbiA9IEJpZ0ludCgweDcxKTtcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuZm9yIChsZXQgcm91bmQgPSAwLCBSID0gXzFuLCB4ID0gMSwgeSA9IDA7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAvLyBQaVxuICAgIFt4LCB5XSA9IFt5LCAoMiAqIHggKyAzICogeSkgJSA1XTtcbiAgICBTSEEzX1BJLnB1c2goMiAqICg1ICogeSArIHgpKTtcbiAgICAvLyBSb3RhdGlvbmFsXG4gICAgU0hBM19ST1RMLnB1c2goKCgocm91bmQgKyAxKSAqIChyb3VuZCArIDIpKSAvIDIpICUgNjQpO1xuICAgIC8vIElvdGFcbiAgICBsZXQgdCA9IF8wbjtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDc7IGorKykge1xuICAgICAgICBSID0gKChSIDw8IF8xbikgXiAoKFIgPj4gXzduKSAqIF8weDcxbikpICUgXzI1Nm47XG4gICAgICAgIGlmIChSICYgXzJuKVxuICAgICAgICAgICAgdCBePSBfMW4gPDwgKChfMW4gPDwgLyogQF9fUFVSRV9fICovIEJpZ0ludChqKSkgLSBfMW4pO1xuICAgIH1cbiAgICBfU0hBM19JT1RBLnB1c2godCk7XG59XG5jb25zdCBJT1RBUyA9IHNwbGl0KF9TSEEzX0lPVEEsIHRydWUpO1xuY29uc3QgU0hBM19JT1RBX0ggPSBJT1RBU1swXTtcbmNvbnN0IFNIQTNfSU9UQV9MID0gSU9UQVNbMV07XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vKiogYGtlY2Nha2YxNjAwYCBpbnRlcm5hbCBmdW5jdGlvbiwgYWRkaXRpb25hbGx5IGFsbG93cyB0byBhZGp1c3Qgcm91bmQgY291bnQuICovXG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrUChzLCByb3VuZHMgPSAyNCkge1xuICAgIGNvbnN0IEIgPSBuZXcgVWludDMyQXJyYXkoNSAqIDIpO1xuICAgIC8vIE5PVEU6IGFsbCBpbmRpY2VzIGFyZSB4MiBzaW5jZSB3ZSBzdG9yZSBzdGF0ZSBhcyB1MzIgaW5zdGVhZCBvZiB1NjQgKGJpZ2ludHMgdG8gc2xvdyBpbiBqcylcbiAgICBmb3IgKGxldCByb3VuZCA9IDI0IC0gcm91bmRzOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgICAgIC8vIFRoZXRhIM64XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgIEJbeF0gPSBzW3hdIF4gc1t4ICsgMTBdIF4gc1t4ICsgMjBdIF4gc1t4ICsgMzBdIF4gc1t4ICsgNDBdO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4ICs9IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeDEgPSAoeCArIDgpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBpZHgwID0gKHggKyAyKSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgQjAgPSBCW2lkeDBdO1xuICAgICAgICAgICAgY29uc3QgQjEgPSBCW2lkeDAgKyAxXTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoQjAsIEIxLCAxKSBeIEJbaWR4MV07XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKEIwLCBCMSwgMSkgXiBCW2lkeDEgKyAxXTtcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgICAgICBzW3ggKyB5XSBePSBUaDtcbiAgICAgICAgICAgICAgICBzW3ggKyB5ICsgMV0gXj0gVGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmhvICjPgSkgYW5kIFBpICjPgClcbiAgICAgICAgbGV0IGN1ckggPSBzWzJdO1xuICAgICAgICBsZXQgY3VyTCA9IHNbM107XG4gICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgMjQ7IHQrKykge1xuICAgICAgICAgICAgY29uc3Qgc2hpZnQgPSBTSEEzX1JPVExbdF07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgUEkgPSBTSEEzX1BJW3RdO1xuICAgICAgICAgICAgY3VySCA9IHNbUEldO1xuICAgICAgICAgICAgY3VyTCA9IHNbUEkgKyAxXTtcbiAgICAgICAgICAgIHNbUEldID0gVGg7XG4gICAgICAgICAgICBzW1BJICsgMV0gPSBUbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGkgKM+HKVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgQlt4XSA9IHNbeSArIHhdO1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIHNbeSArIHhdIF49IH5CWyh4ICsgMikgJSAxMF0gJiBCWyh4ICsgNCkgJSAxMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW90YSAozrkpXG4gICAgICAgIHNbMF0gXj0gU0hBM19JT1RBX0hbcm91bmRdO1xuICAgICAgICBzWzFdIF49IFNIQTNfSU9UQV9MW3JvdW5kXTtcbiAgICB9XG4gICAgY2xlYW4oQik7XG59XG4vKiogS2VjY2FrIHNwb25nZSBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjbGFzcyBLZWNjYWsgZXh0ZW5kcyBIYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgIGFudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICAvLyAwIDwgYmxvY2tMZW4gPCAyMDBcbiAgICAgICAgaWYgKCEoMCA8IGJsb2NrTGVuICYmIGJsb2NrTGVuIDwgMjAwKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignb25seSBrZWNjYWstZjE2MDAgZnVuY3Rpb24gaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgc3dhcDMySWZCRSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICBzd2FwMzJJZkJFKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhZXhpc3RzKHRoaXMpO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgYWJ5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcywgZmFsc2UpO1xuICAgICAgICBhYnl0ZXMob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgIGFudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFvdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCgpIHdhcyBhbHJlYWR5IGNhbGxlZCcpO1xuICAgICAgICB0aGlzLndyaXRlSW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKG5ldyBVaW50OEFycmF5KHRoaXMub3V0cHV0TGVuKSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW4odGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gY3JlYXRlSGFzaGVyKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKiogU0hBMy0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzUxMiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KSkoKTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKioga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni4gKi9cbmV4cG9ydCBjb25zdCBrZWNjYWtfMjU2ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBrZWNjYWstMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha181MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlbigweDAxLCA3MiwgNTEyIC8gOCkpKCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IGNyZWF0ZVhPRmVyKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuLyoqIFNIQUtFMTI4IFhPRiB3aXRoIDEyOC1iaXQgc2VjdXJpdHkuICovXG5leHBvcnQgY29uc3Qgc2hha2UxMjggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCkpKCk7XG4vKiogU0hBS0UyNTYgWE9GIHdpdGggMjU2LWJpdCBzZWN1cml0eS4gKi9cbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/sha3.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: () => (/* binding */ Hash),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   aexists: () => (/* binding */ aexists),\n/* harmony export */   ahash: () => (/* binding */ ahash),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   aoutput: () => (/* binding */ aoutput),\n/* harmony export */   asyncLoop: () => (/* binding */ asyncLoop),\n/* harmony export */   byteSwap: () => (/* binding */ byteSwap),\n/* harmony export */   byteSwap32: () => (/* binding */ byteSwap32),\n/* harmony export */   byteSwapIfBE: () => (/* binding */ byteSwapIfBE),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   checkOpts: () => (/* binding */ checkOpts),\n/* harmony export */   clean: () => (/* binding */ clean),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   createOptHasher: () => (/* binding */ createOptHasher),\n/* harmony export */   createView: () => (/* binding */ createView),\n/* harmony export */   createXOFer: () => (/* binding */ createXOFer),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isLE: () => (/* binding */ isLE),\n/* harmony export */   kdfInputToBytes: () => (/* binding */ kdfInputToBytes),\n/* harmony export */   nextTick: () => (/* binding */ nextTick),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   rotl: () => (/* binding */ rotl),\n/* harmony export */   rotr: () => (/* binding */ rotr),\n/* harmony export */   swap32IfBE: () => (/* binding */ swap32IfBE),\n/* harmony export */   swap8IfBE: () => (/* binding */ swap8IfBE),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   u32: () => (/* binding */ u32),\n/* harmony export */   u8: () => (/* binding */ u8),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   wrapConstructor: () => (/* binding */ wrapConstructor),\n/* harmony export */   wrapConstructorWithOpts: () => (/* binding */ wrapConstructorWithOpts),\n/* harmony export */   wrapXOFConstructorWithOpts: () => (/* binding */ wrapXOFConstructorWithOpts)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/cryptoNode.js\");\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nconst isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nconst swap8IfBE = isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nconst byteSwapIfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nconst swap32IfBE = isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nconst wrapConstructor = createHasher;\nconst wrapConstructorWithOpts = createOptHasher;\nconst wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes === 'function') {\n        return Uint8Array.from(_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUM5QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1A7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQSxRQUFRLHdEQUFNLFdBQVcsd0RBQU07QUFDL0IsK0JBQStCLHdEQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxlc21cXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBoZXgsIGJ5dGVzLCBDU1BSTkcuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbi8qKiBDaGVja3MgaWYgc29tZXRoaW5nIGlzIFVpbnQ4QXJyYXkuIEJlIGNhcmVmdWw6IG5vZGVqcyBCdWZmZXIgd2lsbCByZXR1cm4gdHJ1ZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHwgKEFycmF5QnVmZmVyLmlzVmlldyhhKSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5Jyk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgcG9zaXRpdmUgaW50ZWdlci4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJyArIGxlbmd0aHMgKyAnLCBnb3QgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgaGFzaCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyJyk7XG4gICAgYW51bWJlcihoLm91dHB1dExlbik7XG4gICAgYW51bWJlcihoLmJsb2NrTGVuKTtcbn1cbi8qKiBBc3NlcnRzIGEgaGFzaCBpbnN0YW5jZSBoYXMgbm90IGJlZW4gZGVzdHJveWVkIC8gZmluaXNoZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGFieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICcgKyBtaW4pO1xuICAgIH1cbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHU4LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHU4KGFycikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTMyLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8qKiBDcmVhdGUgRGF0YVZpZXcgb2YgYW4gYXJyYXkgZm9yIGVhc3kgYnl0ZS1sZXZlbCBtYW5pcHVsYXRpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVmlldyhhcnIpIHtcbiAgICByZXR1cm4gbmV3IERhdGFWaWV3KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG59XG4vKiogVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5leHBvcnQgZnVuY3Rpb24gcm90bCh3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCBzaGlmdCkgfCAoKHdvcmQgPj4+ICgzMiAtIHNoaWZ0KSkgPj4+IDApO1xufVxuLyoqIElzIGN1cnJlbnQgcGxhdGZvcm0gbGl0dGxlLWVuZGlhbj8gTW9zdCBhcmUuIEJpZy1FbmRpYW4gcGxhdGZvcm06IElCTSAqL1xuZXhwb3J0IGNvbnN0IGlzTEUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQpKCk7XG4vKiogVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwKHdvcmQpIHtcbiAgICByZXR1cm4gKCgod29yZCA8PCAyNCkgJiAweGZmMDAwMDAwKSB8XG4gICAgICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAgICAgKCh3b3JkID4+PiAyNCkgJiAweGZmKSk7XG59XG4vKiogQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtICovXG5leHBvcnQgY29uc3Qgc3dhcDhJZkJFID0gaXNMRVxuICAgID8gKG4pID0+IG5cbiAgICA6IChuKSA9PiBieXRlU3dhcChuKTtcbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVTd2FwSWZCRSA9IHN3YXA4SWZCRTtcbi8qKiBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5ICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0IGNvbnN0IHN3YXAzMklmQkUgPSBpc0xFXG4gICAgPyAodSkgPT4gdVxuICAgIDogYnl0ZVN3YXAzMjtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gYnl0ZXMudG9IZXgoKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIEE6IDY1LCBGOiA3MCwgYTogOTcsIGY6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaCkge1xuICAgIGlmIChjaCA+PSBhc2NpaXMuXzAgJiYgY2ggPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2ggLSBhc2NpaXMuXzA7IC8vICcyJyA9PiA1MC00OFxuICAgIGlmIChjaCA+PSBhc2NpaXMuQSAmJiBjaCA8PSBhc2NpaXMuRilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5BIC0gMTApOyAvLyAnQicgPT4gNjYtKDY1LTEwKVxuICAgIGlmIChjaCA+PSBhc2NpaXMuYSAmJiBjaCA8PSBhc2NpaXMuZilcbiAgICAgICAgcmV0dXJuIGNoIC0gKGFzY2lpcy5hIC0gMTApOyAvLyAnYicgPT4gOTgtKDk3LTEwKVxuICAgIHJldHVybjtcbn1cbi8qKlxuICogQ29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXkuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb21IZXgoaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yOyAvLyBtdWx0aXBseSBmaXJzdCBvY3RldCwgZS5nLiAnYTMnID0+IDEwKjE2KzMgPT4gMTYwICsgMyA9PiAxNjNcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLyoqXG4gKiBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuICogQ2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4gKiBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdHJpbmcgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIENvbnZlcnRzIGJ5dGVzIHRvIHN0cmluZyB1c2luZyBVVEY4IGVuY29kaW5nLlxuICogQGV4YW1wbGUgYnl0ZXNUb1V0ZjgoVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvVXRmOChieXRlcykge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpO1xufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIEtERnM6IGNvbnN1bWVzIHVpbnQ4YXJyYXkgb3Igc3RyaW5nLlxuICogV2hlbiBzdHJpbmcgaXMgcGFzc2VkLCBkb2VzIHV0ZjggZGVjb2RpbmcsIHVzaW5nIFRleHREZWNvZGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24ga2RmSW5wdXRUb0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmV4cG9ydCBjbGFzcyBIYXNoIHtcbn1cbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnKSA9PiBoYXNoQ29ucygpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoKSA9PiBoYXNoQ29ucygpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVPcHRIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlWE9GZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgY29uc3Qgd3JhcENvbnN0cnVjdG9yID0gY3JlYXRlSGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlT3B0SGFzaGVyO1xuZXhwb3J0IGNvbnN0IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlWE9GZXI7XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIC8vIExlZ2FjeSBOb2RlLmpzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShjcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/legacy.js":
/*!******************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/legacy.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = exports.md5 = exports.MD5 = exports.sha1 = exports.SHA1 = void 0;\n/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_md.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n    0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n/** SHA1 legacy hash class. */\nclass SHA1 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, false);\n        this.A = SHA1_IV[0] | 0;\n        this.B = SHA1_IV[1] | 0;\n        this.C = SHA1_IV[2] | 0;\n        this.D = SHA1_IV[3] | 0;\n        this.E = SHA1_IV[4] | 0;\n    }\n    get() {\n        const { A, B, C, D, E } = this;\n        return [A, B, C, D, E];\n    }\n    set(A, B, C, D, E) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA1_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 80; i++)\n            SHA1_W[i] = (0, utils_ts_1.rotl)(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n        // Compression function main loop, 80 rounds\n        let { A, B, C, D, E } = this;\n        for (let i = 0; i < 80; i++) {\n            let F, K;\n            if (i < 20) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                K = 0x5a827999;\n            }\n            else if (i < 40) {\n                F = B ^ C ^ D;\n                K = 0x6ed9eba1;\n            }\n            else if (i < 60) {\n                F = (0, _md_ts_1.Maj)(B, C, D);\n                K = 0x8f1bbcdc;\n            }\n            else {\n                F = B ^ C ^ D;\n                K = 0xca62c1d6;\n            }\n            const T = ((0, utils_ts_1.rotl)(A, 5) + F + E + K + SHA1_W[i]) | 0;\n            E = D;\n            D = C;\n            C = (0, utils_ts_1.rotl)(B, 30);\n            B = A;\n            A = T;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        this.set(A, B, C, D, E);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA1_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA1 = SHA1;\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexports.sha1 = (0, utils_ts_1.createHasher)(() => new SHA1());\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) => Math.floor(p32 * Math.abs(Math.sin(i + 1))));\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nclass MD5 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 16, 8, true);\n        this.A = MD5_IV[0] | 0;\n        this.B = MD5_IV[1] | 0;\n        this.C = MD5_IV[2] | 0;\n        this.D = MD5_IV[3] | 0;\n    }\n    get() {\n        const { A, B, C, D } = this;\n        return [A, B, C, D];\n    }\n    set(A, B, C, D) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            MD5_W[i] = view.getUint32(offset, true);\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D } = this;\n        for (let i = 0; i < 64; i++) {\n            let F, g, s;\n            if (i < 16) {\n                F = (0, _md_ts_1.Chi)(B, C, D);\n                g = i;\n                s = [7, 12, 17, 22];\n            }\n            else if (i < 32) {\n                F = (0, _md_ts_1.Chi)(D, B, C);\n                g = (5 * i + 1) % 16;\n                s = [5, 9, 14, 20];\n            }\n            else if (i < 48) {\n                F = B ^ C ^ D;\n                g = (3 * i + 5) % 16;\n                s = [4, 11, 16, 23];\n            }\n            else {\n                F = C ^ (B | ~D);\n                g = (7 * i) % 16;\n                s = [6, 10, 15, 21];\n            }\n            F = F + A + K[i] + MD5_W[g];\n            A = D;\n            D = C;\n            C = B;\n            B = B + (0, utils_ts_1.rotl)(F, s[i % 4]);\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        this.set(A, B, C, D);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(MD5_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.MD5 = MD5;\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexports.md5 = (0, utils_ts_1.createHasher)(() => new MD5());\n// RIPEMD-160\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n    const L = [Id160];\n    const R = [Pi160];\n    const res = [L, R];\n    for (let i = 0; i < 4; i++)\n        for (let j of res)\n            j.push(j[i].map((k) => Rho160[k]));\n    return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\nconst shifts160 = /* @__PURE__ */ [\n    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n    0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n    0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group, x, y, z) {\n    if (group === 0)\n        return x ^ y ^ z;\n    if (group === 1)\n        return (x & y) | (~x & z);\n    if (group === 2)\n        return (x | ~y) ^ z;\n    if (group === 3)\n        return (x & z) | (y & ~z);\n    return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nclass RIPEMD160 extends _md_ts_1.HashMD {\n    constructor() {\n        super(64, 20, 8, true);\n        this.h0 = 0x67452301 | 0;\n        this.h1 = 0xefcdab89 | 0;\n        this.h2 = 0x98badcfe | 0;\n        this.h3 = 0x10325476 | 0;\n        this.h4 = 0xc3d2e1f0 | 0;\n    }\n    get() {\n        const { h0, h1, h2, h3, h4 } = this;\n        return [h0, h1, h2, h3, h4];\n    }\n    set(h0, h1, h2, h3, h4) {\n        this.h0 = h0 | 0;\n        this.h1 = h1 | 0;\n        this.h2 = h2 | 0;\n        this.h3 = h3 | 0;\n        this.h4 = h4 | 0;\n    }\n    process(view, offset) {\n        for (let i = 0; i < 16; i++, offset += 4)\n            BUF_160[i] = view.getUint32(offset, true);\n        // prettier-ignore\n        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;\n        // Instead of iterating 0 to 80, we split it into 5 groups\n        // And use the groups in constants, functions, etc. Much simpler\n        for (let group = 0; group < 5; group++) {\n            const rGroup = 4 - group;\n            const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n            const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n            const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n            for (let i = 0; i < 16; i++) {\n                const tl = ((0, utils_ts_1.rotl)(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n                al = el, el = dl, dl = (0, utils_ts_1.rotl)(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n            }\n            // 2 loops are 10% faster\n            for (let i = 0; i < 16; i++) {\n                const tr = ((0, utils_ts_1.rotl)(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n                ar = er, er = dr, dr = (0, utils_ts_1.rotl)(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n            }\n        }\n        // Add the compressed chunk to the current hash value\n        this.set((this.h1 + cl + dr) | 0, (this.h2 + dl + er) | 0, (this.h3 + el + ar) | 0, (this.h4 + al + br) | 0, (this.h0 + bl + cr) | 0);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(BUF_160);\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0);\n    }\n}\nexports.RIPEMD160 = RIPEMD160;\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexports.ripemd160 = (0, utils_ts_1.createHasher)(() => new RIPEMD160());\n//# sourceMappingURL=legacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2xlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUIsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFlBQVksR0FBRyxZQUFZO0FBQy9GOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLCtFQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLG1GQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUIsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBLDBEQUEwRDtBQUMxRCxzREFBc0Q7QUFDdEQsa0VBQWtFO0FBQ2xFLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0EsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBLDJGQUEyRjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXGxlZ2FjeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmlwZW1kMTYwID0gZXhwb3J0cy5SSVBFTUQxNjAgPSBleHBvcnRzLm1kNSA9IGV4cG9ydHMuTUQ1ID0gZXhwb3J0cy5zaGExID0gZXhwb3J0cy5TSEExID0gdm9pZCAwO1xuLyoqXG5cblNIQTEgKFJGQyAzMTc0KSwgTUQ1IChSRkMgMTMyMSkgYW5kIFJJUEVNRDE2MCAoUkZDIDIyODYpIGxlZ2FjeSwgd2VhayBoYXNoIGZ1bmN0aW9ucy5cbkRvbid0IHVzZSB0aGVtIGluIGEgbmV3IHByb3RvY29sLiBXaGF0IFwid2Vha1wiIG1lYW5zOlxuXG4tIENvbGxpc2lvbnMgY2FuIGJlIG1hZGUgd2l0aCAyXjE4IGVmZm9ydCBpbiBNRDUsIDJeNjAgaW4gU0hBMSwgMl44MCBpbiBSSVBFTUQxNjAuXG4tIE5vIHByYWN0aWNhbCBwcmUtaW1hZ2UgYXR0YWNrcyAob25seSB0aGVvcmV0aWNhbCwgMl4xMjMuNClcbi0gSE1BQyBzZWVtcyBraW5kYSBvazogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM2MTUxXG4gKiBAbW9kdWxlXG4gKi9cbmNvbnN0IF9tZF90c18xID0gcmVxdWlyZShcIi4vX21kLmpzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqIEluaXRpYWwgU0hBMSBzdGF0ZSAqL1xuY29uc3QgU0hBMV9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwLFxuXSk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyXG5jb25zdCBTSEExX1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbi8qKiBTSEExIGxlZ2FjeSBoYXNoIGNsYXNzLiAqL1xuY2xhc3MgU0hBMSBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgZmFsc2UpO1xuICAgICAgICB0aGlzLkEgPSBTSEExX0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMV9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTFfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEExX0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMV9JVls0XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEVdO1xuICAgIH1cbiAgICBzZXQoQSwgQiwgQywgRCwgRSkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEExX1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgODA7IGkrKylcbiAgICAgICAgICAgIFNIQTFfV1tpXSA9ICgwLCB1dGlsc190c18xLnJvdGwpKFNIQTFfV1tpIC0gM10gXiBTSEExX1dbaSAtIDhdIF4gU0hBMV9XW2kgLSAxNF0gXiBTSEExX1dbaSAtIDE2XSwgMSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIEs7XG4gICAgICAgICAgICBpZiAoaSA8IDIwKSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5DaGkpKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIEsgPSAweDVhODI3OTk5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQwKSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBLID0gMHg2ZWQ5ZWJhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGkgPCA2MCkge1xuICAgICAgICAgICAgICAgIEYgPSAoMCwgX21kX3RzXzEuTWFqKShCLCBDLCBEKTtcbiAgICAgICAgICAgICAgICBLID0gMHg4ZjFiYmNkYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIEYgPSBCIF4gQyBeIEQ7XG4gICAgICAgICAgICAgICAgSyA9IDB4Y2E2MmMxZDY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBUID0gKCgwLCB1dGlsc190c18xLnJvdGwpKEEsIDUpICsgRiArIEUgKyBLICsgU0hBMV9XW2ldKSB8IDA7XG4gICAgICAgICAgICBFID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9ICgwLCB1dGlsc190c18xLnJvdGwpKEIsIDMwKTtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IFQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTFfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMSA9IFNIQTE7XG4vKiogU0hBMSAoUkZDIDMxNzQpIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uLiBJdCB3YXMgY3J5cHRvZ3JhcGhpY2FsbHkgYnJva2VuLiAqL1xuZXhwb3J0cy5zaGExID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMSgpKTtcbi8qKiBQZXItcm91bmQgY29uc3RhbnRzICovXG5jb25zdCBwMzIgPSAvKiBAX19QVVJFX18gKi8gTWF0aC5wb3coMiwgMzIpO1xuY29uc3QgSyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiA2NCB9LCAoXywgaSkgPT4gTWF0aC5mbG9vcihwMzIgKiBNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpKSk7XG4vKiogbWQ1IGluaXRpYWwgc3RhdGU6IHNhbWUgYXMgc2hhMSwgYnV0IDQgdTMyIGluc3RlYWQgb2YgNS4gKi9cbmNvbnN0IE1ENV9JViA9IC8qIEBfX1BVUkVfXyAqLyBTSEExX0lWLnNsaWNlKDAsIDQpO1xuLy8gUmV1c2FibGUgdGVtcG9yYXJ5IGJ1ZmZlclxuY29uc3QgTUQ1X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbi8qKiBNRDUgbGVnYWN5IGhhc2ggY2xhc3MuICovXG5jbGFzcyBNRDUgZXh0ZW5kcyBfbWRfdHNfMS5IYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMTYsIDgsIHRydWUpO1xuICAgICAgICB0aGlzLkEgPSBNRDVfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBNRDVfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBNRDVfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBNRDVfSVZbM10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBEXTtcbiAgICB9XG4gICAgc2V0KEEsIEIsIEMsIEQpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBNRDVfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQgfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IEYsIGcsIHM7XG4gICAgICAgICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgICAgICAgICAgRiA9ICgwLCBfbWRfdHNfMS5DaGkpKEIsIEMsIEQpO1xuICAgICAgICAgICAgICAgIGcgPSBpO1xuICAgICAgICAgICAgICAgIHMgPSBbNywgMTIsIDE3LCAyMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgICAgICAgICAgICBGID0gKDAsIF9tZF90c18xLkNoaSkoRCwgQiwgQyk7XG4gICAgICAgICAgICAgICAgZyA9ICg1ICogaSArIDEpICUgMTY7XG4gICAgICAgICAgICAgICAgcyA9IFs1LCA5LCAxNCwgMjBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaSA8IDQ4KSB7XG4gICAgICAgICAgICAgICAgRiA9IEIgXiBDIF4gRDtcbiAgICAgICAgICAgICAgICBnID0gKDMgKiBpICsgNSkgJSAxNjtcbiAgICAgICAgICAgICAgICBzID0gWzQsIDExLCAxNiwgMjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRiA9IEMgXiAoQiB8IH5EKTtcbiAgICAgICAgICAgICAgICBnID0gKDcgKiBpKSAlIDE2O1xuICAgICAgICAgICAgICAgIHMgPSBbNiwgMTAsIDE1LCAyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGID0gRiArIEEgKyBLW2ldICsgTUQ1X1dbZ107XG4gICAgICAgICAgICBBID0gRDtcbiAgICAgICAgICAgIEQgPSBDO1xuICAgICAgICAgICAgQyA9IEI7XG4gICAgICAgICAgICBCID0gQiArICgwLCB1dGlsc190c18xLnJvdGwpKEYsIHNbaSAlIDRdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgdGhpcy5zZXQoQSwgQiwgQywgRCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKShNRDVfVyk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDApO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgIH1cbn1cbmV4cG9ydHMuTUQ1ID0gTUQ1O1xuLyoqXG4gKiBNRDUgKFJGQyAxMzIxKSBsZWdhY3kgaGFzaCBmdW5jdGlvbi4gSXQgd2FzIGNyeXB0b2dyYXBoaWNhbGx5IGJyb2tlbi5cbiAqIE1ENSBhcmNoaXRlY3R1cmUgaXMgc2ltaWxhciB0byBTSEExLCB3aXRoIHNvbWUgZGlmZmVyZW5jZXM6XG4gKiAtIFJlZHVjZWQgb3V0cHV0IGxlbmd0aDogMTYgYnl0ZXMgKDEyOCBiaXQpIGluc3RlYWQgb2YgMjBcbiAqIC0gNjQgcm91bmRzLCBpbnN0ZWFkIG9mIDgwXG4gKiAtIExpdHRsZS1lbmRpYW46IGNvdWxkIGJlIGZhc3RlciwgYnV0IHdpbGwgcmVxdWlyZSBtb3JlIGNvZGVcbiAqIC0gTm9uLWxpbmVhciBpbmRleCBzZWxlY3Rpb246IGh1Z2Ugc3BlZWQtdXAgZm9yIHVucm9sbFxuICogLSBQZXIgcm91bmQgY29uc3RhbnRzOiBtb3JlIG1lbW9yeSBhY2Nlc3NlcywgYWRkaXRpb25hbCBzcGVlZC11cCBmb3IgdW5yb2xsXG4gKi9cbmV4cG9ydHMubWQ1ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgTUQ1KCkpO1xuLy8gUklQRU1ELTE2MFxuY29uc3QgUmhvMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQ4QXJyYXkuZnJvbShbXG4gICAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcbl0pO1xuY29uc3QgSWQxNjAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IFVpbnQ4QXJyYXkuZnJvbShuZXcgQXJyYXkoMTYpLmZpbGwoMCkubWFwKChfLCBpKSA9PiBpKSkpKCk7XG5jb25zdCBQaTE2MCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gSWQxNjAubWFwKChpKSA9PiAoOSAqIGkgKyA1KSAlIDE2KSkoKTtcbmNvbnN0IGlkeExSID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgTCA9IFtJZDE2MF07XG4gICAgY29uc3QgUiA9IFtQaTE2MF07XG4gICAgY29uc3QgcmVzID0gW0wsIFJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKVxuICAgICAgICBmb3IgKGxldCBqIG9mIHJlcylcbiAgICAgICAgICAgIGoucHVzaChqW2ldLm1hcCgoaykgPT4gUmhvMTYwW2tdKSk7XG4gICAgcmV0dXJuIHJlcztcbn0pKCk7XG5jb25zdCBpZHhMID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpZHhMUlswXSkoKTtcbmNvbnN0IGlkeFIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlkeExSWzFdKSgpO1xuLy8gY29uc3QgW2lkeEwsIGlkeFJdID0gaWR4TFI7XG5jb25zdCBzaGlmdHMxNjAgPSAvKiBAX19QVVJFX18gKi8gW1xuICAgIFsxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDhdLFxuICAgIFsxMiwgMTMsIDExLCAxNSwgNiwgOSwgOSwgNywgMTIsIDE1LCAxMSwgMTMsIDcsIDgsIDcsIDddLFxuICAgIFsxMywgMTUsIDE0LCAxMSwgNywgNywgNiwgOCwgMTMsIDE0LCAxMywgMTIsIDUsIDUsIDYsIDldLFxuICAgIFsxNCwgMTEsIDEyLCAxNCwgOCwgNiwgNSwgNSwgMTUsIDEyLCAxNSwgMTQsIDksIDksIDgsIDZdLFxuICAgIFsxNSwgMTIsIDEzLCAxMywgOSwgNSwgOCwgNiwgMTQsIDExLCAxMiwgMTEsIDgsIDYsIDUsIDVdLFxuXS5tYXAoKGkpID0+IFVpbnQ4QXJyYXkuZnJvbShpKSk7XG5jb25zdCBzaGlmdHNMMTYwID0gLyogQF9fUFVSRV9fICovIGlkeEwubWFwKChpZHgsIGkpID0+IGlkeC5tYXAoKGopID0+IHNoaWZ0czE2MFtpXVtqXSkpO1xuY29uc3Qgc2hpZnRzUjE2MCA9IC8qIEBfX1BVUkVfXyAqLyBpZHhSLm1hcCgoaWR4LCBpKSA9PiBpZHgubWFwKChqKSA9PiBzaGlmdHMxNjBbaV1bal0pKTtcbmNvbnN0IEtsMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MDAwMDAwMDAsIDB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4YTk1M2ZkNGUsXG5dKTtcbmNvbnN0IEtyMTYwID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4NTBhMjhiZTYsIDB4NWM0ZGQxMjQsIDB4NmQ3MDNlZjMsIDB4N2E2ZDc2ZTksIDB4MDAwMDAwMDAsXG5dKTtcbi8vIEl0J3MgY2FsbGVkIGYoKSBpbiBzcGVjLlxuZnVuY3Rpb24gcmlwZW1kX2YoZ3JvdXAsIHgsIHksIHopIHtcbiAgICBpZiAoZ3JvdXAgPT09IDApXG4gICAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gICAgaWYgKGdyb3VwID09PSAxKVxuICAgICAgICByZXR1cm4gKHggJiB5KSB8ICh+eCAmIHopO1xuICAgIGlmIChncm91cCA9PT0gMilcbiAgICAgICAgcmV0dXJuICh4IHwgfnkpIF4gejtcbiAgICBpZiAoZ3JvdXAgPT09IDMpXG4gICAgICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiB+eik7XG4gICAgcmV0dXJuIHggXiAoeSB8IH56KTtcbn1cbi8vIFJldXNhYmxlIHRlbXBvcmFyeSBidWZmZXJcbmNvbnN0IEJVRl8xNjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDE2KTtcbmNsYXNzIFJJUEVNRDE2MCBleHRlbmRzIF9tZF90c18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAyMCwgOCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaDAgPSAweDY3NDUyMzAxIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IDB4ZWZjZGFiODkgfCAwO1xuICAgICAgICB0aGlzLmgyID0gMHg5OGJhZGNmZSB8IDA7XG4gICAgICAgIHRoaXMuaDMgPSAweDEwMzI1NDc2IHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IDB4YzNkMmUxZjAgfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgaDAsIGgxLCBoMiwgaDMsIGg0IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW2gwLCBoMSwgaDIsIGgzLCBoNF07XG4gICAgfVxuICAgIHNldChoMCwgaDEsIGgyLCBoMywgaDQpIHtcbiAgICAgICAgdGhpcy5oMCA9IGgwIHwgMDtcbiAgICAgICAgdGhpcy5oMSA9IGgxIHwgMDtcbiAgICAgICAgdGhpcy5oMiA9IGgyIHwgMDtcbiAgICAgICAgdGhpcy5oMyA9IGgzIHwgMDtcbiAgICAgICAgdGhpcy5oNCA9IGg0IHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIEJVRl8xNjBbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIHRydWUpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IGFsID0gdGhpcy5oMCB8IDAsIGFyID0gYWwsIGJsID0gdGhpcy5oMSB8IDAsIGJyID0gYmwsIGNsID0gdGhpcy5oMiB8IDAsIGNyID0gY2wsIGRsID0gdGhpcy5oMyB8IDAsIGRyID0gZGwsIGVsID0gdGhpcy5oNCB8IDAsIGVyID0gZWw7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgaXRlcmF0aW5nIDAgdG8gODAsIHdlIHNwbGl0IGl0IGludG8gNSBncm91cHNcbiAgICAgICAgLy8gQW5kIHVzZSB0aGUgZ3JvdXBzIGluIGNvbnN0YW50cywgZnVuY3Rpb25zLCBldGMuIE11Y2ggc2ltcGxlclxuICAgICAgICBmb3IgKGxldCBncm91cCA9IDA7IGdyb3VwIDwgNTsgZ3JvdXArKykge1xuICAgICAgICAgICAgY29uc3Qgckdyb3VwID0gNCAtIGdyb3VwO1xuICAgICAgICAgICAgY29uc3QgaGJsID0gS2wxNjBbZ3JvdXBdLCBoYnIgPSBLcjE2MFtncm91cF07IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgcmwgPSBpZHhMW2dyb3VwXSwgcnIgPSBpZHhSW2dyb3VwXTsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzbCA9IHNoaWZ0c0wxNjBbZ3JvdXBdLCBzciA9IHNoaWZ0c1IxNjBbZ3JvdXBdOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRsID0gKCgwLCB1dGlsc190c18xLnJvdGwpKGFsICsgcmlwZW1kX2YoZ3JvdXAsIGJsLCBjbCwgZGwpICsgQlVGXzE2MFtybFtpXV0gKyBoYmwsIHNsW2ldKSArIGVsKSB8IDA7XG4gICAgICAgICAgICAgICAgYWwgPSBlbCwgZWwgPSBkbCwgZGwgPSAoMCwgdXRpbHNfdHNfMS5yb3RsKShjbCwgMTApIHwgMCwgY2wgPSBibCwgYmwgPSB0bDsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAyIGxvb3BzIGFyZSAxMCUgZmFzdGVyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9ICgoMCwgdXRpbHNfdHNfMS5yb3RsKShhciArIHJpcGVtZF9mKHJHcm91cCwgYnIsIGNyLCBkcikgKyBCVUZfMTYwW3JyW2ldXSArIGhiciwgc3JbaV0pICsgZXIpIHwgMDtcbiAgICAgICAgICAgICAgICBhciA9IGVyLCBlciA9IGRyLCBkciA9ICgwLCB1dGlsc190c18xLnJvdGwpKGNyLCAxMCkgfCAwLCBjciA9IGJyLCBiciA9IHRyOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICB0aGlzLnNldCgodGhpcy5oMSArIGNsICsgZHIpIHwgMCwgKHRoaXMuaDIgKyBkbCArIGVyKSB8IDAsICh0aGlzLmgzICsgZWwgKyBhcikgfCAwLCAodGhpcy5oNCArIGFsICsgYnIpIHwgMCwgKHRoaXMuaDAgKyBibCArIGNyKSB8IDApO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikoQlVGXzE2MCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCk7XG4gICAgfVxufVxuZXhwb3J0cy5SSVBFTUQxNjAgPSBSSVBFTUQxNjA7XG4vKipcbiAqIFJJUEVNRC0xNjAgLSBhIGxlZ2FjeSBoYXNoIGZ1bmN0aW9uIGZyb20gMTk5MHMuXG4gKiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbiAqICogaHR0cHM6Ly9ob21lcy5lc2F0Lmt1bGV1dmVuLmJlL35ib3NzZWxhZS9yaXBlbWQxNjAvcGRmL0FCLTk2MDEvQUItOTYwMS5wZGZcbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBSSVBFTUQxNjAoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3kuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/legacy.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/ripemd160.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/ripemd160.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ripemd160 = exports.RIPEMD160 = void 0;\n/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nconst legacy_ts_1 = __webpack_require__(/*! ./legacy.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/legacy.js\");\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.RIPEMD160 = legacy_ts_1.RIPEMD160;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexports.ripemd160 = legacy_ts_1.ripemd160;\n//# sourceMappingURL=ripemd160.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3JpcGVtZDE2MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6QztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxjaGltZFxcY29zbWljLWRleFxcbm9kZV9tb2R1bGVzXFxveFxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xccmlwZW1kMTYwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBleHBvcnRzLlJJUEVNRDE2MCA9IHZvaWQgMDtcbi8qKlxuICogUklQRU1ELTE2MCBsZWdhY3kgaGFzaCBmdW5jdGlvbi5cbiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwLmh0bWxcbiAqIGh0dHBzOi8vaG9tZXMuZXNhdC5rdWxldXZlbi5iZS9+Ym9zc2VsYWUvcmlwZW1kMTYwL3BkZi9BQi05NjAxL0FCLTk2MDEucGRmXG4gKiBAbW9kdWxlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBsZWdhY3lfdHNfMSA9IHJlcXVpcmUoXCIuL2xlZ2FjeS5qc1wiKTtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgaW1wb3J0IGZyb20gYG5vYmxlL2hhc2hlcy9sZWdhY3lgIG1vZHVsZSAqL1xuZXhwb3J0cy5SSVBFTUQxNjAgPSBsZWdhY3lfdHNfMS5SSVBFTUQxNjA7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvbGVnYWN5YCBtb2R1bGUgKi9cbmV4cG9ydHMucmlwZW1kMTYwID0gbGVnYWN5X3RzXzEucmlwZW1kMTYwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmlwZW1kMTYwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/ripemd160.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha2.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/sha2.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha512_224 = exports.sha512_256 = exports.sha384 = exports.sha512 = exports.sha224 = exports.sha256 = exports.SHA512_256 = exports.SHA512_224 = exports.SHA384 = exports.SHA512 = exports.SHA224 = exports.SHA256 = void 0;\n/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nconst _md_ts_1 = __webpack_require__(/*! ./_md.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_md.js\");\nconst u64 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_u64.js\");\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_ts_1.HashMD {\n    constructor(outputLen = 32) {\n        super(64, outputLen, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = _md_ts_1.SHA256_IV[0] | 0;\n        this.B = _md_ts_1.SHA256_IV[1] | 0;\n        this.C = _md_ts_1.SHA256_IV[2] | 0;\n        this.D = _md_ts_1.SHA256_IV[3] | 0;\n        this.E = _md_ts_1.SHA256_IV[4] | 0;\n        this.F = _md_ts_1.SHA256_IV[5] | 0;\n        this.G = _md_ts_1.SHA256_IV[6] | 0;\n        this.H = _md_ts_1.SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0, utils_ts_1.rotr)(W15, 7) ^ (0, utils_ts_1.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0, utils_ts_1.rotr)(W2, 17) ^ (0, utils_ts_1.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0, utils_ts_1.rotr)(E, 6) ^ (0, utils_ts_1.rotr)(E, 11) ^ (0, utils_ts_1.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0, _md_ts_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0, utils_ts_1.rotr)(A, 2) ^ (0, utils_ts_1.rotr)(A, 13) ^ (0, utils_ts_1.rotr)(A, 22);\n            const T2 = (sigma0 + (0, _md_ts_1.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA256_W);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        (0, utils_ts_1.clean)(this.buffer);\n    }\n}\nexports.SHA256 = SHA256;\nclass SHA224 extends SHA256 {\n    constructor() {\n        super(28);\n        this.A = _md_ts_1.SHA224_IV[0] | 0;\n        this.B = _md_ts_1.SHA224_IV[1] | 0;\n        this.C = _md_ts_1.SHA224_IV[2] | 0;\n        this.D = _md_ts_1.SHA224_IV[3] | 0;\n        this.E = _md_ts_1.SHA224_IV[4] | 0;\n        this.F = _md_ts_1.SHA224_IV[5] | 0;\n        this.G = _md_ts_1.SHA224_IV[6] | 0;\n        this.H = _md_ts_1.SHA224_IV[7] | 0;\n    }\n}\nexports.SHA224 = SHA224;\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_ts_1.HashMD {\n    constructor(outputLen = 64) {\n        super(128, outputLen, 16, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = _md_ts_1.SHA512_IV[0] | 0;\n        this.Al = _md_ts_1.SHA512_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA512_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA512_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA512_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA512_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA512_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA512_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA512_IV[8] | 0;\n        this.El = _md_ts_1.SHA512_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA512_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA512_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA512_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA512_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA512_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n            const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n            const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n            const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n            const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = u64.add3L(T1l, sigma0l, MAJl);\n            Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        (0, utils_ts_1.clean)(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n        (0, utils_ts_1.clean)(this.buffer);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nexports.SHA512 = SHA512;\nclass SHA384 extends SHA512 {\n    constructor() {\n        super(48);\n        this.Ah = _md_ts_1.SHA384_IV[0] | 0;\n        this.Al = _md_ts_1.SHA384_IV[1] | 0;\n        this.Bh = _md_ts_1.SHA384_IV[2] | 0;\n        this.Bl = _md_ts_1.SHA384_IV[3] | 0;\n        this.Ch = _md_ts_1.SHA384_IV[4] | 0;\n        this.Cl = _md_ts_1.SHA384_IV[5] | 0;\n        this.Dh = _md_ts_1.SHA384_IV[6] | 0;\n        this.Dl = _md_ts_1.SHA384_IV[7] | 0;\n        this.Eh = _md_ts_1.SHA384_IV[8] | 0;\n        this.El = _md_ts_1.SHA384_IV[9] | 0;\n        this.Fh = _md_ts_1.SHA384_IV[10] | 0;\n        this.Fl = _md_ts_1.SHA384_IV[11] | 0;\n        this.Gh = _md_ts_1.SHA384_IV[12] | 0;\n        this.Gl = _md_ts_1.SHA384_IV[13] | 0;\n        this.Hh = _md_ts_1.SHA384_IV[14] | 0;\n        this.Hl = _md_ts_1.SHA384_IV[15] | 0;\n    }\n}\nexports.SHA384 = SHA384;\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n    0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n    0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n    0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n    0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super(28);\n        this.Ah = T224_IV[0] | 0;\n        this.Al = T224_IV[1] | 0;\n        this.Bh = T224_IV[2] | 0;\n        this.Bl = T224_IV[3] | 0;\n        this.Ch = T224_IV[4] | 0;\n        this.Cl = T224_IV[5] | 0;\n        this.Dh = T224_IV[6] | 0;\n        this.Dl = T224_IV[7] | 0;\n        this.Eh = T224_IV[8] | 0;\n        this.El = T224_IV[9] | 0;\n        this.Fh = T224_IV[10] | 0;\n        this.Fl = T224_IV[11] | 0;\n        this.Gh = T224_IV[12] | 0;\n        this.Gl = T224_IV[13] | 0;\n        this.Hh = T224_IV[14] | 0;\n        this.Hl = T224_IV[15] | 0;\n    }\n}\nexports.SHA512_224 = SHA512_224;\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super(32);\n        this.Ah = T256_IV[0] | 0;\n        this.Al = T256_IV[1] | 0;\n        this.Bh = T256_IV[2] | 0;\n        this.Bl = T256_IV[3] | 0;\n        this.Ch = T256_IV[4] | 0;\n        this.Cl = T256_IV[5] | 0;\n        this.Dh = T256_IV[6] | 0;\n        this.Dl = T256_IV[7] | 0;\n        this.Eh = T256_IV[8] | 0;\n        this.El = T256_IV[9] | 0;\n        this.Fh = T256_IV[10] | 0;\n        this.Fl = T256_IV[11] | 0;\n        this.Gh = T256_IV[12] | 0;\n        this.Gl = T256_IV[13] | 0;\n        this.Hh = T256_IV[14] | 0;\n        this.Hl = T256_IV[15] | 0;\n    }\n}\nexports.SHA512_256 = SHA512_256;\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexports.sha256 = (0, utils_ts_1.createHasher)(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexports.sha224 = (0, utils_ts_1.createHasher)(() => new SHA224());\n/** SHA2-512 hash function from RFC 4634. */\nexports.sha512 = (0, utils_ts_1.createHasher)(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexports.sha384 = (0, utils_ts_1.createHasher)(() => new SHA384());\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_256 = (0, utils_ts_1.createHasher)(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexports.sha512_224 = (0, utils_ts_1.createHasher)(() => new SHA512_224());\n//# sourceMappingURL=sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWM7QUFDek47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQywrRUFBVTtBQUNuQyxZQUFZLG1CQUFPLENBQUMsaUZBQVc7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxzaGEyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGE1MTJfMjI0ID0gZXhwb3J0cy5zaGE1MTJfMjU2ID0gZXhwb3J0cy5zaGEzODQgPSBleHBvcnRzLnNoYTUxMiA9IGV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5zaGEyNTYgPSBleHBvcnRzLlNIQTUxMl8yNTYgPSBleHBvcnRzLlNIQTUxMl8yMjQgPSBleHBvcnRzLlNIQTM4NCA9IGV4cG9ydHMuU0hBNTEyID0gZXhwb3J0cy5TSEEyMjQgPSBleHBvcnRzLlNIQTI1NiA9IHZvaWQgMDtcbi8qKlxuICogU0hBMiBoYXNoIGZ1bmN0aW9uLiBBLmsuYS4gc2hhMjU2LCBzaGEzODQsIHNoYTUxMiwgc2hhNTEyXzIyNCwgc2hhNTEyXzI1Ni5cbiAqIFNIQTI1NiBpcyB0aGUgZmFzdGVzdCBoYXNoIGltcGxlbWVudGFibGUgaW4gSlMsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogQ2hlY2sgb3V0IFtSRkMgNDYzNF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM0NjM0KSBhbmRcbiAqIFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX21kX3RzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1NjQgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqXG4gKiBSb3VuZCBjb25zdGFudHM6XG4gKiBGaXJzdCAzMiBiaXRzIG9mIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4gKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8qKiBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyLiBcIldcIiBjb21lcyBzdHJhaWdodCBmcm9tIHNwZWMuICovXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSAzMikge1xuICAgICAgICBzdXBlcig2NCwgb3V0cHV0TGVuLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBfbWRfdHNfMS5TSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBfbWRfdHNfMS5TSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBfbWRfdHNfMS5TSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBfbWRfdHNfMS5TSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX3RzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc190c18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc190c18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX3RzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfdHNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgKDAsIF9tZF90c18xLkNoaSkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfdHNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc190c18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArICgwLCBfbWRfdHNfMS5NYWopKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTI1Nl9XKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmNsZWFuKSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyNTYgPSBTSEEyNTY7XG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyOCk7XG4gICAgICAgIHRoaXMuQSA9IF9tZF90c18xLlNIQTIyNF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IF9tZF90c18xLlNIQTIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IF9tZF90c18xLlNIQTIyNF9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IF9tZF90c18xLlNIQTIyNF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IF9tZF90c18xLlNIQTIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IF9tZF90c18xLlNIQTIyNF9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IF9tZF90c18xLlNIQTIyNF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IF9tZF90c18xLlNIQTIyNF9JVls3XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyMjQgPSBTSEEyMjQ7XG4vLyBTSEEyLTUxMiBpcyBzbG93ZXIgdGhhbiBzaGEyNTYgaW4ganMgYmVjYXVzZSB1NjQgb3BlcmF0aW9ucyBhcmUgc2xvdy5cbi8vIFJvdW5kIGNvbnRhbnRzXG4vLyBGaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4MCBwcmltZXMgMi4uNDA5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEs1MTIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG5jb25zdCBTSEE1MTJfS2ggPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMF0pKCk7XG5jb25zdCBTSEE1MTJfS2wgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEs1MTJbMV0pKCk7XG4vLyBSZXVzYWJsZSB0ZW1wb3JhcnkgYnVmZmVyc1xuY29uc3QgU0hBNTEyX1dfSCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY29uc3QgU0hBNTEyX1dfTCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoODApO1xuY2xhc3MgU0hBNTEyIGV4dGVuZHMgX21kX3RzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcihvdXRwdXRMZW4gPSA2NCkge1xuICAgICAgICBzdXBlcigxMjgsIG91dHB1dExlbiwgMTYsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gX21kX3RzXzEuU0hBNTEyX0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IF9tZF90c18xLlNIQTUxMl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gX21kX3RzXzEuU0hBNTEyX0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IF9tZF90c18xLlNIQTUxMl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBfbWRfdHNfMS5TSEE1MTJfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gX21kX3RzXzEuU0hBNTEyX0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IF9tZF90c18xLlNIQTUxMl9JVls4XSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gX21kX3RzXzEuU0hBNTEyX0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTFdIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IF9tZF90c18xLlNIQTUxMl9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gX21kX3RzXzEuU0hBNTEyX0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBfbWRfdHNfMS5TSEE1MTJfSVZbMTRdIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IF9tZF90c18xLlNIQTUxMl9JVlsxNV0gfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IHU2NC5yb3RyU0goVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNIKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gdTY0LnJvdHJTTChXMTVoLCBXMTVsLCAxKSBeIHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgOCkgXiB1NjQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gdTY0LnJvdHJTSChXMmgsIFcybCwgMTkpIF4gdTY0LnJvdHJCSChXMmgsIFcybCwgNjEpIF4gdTY0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IHU2NC5yb3RyU0woVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkwoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IHU2NC5hZGQ0TChzMGwsIHMxbCwgU0hBNTEyX1dfTFtpIC0gN10sIFNIQTUxMl9XX0xbaSAtIDE2XSk7XG4gICAgICAgICAgICBjb25zdCBTVU1oID0gdTY0LmFkZDRIKFNVTWwsIHMwaCwgczFoLCBTSEE1MTJfV19IW2kgLSA3XSwgU0hBNTEyX1dfSFtpIC0gMTZdKTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSBTVU1oIHwgMDtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSBTVU1sIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCB9ID0gdGhpcztcbiAgICAgICAgLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24gbWFpbiBsb29wLCA4MCByb3VuZHNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBTMSA6PSAoZSByaWdodHJvdGF0ZSAxNCkgeG9yIChlIHJpZ2h0cm90YXRlIDE4KSB4b3IgKGUgcmlnaHRyb3RhdGUgNDEpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTFoID0gdTY0LnJvdHJTSChFaCwgRWwsIDE0KSBeIHU2NC5yb3RyU0goRWgsIEVsLCAxOCkgXiB1NjQucm90ckJIKEVoLCBFbCwgNDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExbCA9IHU2NC5yb3RyU0woRWgsIEVsLCAxNCkgXiB1NjQucm90clNMKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCTChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIC8vY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IENISWggPSAoRWggJiBGaCkgXiAofkVoICYgR2gpO1xuICAgICAgICAgICAgY29uc3QgQ0hJbCA9IChFbCAmIEZsKSBeICh+RWwgJiBHbCk7XG4gICAgICAgICAgICAvLyBUMSA9IEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEE1MTJfS1tpXSArIFNIQTUxMl9XW2ldXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFQxbGwgPSB1NjQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSB1NjQuYWRkNUgoVDFsbCwgSGgsIHNpZ21hMWgsIENISWgsIFNIQTUxMl9LaFtpXSwgU0hBNTEyX1dfSFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWwgPSBUMWxsIHwgMDtcbiAgICAgICAgICAgIC8vIFMwIDo9IChhIHJpZ2h0cm90YXRlIDI4KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzQpIHhvciAoYSByaWdodHJvdGF0ZSAzOSlcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGggPSB1NjQucm90clNIKEFoLCBBbCwgMjgpIF4gdTY0LnJvdHJCSChBaCwgQWwsIDM0KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTBsID0gdTY0LnJvdHJTTChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkwoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3QgTUFKaCA9IChBaCAmIEJoKSBeIChBaCAmIENoKSBeIChCaCAmIENoKTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmwgPSAoQWwgJiBCbCkgXiAoQWwgJiBDbCkgXiAoQmwgJiBDbCk7XG4gICAgICAgICAgICBIaCA9IEdoIHwgMDtcbiAgICAgICAgICAgIEhsID0gR2wgfCAwO1xuICAgICAgICAgICAgR2ggPSBGaCB8IDA7XG4gICAgICAgICAgICBHbCA9IEZsIHwgMDtcbiAgICAgICAgICAgIEZoID0gRWggfCAwO1xuICAgICAgICAgICAgRmwgPSBFbCB8IDA7XG4gICAgICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQoRGggfCAwLCBEbCB8IDAsIFQxaCB8IDAsIFQxbCB8IDApKTtcbiAgICAgICAgICAgIERoID0gQ2ggfCAwO1xuICAgICAgICAgICAgRGwgPSBDbCB8IDA7XG4gICAgICAgICAgICBDaCA9IEJoIHwgMDtcbiAgICAgICAgICAgIENsID0gQmwgfCAwO1xuICAgICAgICAgICAgQmggPSBBaCB8IDA7XG4gICAgICAgICAgICBCbCA9IEFsIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IEFsbCA9IHU2NC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSB1NjQuYWRkM0goQWxsLCBUMWgsIHNpZ21hMGgsIE1BSmgpO1xuICAgICAgICAgICAgQWwgPSBBbGwgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCB0aGUgY29tcHJlc3NlZCBjaHVuayB0byB0aGUgY3VycmVudCBoYXNoIHZhbHVlXG4gICAgICAgICh7IGg6IEFoLCBsOiBBbCB9ID0gdTY0LmFkZCh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIEFoIHwgMCwgQWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEJoLCBsOiBCbCB9ID0gdTY0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gdTY0LmFkZCh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIENoIHwgMCwgQ2wgfCAwKSk7XG4gICAgICAgICh7IGg6IERoLCBsOiBEbCB9ID0gdTY0LmFkZCh0aGlzLkRoIHwgMCwgdGhpcy5EbCB8IDAsIERoIHwgMCwgRGwgfCAwKSk7XG4gICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gdTY0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gdTY0LmFkZCh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIEZoIHwgMCwgRmwgfCAwKSk7XG4gICAgICAgICh7IGg6IEdoLCBsOiBHbCB9ID0gdTY0LmFkZCh0aGlzLkdoIHwgMCwgdGhpcy5HbCB8IDAsIEdoIHwgMCwgR2wgfCAwKSk7XG4gICAgICAgICh7IGg6IEhoLCBsOiBIbCB9ID0gdTY0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuY2xlYW4pKFNIQTUxMl9XX0gsIFNIQTUxMl9XX0wpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5idWZmZXIpO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMiA9IFNIQTUxMjtcbmNsYXNzIFNIQTM4NCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDQ4KTtcbiAgICAgICAgdGhpcy5BaCA9IF9tZF90c18xLlNIQTM4NF9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBfbWRfdHNfMS5TSEEzODRfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkJoID0gX21kX3RzXzEuU0hBMzg0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IF9tZF90c18xLlNIQTM4NF9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBfbWRfdHNfMS5TSEEzODRfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkNsID0gX21kX3RzXzEuU0hBMzg0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IF9tZF90c18xLlNIQTM4NF9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBfbWRfdHNfMS5TSEEzODRfSVZbN10gfCAwO1xuICAgICAgICB0aGlzLkVoID0gX21kX3RzXzEuU0hBMzg0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IF9tZF90c18xLlNIQTM4NF9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBfbWRfdHNfMS5TSEEzODRfSVZbMTBdIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IF9tZF90c18xLlNIQTM4NF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gX21kX3RzXzEuU0hBMzg0X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBfbWRfdHNfMS5TSEEzODRfSVZbMTNdIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IF9tZF90c18xLlNIQTM4NF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gX21kX3RzXzEuU0hBMzg0X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEzODQgPSBTSEEzODQ7XG4vKipcbiAqIFRydW5jYXRlZCBTSEE1MTIvMjU2IGFuZCBTSEE1MTIvMjI0LlxuICogU0hBNTEyX0lWIGlzIFhPUmVkIHdpdGggMHhhNWE1YTVhNWE1YTVhNWE1LCB0aGVuIHVzZWQgYXMgXCJpbnRlcm1lZGlhcnlcIiBJViBvZiBTSEE1MTIvdC5cbiAqIFRoZW4gdCBoYXNoZXMgc3RyaW5nIHRvIHByb2R1Y2UgcmVzdWx0IElWLlxuICogU2VlIGB0ZXN0L21pc2Mvc2hhMi1nZW4taXYuanNgLlxuICovXG4vKiogU0hBNTEyLzIyNCBJViAqL1xuY29uc3QgVDIyNF9JViA9IC8qIEBfX1BVUkVfXyAqLyBVaW50MzJBcnJheS5mcm9tKFtcbiAgICAweDhjM2QzN2M4LCAweDE5NTQ0ZGEyLCAweDczZTE5OTY2LCAweDg5ZGNkNGQ2LCAweDFkZmFiN2FlLCAweDMyZmY5YzgyLCAweDY3OWRkNTE0LCAweDU4MmY5ZmNmLFxuICAgIDB4MGY2ZDJiNjksIDB4N2JkNDRkYTgsIDB4NzdlMzZmNzMsIDB4MDRjNDg5NDIsIDB4M2Y5ZDg1YTgsIDB4NmExZDM2YzgsIDB4MTExMmU2YWQsIDB4OTFkNjkyYTEsXG5dKTtcbi8qKiBTSEE1MTIvMjU2IElWICovXG5jb25zdCBUMjU2X0lWID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAgIDB4MjIzMTIxOTQsIDB4ZmMyYmY3MmMsIDB4OWY1NTVmYTMsIDB4Yzg0YzY0YzIsIDB4MjM5M2I4NmIsIDB4NmY1M2IxNTEsIDB4OTYzODc3MTksIDB4NTk0MGVhYmQsXG4gICAgMHg5NjI4M2VlMiwgMHhhODhlZmZlMywgMHhiZTVlMWUyNSwgMHg1Mzg2Mzk5MiwgMHgyYjAxOTlmYywgMHgyYzg1YjhhYSwgMHgwZWI3MmRkYywgMHg4MWM1MmNhMixcbl0pO1xuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDI4KTtcbiAgICAgICAgdGhpcy5BaCA9IFQyMjRfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkFsID0gVDIyNF9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBUMjI0X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IFQyMjRfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkNoID0gVDIyNF9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBUMjI0X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IFQyMjRfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkRsID0gVDIyNF9JVls3XSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBUMjI0X0lWWzhdIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IFQyMjRfSVZbOV0gfCAwO1xuICAgICAgICB0aGlzLkZoID0gVDIyNF9JVlsxMF0gfCAwO1xuICAgICAgICB0aGlzLkZsID0gVDIyNF9JVlsxMV0gfCAwO1xuICAgICAgICB0aGlzLkdoID0gVDIyNF9JVlsxMl0gfCAwO1xuICAgICAgICB0aGlzLkdsID0gVDIyNF9JVlsxM10gfCAwO1xuICAgICAgICB0aGlzLkhoID0gVDIyNF9JVlsxNF0gfCAwO1xuICAgICAgICB0aGlzLkhsID0gVDIyNF9JVlsxNV0gfCAwO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyXzIyNCA9IFNIQTUxMl8yMjQ7XG5jbGFzcyBTSEE1MTJfMjU2IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoMzIpO1xuICAgICAgICB0aGlzLkFoID0gVDI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBUMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IFQyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkJsID0gVDI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBUMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IFQyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkRoID0gVDI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBUMjU2X0lWWzddIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IFQyNTZfSVZbOF0gfCAwO1xuICAgICAgICB0aGlzLkVsID0gVDI1Nl9JVls5XSB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBUMjU2X0lWWzEwXSB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBUMjU2X0lWWzExXSB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBUMjU2X0lWWzEyXSB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBUMjU2X0lWWzEzXSB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBUMjU2X0lWWzE0XSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBUMjU2X0lWWzE1XSB8IDA7XG4gICAgfVxufVxuZXhwb3J0cy5TSEE1MTJfMjU2ID0gU0hBNTEyXzI1Njtcbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LlxuICpcbiAqIEl0IGlzIHRoZSBmYXN0ZXN0IEpTIGhhc2gsIGV2ZW4gZmFzdGVyIHRoYW4gQmxha2UzLlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKi9cbmV4cG9ydHMuc2hhMjU2ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBMjU2KCkpO1xuLyoqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb24gZnJvbSBSRkMgNDYzNCAqL1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vKiogU0hBMi01MTIgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0cy5zaGE1MTIgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTIoKSk7XG4vKiogU0hBMi0zODQgaGFzaCBmdW5jdGlvbiBmcm9tIFJGQyA0NjM0LiAqL1xuZXhwb3J0cy5zaGEzODQgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vKipcbiAqIFNIQTItNTEyLzI1NiBcInRydW5jYXRlZFwiIGhhc2ggZnVuY3Rpb24sIHdpdGggaW1wcm92ZWQgcmVzaXN0YW5jZSB0byBsZW5ndGggZXh0ZW5zaW9uIGF0dGFja3MuXG4gKiBTZWUgdGhlIHBhcGVyIG9uIFt0cnVuY2F0ZWQgU0hBNTEyXShodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEwLzU0OC5wZGYpLlxuICovXG5leHBvcnRzLnNoYTUxMl8yNTYgPSAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBTSEE1MTJfMjU2KCkpO1xuLyoqXG4gKiBTSEEyLTUxMi8yMjQgXCJ0cnVuY2F0ZWRcIiBoYXNoIGZ1bmN0aW9uLCB3aXRoIGltcHJvdmVkIHJlc2lzdGFuY2UgdG8gbGVuZ3RoIGV4dGVuc2lvbiBhdHRhY2tzLlxuICogU2VlIHRoZSBwYXBlciBvbiBbdHJ1bmNhdGVkIFNIQTUxMl0oaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC81NDgucGRmKS5cbiAqL1xuZXhwb3J0cy5zaGE1MTJfMjI0ID0gKDAsIHV0aWxzX3RzXzEuY3JlYXRlSGFzaGVyKSgoKSA9PiBuZXcgU0hBNTEyXzIyNCgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha2.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha256.js":
/*!******************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/sha256.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.sha224 = exports.SHA224 = exports.sha256 = exports.SHA256 = void 0;\n/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nconst sha2_ts_1 = __webpack_require__(/*! ./sha2.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha2.js\");\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA256 = sha2_ts_1.SHA256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha256 = sha2_ts_1.sha256;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.SHA224 = sha2_ts_1.SHA224;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexports.sha224 = sha2_ts_1.sha224;\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLEdBQUcsY0FBYyxHQUFHLGNBQWMsR0FBRyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsaUZBQVc7QUFDckM7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2QiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXHNoYTI1Ni5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMjI0ID0gZXhwb3J0cy5TSEEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuLyoqXG4gKiBTSEEyLTI1NiBhLmsuYS4gc2hhMjU2LiBJbiBKUywgaXQgaXMgdGhlIGZhc3Rlc3QgaGFzaCwgZXZlbiBmYXN0ZXIgdGhhbiBCbGFrZTMuXG4gKlxuICogVG8gYnJlYWsgc2hhMjU2IHVzaW5nIGJpcnRoZGF5IGF0dGFjaywgYXR0YWNrZXJzIG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcy5cbiAqIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNzAgaGFzaGVzL3NlYyAoMl45NSBoYXNoZXMveWVhcikgYXMgcGVyIDIwMjUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTIDE4MC00XShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmKS5cbiAqIEBtb2R1bGVcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IHNoYTJfdHNfMSA9IHJlcXVpcmUoXCIuL3NoYTIuanNcIik7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTI1NiA9IHNoYTJfdHNfMS5TSEEyNTY7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTI1NiA9IHNoYTJfdHNfMS5zaGEyNTY7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLlNIQTIyNCA9IHNoYTJfdHNfMS5TSEEyMjQ7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGltcG9ydCBmcm9tIGBub2JsZS9oYXNoZXMvc2hhMmAgbW9kdWxlICovXG5leHBvcnRzLnNoYTIyNCA9IHNoYTJfdHNfMS5zaGEyMjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha256.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha3.js":
/*!****************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/sha3.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = void 0;\nexports.keccakP = keccakP;\n/**\n * SHA3 (keccak) hash function, based on a new \"Sponge function\" design.\n * Different from older hashes, the internal state is bigger than output size.\n *\n * Check out [FIPS-202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf),\n * [Website](https://keccak.team/keccak.html),\n * [the differences between SHA-3 and Keccak](https://crypto.stackexchange.com/questions/15727/what-are-the-key-differences-between-the-draft-sha-3-standard-and-the-keccak-sub).\n *\n * Check out `sha3-addons` module for cSHAKE, k12, and others.\n * @module\n */\nconst _u64_ts_1 = __webpack_require__(/*! ./_u64.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/_u64.js\");\n// prettier-ignore\nconst utils_ts_1 = __webpack_require__(/*! ./utils.js */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\");\n// No __PURE__ annotations in sha3 header:\n// EVERYTHING is in fact used on every export.\n// Various per round constants calculations\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst IOTAS = (0, _u64_ts_1.split)(_SHA3_IOTA, true);\nconst SHA3_IOTA_H = IOTAS[0];\nconst SHA3_IOTA_L = IOTAS[1];\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBH)(h, l, s) : (0, _u64_ts_1.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0, _u64_ts_1.rotlBL)(h, l, s) : (0, _u64_ts_1.rotlSL)(h, l, s));\n/** `keccakf1600` internal function, additionally allows to adjust round count. */\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    (0, utils_ts_1.clean)(B);\n}\n/** Keccak sponge function. */\nclass Keccak extends utils_ts_1.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        this.enableXOF = false;\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        // Can be passed from user as dkLen\n        (0, utils_ts_1.anumber)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        // 0 < blockLen < 200\n        if (!(0 < blockLen && blockLen < 200))\n            throw new Error('only keccak-f1600 function is supported');\n        this.state = new Uint8Array(200);\n        this.state32 = (0, utils_ts_1.u32)(this.state);\n    }\n    clone() {\n        return this._cloneInto();\n    }\n    keccak() {\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        keccakP(this.state32, this.rounds);\n        (0, utils_ts_1.swap32IfBE)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0, utils_ts_1.aexists)(this);\n        data = (0, utils_ts_1.toBytes)(data);\n        (0, utils_ts_1.abytes)(data);\n        const { blockLen, state } = this;\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0, utils_ts_1.aexists)(this, false);\n        (0, utils_ts_1.abytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0, utils_ts_1.anumber)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0, utils_ts_1.aoutput)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        (0, utils_ts_1.clean)(this.state);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nexports.Keccak = Keccak;\nconst gen = (suffix, blockLen, outputLen) => (0, utils_ts_1.createHasher)(() => new Keccak(blockLen, suffix, outputLen));\n/** SHA3-224 hash function. */\nexports.sha3_224 = (() => gen(0x06, 144, 224 / 8))();\n/** SHA3-256 hash function. Different from keccak-256. */\nexports.sha3_256 = (() => gen(0x06, 136, 256 / 8))();\n/** SHA3-384 hash function. */\nexports.sha3_384 = (() => gen(0x06, 104, 384 / 8))();\n/** SHA3-512 hash function. */\nexports.sha3_512 = (() => gen(0x06, 72, 512 / 8))();\n/** keccak-224 hash function. */\nexports.keccak_224 = (() => gen(0x01, 144, 224 / 8))();\n/** keccak-256 hash function. Different from SHA3-256. */\nexports.keccak_256 = (() => gen(0x01, 136, 256 / 8))();\n/** keccak-384 hash function. */\nexports.keccak_384 = (() => gen(0x01, 104, 384 / 8))();\n/** keccak-512 hash function. */\nexports.keccak_512 = (() => gen(0x01, 72, 512 / 8))();\nconst genShake = (suffix, blockLen, outputLen) => (0, utils_ts_1.createXOFer)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\n/** SHAKE128 XOF with 128-bit security. */\nexports.shake128 = (() => genShake(0x1f, 168, 128 / 8))();\n/** SHAKE256 XOF with 256-bit security. */\nexports.shake256 = (() => genShake(0x1f, 136, 256 / 8))();\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3NoYTMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsZ0JBQWdCLEdBQUcsY0FBYztBQUNwTixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsbUZBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQiw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEIsd0ZBQXdGO0FBQ3hGO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGNoaW1kXFxjb3NtaWMtZGV4XFxub2RlX21vZHVsZXNcXG94XFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxzaGEzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGFrZTI1NiA9IGV4cG9ydHMuc2hha2UxMjggPSBleHBvcnRzLmtlY2Nha181MTIgPSBleHBvcnRzLmtlY2Nha18zODQgPSBleHBvcnRzLmtlY2Nha18yNTYgPSBleHBvcnRzLmtlY2Nha18yMjQgPSBleHBvcnRzLnNoYTNfNTEyID0gZXhwb3J0cy5zaGEzXzM4NCA9IGV4cG9ydHMuc2hhM18yNTYgPSBleHBvcnRzLnNoYTNfMjI0ID0gZXhwb3J0cy5LZWNjYWsgPSB2b2lkIDA7XG5leHBvcnRzLmtlY2Nha1AgPSBrZWNjYWtQO1xuLyoqXG4gKiBTSEEzIChrZWNjYWspIGhhc2ggZnVuY3Rpb24sIGJhc2VkIG9uIGEgbmV3IFwiU3BvbmdlIGZ1bmN0aW9uXCIgZGVzaWduLlxuICogRGlmZmVyZW50IGZyb20gb2xkZXIgaGFzaGVzLCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4gKlxuICogQ2hlY2sgb3V0IFtGSVBTLTIwMl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjIwMi5wZGYpLFxuICogW1dlYnNpdGVdKGh0dHBzOi8va2VjY2FrLnRlYW0va2VjY2FrLmh0bWwpLFxuICogW3RoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIFNIQS0zIGFuZCBLZWNjYWtdKGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xNTcyNy93aGF0LWFyZS10aGUta2V5LWRpZmZlcmVuY2VzLWJldHdlZW4tdGhlLWRyYWZ0LXNoYS0zLXN0YW5kYXJkLWFuZC10aGUta2VjY2FrLXN1YikuXG4gKlxuICogQ2hlY2sgb3V0IGBzaGEzLWFkZG9uc2AgbW9kdWxlIGZvciBjU0hBS0UsIGsxMiwgYW5kIG90aGVycy5cbiAqIEBtb2R1bGVcbiAqL1xuY29uc3QgX3U2NF90c18xID0gcmVxdWlyZShcIi4vX3U2NC5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdXRpbHNfdHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gTm8gX19QVVJFX18gYW5ub3RhdGlvbnMgaW4gc2hhMyBoZWFkZXI6XG4vLyBFVkVSWVRISU5HIGlzIGluIGZhY3QgdXNlZCBvbiBldmVyeSBleHBvcnQuXG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5jb25zdCBfN24gPSBCaWdJbnQoNyk7XG5jb25zdCBfMjU2biA9IEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gQmlnSW50KDB4NzEpO1xuY29uc3QgU0hBM19QSSA9IFtdO1xuY29uc3QgU0hBM19ST1RMID0gW107XG5jb25zdCBfU0hBM19JT1RBID0gW107XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCAvKiBAX19QVVJFX18gKi8gQmlnSW50KGopKSAtIF8xbik7XG4gICAgfVxuICAgIF9TSEEzX0lPVEEucHVzaCh0KTtcbn1cbmNvbnN0IElPVEFTID0gKDAsIF91NjRfdHNfMS5zcGxpdCkoX1NIQTNfSU9UQSwgdHJ1ZSk7XG5jb25zdCBTSEEzX0lPVEFfSCA9IElPVEFTWzBdO1xuY29uc3QgU0hBM19JT1RBX0wgPSBJT1RBU1sxXTtcbi8vIExlZnQgcm90YXRpb24gKHdpdGhvdXQgMCwgMzIsIDY0KVxuY29uc3Qgcm90bEggPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/ICgwLCBfdTY0X3RzXzEucm90bEJIKShoLCBsLCBzKSA6ICgwLCBfdTY0X3RzXzEucm90bFNIKShoLCBsLCBzKSk7XG5jb25zdCByb3RsTCA9IChoLCBsLCBzKSA9PiAocyA+IDMyID8gKDAsIF91NjRfdHNfMS5yb3RsQkwpKGgsIGwsIHMpIDogKDAsIF91NjRfdHNfMS5yb3RsU0wpKGgsIGwsIHMpKTtcbi8qKiBga2VjY2FrZjE2MDBgIGludGVybmFsIGZ1bmN0aW9uLCBhZGRpdGlvbmFsbHkgYWxsb3dzIHRvIGFkanVzdCByb3VuZCBjb3VudC4gKi9cbmZ1bmN0aW9uIGtlY2Nha1Aocywgcm91bmRzID0gMjQpIHtcbiAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KDUgKiAyKTtcbiAgICAvLyBOT1RFOiBhbGwgaW5kaWNlcyBhcmUgeDIgc2luY2Ugd2Ugc3RvcmUgc3RhdGUgYXMgdTMyIGluc3RlYWQgb2YgdTY0IChiaWdpbnRzIHRvIHNsb3cgaW4ganMpXG4gICAgZm9yIChsZXQgcm91bmQgPSAyNCAtIHJvdW5kczsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgICAgICAvLyBUaGV0YSDOuFxuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICBCW3hdID0gc1t4XSBeIHNbeCArIDEwXSBeIHNbeCArIDIwXSBeIHNbeCArIDMwXSBeIHNbeCArIDQwXTtcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCArPSAyKSB7XG4gICAgICAgICAgICBjb25zdCBpZHgxID0gKHggKyA4KSAlIDEwO1xuICAgICAgICAgICAgY29uc3QgaWR4MCA9ICh4ICsgMikgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IEIwID0gQltpZHgwXTtcbiAgICAgICAgICAgIGNvbnN0IEIxID0gQltpZHgwICsgMV07XG4gICAgICAgICAgICBjb25zdCBUaCA9IHJvdGxIKEIwLCBCMSwgMSkgXiBCW2lkeDFdO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChCMCwgQjEsIDEpIF4gQltpZHgxICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IDUwOyB5ICs9IDEwKSB7XG4gICAgICAgICAgICAgICAgc1t4ICsgeV0gXj0gVGg7XG4gICAgICAgICAgICAgICAgc1t4ICsgeSArIDFdIF49IFRsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJobyAoz4EpIGFuZCBQaSAoz4ApXG4gICAgICAgIGxldCBjdXJIID0gc1syXTtcbiAgICAgICAgbGV0IGN1ckwgPSBzWzNdO1xuICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IDI0OyB0KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gU0hBM19ST1RMW3RdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBUbCA9IHJvdGxMKGN1ckgsIGN1ckwsIHNoaWZ0KTtcbiAgICAgICAgICAgIGNvbnN0IFBJID0gU0hBM19QSVt0XTtcbiAgICAgICAgICAgIGN1ckggPSBzW1BJXTtcbiAgICAgICAgICAgIGN1ckwgPSBzW1BJICsgMV07XG4gICAgICAgICAgICBzW1BJXSA9IFRoO1xuICAgICAgICAgICAgc1tQSSArIDFdID0gVGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hpICjPhylcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgICAgIEJbeF0gPSBzW3kgKyB4XTtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBzW3kgKyB4XSBePSB+QlsoeCArIDIpICUgMTBdICYgQlsoeCArIDQpICUgMTBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIElvdGEgKM65KVxuICAgICAgICBzWzBdIF49IFNIQTNfSU9UQV9IW3JvdW5kXTtcbiAgICAgICAgc1sxXSBePSBTSEEzX0lPVEFfTFtyb3VuZF07XG4gICAgfVxuICAgICgwLCB1dGlsc190c18xLmNsZWFuKShCKTtcbn1cbi8qKiBLZWNjYWsgc3BvbmdlIGZ1bmN0aW9uLiAqL1xuY2xhc3MgS2VjY2FrIGV4dGVuZHMgdXRpbHNfdHNfMS5IYXNoIHtcbiAgICAvLyBOT1RFOiB3ZSBhY2NlcHQgYXJndW1lbnRzIGluIGJ5dGVzIGluc3RlYWQgb2YgYml0cyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GID0gZmFsc2UsIHJvdW5kcyA9IDI0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5wb3NPdXQgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW5hYmxlWE9GID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5zdWZmaXggPSBzdWZmaXg7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdGhpcy5yb3VuZHMgPSByb3VuZHM7XG4gICAgICAgIC8vIENhbiBiZSBwYXNzZWQgZnJvbSB1c2VyIGFzIGRrTGVuXG4gICAgICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgLy8gMCA8IGJsb2NrTGVuIDwgMjAwXG4gICAgICAgIGlmICghKDAgPCBibG9ja0xlbiAmJiBibG9ja0xlbiA8IDIwMCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gKDAsIHV0aWxzX3RzXzEudTMyKSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG4gICAga2VjY2FrKCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5zd2FwMzJJZkJFKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5zd2FwMzJJZkJFKSh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0aGlzLnBvc091dCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWV4aXN0cykodGhpcyk7XG4gICAgICAgIGRhdGEgPSAoMCwgdXRpbHNfdHNfMS50b0J5dGVzKShkYXRhKTtcbiAgICAgICAgKDAsIHV0aWxzX3RzXzEuYWJ5dGVzKShkYXRhKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hZXhpc3RzKSh0aGlzLCBmYWxzZSk7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFieXRlcykob3V0KTtcbiAgICAgICAgdGhpcy5maW5pc2goKTtcbiAgICAgICAgY29uc3QgYnVmZmVyT3V0ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMCwgbGVuID0gb3V0Lmxlbmd0aDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zT3V0ID49IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvc091dCwgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIG91dC5zZXQoYnVmZmVyT3V0LnN1YmFycmF5KHRoaXMucG9zT3V0LCB0aGlzLnBvc091dCArIHRha2UpLCBwb3MpO1xuICAgICAgICAgICAgdGhpcy5wb3NPdXQgKz0gdGFrZTtcbiAgICAgICAgICAgIHBvcyArPSB0YWtlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHhvZkludG8ob3V0KSB7XG4gICAgICAgIC8vIFNoYTMvS2VjY2FrIHVzYWdlIHdpdGggWE9GIGlzIHByb2JhYmx5IG1pc3Rha2UsIG9ubHkgU0hBS0UgaW5zdGFuY2VzIGNhbiBkbyBYT0ZcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZVhPRilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWE9GIGlzIG5vdCBwb3NzaWJsZSBmb3IgdGhpcyBpbnN0YW5jZScpO1xuICAgICAgICByZXR1cm4gdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICB9XG4gICAgeG9mKGJ5dGVzKSB7XG4gICAgICAgICgwLCB1dGlsc190c18xLmFudW1iZXIpKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5hb3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICAoMCwgdXRpbHNfdHNfMS5jbGVhbikodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuZXhwb3J0cy5LZWNjYWsgPSBLZWNjYWs7XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiAoMCwgdXRpbHNfdHNfMS5jcmVhdGVIYXNoZXIpKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG4vKiogU0hBMy0yMjQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM18yMjQgPSAoKCkgPT4gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKiogU0hBMy0yNTYgaGFzaCBmdW5jdGlvbi4gRGlmZmVyZW50IGZyb20ga2VjY2FrLTI1Ni4gKi9cbmV4cG9ydHMuc2hhM18yNTYgPSAoKCkgPT4gZ2VuKDB4MDYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vKiogU0hBMy0zODQgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM18zODQgPSAoKCkgPT4gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKiogU0hBMy01MTIgaGFzaCBmdW5jdGlvbi4gKi9cbmV4cG9ydHMuc2hhM181MTIgPSAoKCkgPT4gZ2VuKDB4MDYsIDcyLCA1MTIgLyA4KSkoKTtcbi8qKiBrZWNjYWstMjI0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLmtlY2Nha18yMjQgPSAoKCkgPT4gZ2VuKDB4MDEsIDE0NCwgMjI0IC8gOCkpKCk7XG4vKioga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni4gKi9cbmV4cG9ydHMua2VjY2FrXzI1NiA9ICgoKSA9PiBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KSkoKTtcbi8qKiBrZWNjYWstMzg0IGhhc2ggZnVuY3Rpb24uICovXG5leHBvcnRzLmtlY2Nha18zODQgPSAoKCkgPT4gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCkpKCk7XG4vKioga2VjY2FrLTUxMiBoYXNoIGZ1bmN0aW9uLiAqL1xuZXhwb3J0cy5rZWNjYWtfNTEyID0gKCgpID0+IGdlbigweDAxLCA3MiwgNTEyIC8gOCkpKCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+ICgwLCB1dGlsc190c18xLmNyZWF0ZVhPRmVyKSgob3B0cyA9IHt9KSA9PiBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG9wdHMuZGtMZW4gPT09IHVuZGVmaW5lZCA/IG91dHB1dExlbiA6IG9wdHMuZGtMZW4sIHRydWUpKTtcbi8qKiBTSEFLRTEyOCBYT0Ygd2l0aCAxMjgtYml0IHNlY3VyaXR5LiAqL1xuZXhwb3J0cy5zaGFrZTEyOCA9ICgoKSA9PiBnZW5TaGFrZSgweDFmLCAxNjgsIDEyOCAvIDgpKSgpO1xuLyoqIFNIQUtFMjU2IFhPRiB3aXRoIDI1Ni1iaXQgc2VjdXJpdHkuICovXG5leHBvcnRzLnNoYWtlMjU2ID0gKCgpID0+IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCkpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/sha3.js\n");

/***/ }),

/***/ "(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/ox/node_modules/@noble/hashes/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.Hash = exports.nextTick = exports.swap32IfBE = exports.byteSwapIfBE = exports.swap8IfBE = exports.isLE = void 0;\nexports.isBytes = isBytes;\nexports.anumber = anumber;\nexports.abytes = abytes;\nexports.ahash = ahash;\nexports.aexists = aexists;\nexports.aoutput = aoutput;\nexports.u8 = u8;\nexports.u32 = u32;\nexports.clean = clean;\nexports.createView = createView;\nexports.rotr = rotr;\nexports.rotl = rotl;\nexports.byteSwap = byteSwap;\nexports.byteSwap32 = byteSwap32;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.asyncLoop = asyncLoop;\nexports.utf8ToBytes = utf8ToBytes;\nexports.bytesToUtf8 = bytesToUtf8;\nexports.toBytes = toBytes;\nexports.kdfInputToBytes = kdfInputToBytes;\nexports.concatBytes = concatBytes;\nexports.checkOpts = checkOpts;\nexports.createHasher = createHasher;\nexports.createOptHasher = createOptHasher;\nexports.createXOFer = createXOFer;\nexports.randomBytes = randomBytes;\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nconst crypto_1 = __webpack_require__(/*! @noble/hashes/crypto */ \"(ssr)/../../node_modules/ox/node_modules/@noble/hashes/cryptoNode.js\");\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is positive integer. */\nfunction anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error('positive integer expected, got ' + n);\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n/** Asserts something is hash */\nfunction ahash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.createHasher');\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n}\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out, instance) {\n    abytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error('digestInto() expects output buffer of length at least ' + min);\n    }\n}\n/** Cast u8 / u16 / u32 to u8. */\nfunction u8(arr) {\n    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** Cast u8 / u16 / u32 to u32. */\nfunction u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nfunction clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n        arrays[i].fill(0);\n    }\n}\n/** Create DataView of an array for easy byte-level manipulation. */\nfunction createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n/** The rotate right (circular right shift) operation for uint32 */\nfunction rotr(word, shift) {\n    return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nfunction rotl(word, shift) {\n    return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexports.isLE = (() => new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n/** The byte swap operation for uint32 */\nfunction byteSwap(word) {\n    return (((word << 24) & 0xff000000) |\n        ((word << 8) & 0xff0000) |\n        ((word >>> 8) & 0xff00) |\n        ((word >>> 24) & 0xff));\n}\n/** Conditionally byte swap if on a big-endian platform */\nexports.swap8IfBE = exports.isLE\n    ? (n) => n\n    : (n) => byteSwap(n);\n/** @deprecated */\nexports.byteSwapIfBE = exports.swap8IfBE;\n/** In place byte swap for Uint32Array */\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n}\nexports.swap32IfBE = exports.isLE\n    ? (u) => u\n    : byteSwap32;\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = /* @__PURE__ */ (() => \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nconst nextTick = async () => { };\nexports.nextTick = nextTick;\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await (0, exports.nextTick)();\n        ts += diff;\n    }\n}\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nfunction bytesToUtf8(bytes) {\n    return new TextDecoder().decode(bytes);\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nfunction kdfInputToBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n}\n/** Copies several Uint8Arrays into one. */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n        throw new Error('options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\n/** For runtime check if class implements interface */\nclass Hash {\n}\nexports.Hash = Hash;\n/** Wraps hash function, creating an interface on top of it */\nfunction createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction createOptHasher(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction createXOFer(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nexports.wrapConstructor = createHasher;\nexports.wrapConstructorWithOpts = createOptHasher;\nexports.wrapXOFConstructorWithOpts = createXOFer;\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nfunction randomBytes(bytesLength = 32) {\n    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {\n        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    // Legacy Node.js compatibility\n    if (crypto_1.crypto && typeof crypto_1.crypto.randomBytes === 'function') {\n        return Uint8Array.from(crypto_1.crypto.randomBytes(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL294L25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL3V0aWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQ0FBa0MsR0FBRywrQkFBK0IsR0FBRyx1QkFBdUIsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLEdBQUcsa0JBQWtCLEdBQUcsb0JBQW9CLEdBQUcsaUJBQWlCLEdBQUcsWUFBWTtBQUMvTSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGNBQWM7QUFDZCxhQUFhO0FBQ2IsZUFBZTtBQUNmLGVBQWU7QUFDZixVQUFVO0FBQ1YsV0FBVztBQUNYLGFBQWE7QUFDYixrQkFBa0I7QUFDbEIsWUFBWTtBQUNaLFlBQVk7QUFDWixnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixtQkFBbUI7QUFDbkIsZUFBZTtBQUNmLHVCQUF1QjtBQUN2QixtQkFBbUI7QUFDbkIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsbUJBQW1CO0FBQ25CLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxrR0FBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLHFDQUFxQztBQUNyQztBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsK0JBQStCO0FBQy9CLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcY2hpbWRcXGNvc21pYy1kZXhcXG5vZGVfbW9kdWxlc1xcb3hcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxoYXNoZXNcXHV0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBVdGlsaXRpZXMgZm9yIGhleCwgYnl0ZXMsIENTUFJORy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cyA9IGV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBleHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGV4cG9ydHMuSGFzaCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLnN3YXAzMklmQkUgPSBleHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuc3dhcDhJZkJFID0gZXhwb3J0cy5pc0xFID0gdm9pZCAwO1xuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmV4cG9ydHMuYW51bWJlciA9IGFudW1iZXI7XG5leHBvcnRzLmFieXRlcyA9IGFieXRlcztcbmV4cG9ydHMuYWhhc2ggPSBhaGFzaDtcbmV4cG9ydHMuYWV4aXN0cyA9IGFleGlzdHM7XG5leHBvcnRzLmFvdXRwdXQgPSBhb3V0cHV0O1xuZXhwb3J0cy51OCA9IHU4O1xuZXhwb3J0cy51MzIgPSB1MzI7XG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG5leHBvcnRzLmNyZWF0ZVZpZXcgPSBjcmVhdGVWaWV3O1xuZXhwb3J0cy5yb3RyID0gcm90cjtcbmV4cG9ydHMucm90bCA9IHJvdGw7XG5leHBvcnRzLmJ5dGVTd2FwID0gYnl0ZVN3YXA7XG5leHBvcnRzLmJ5dGVTd2FwMzIgPSBieXRlU3dhcDMyO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmFzeW5jTG9vcCA9IGFzeW5jTG9vcDtcbmV4cG9ydHMudXRmOFRvQnl0ZXMgPSB1dGY4VG9CeXRlcztcbmV4cG9ydHMuYnl0ZXNUb1V0ZjggPSBieXRlc1RvVXRmODtcbmV4cG9ydHMudG9CeXRlcyA9IHRvQnl0ZXM7XG5leHBvcnRzLmtkZklucHV0VG9CeXRlcyA9IGtkZklucHV0VG9CeXRlcztcbmV4cG9ydHMuY29uY2F0Qnl0ZXMgPSBjb25jYXRCeXRlcztcbmV4cG9ydHMuY2hlY2tPcHRzID0gY2hlY2tPcHRzO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG5leHBvcnRzLmNyZWF0ZU9wdEhhc2hlciA9IGNyZWF0ZU9wdEhhc2hlcjtcbmV4cG9ydHMuY3JlYXRlWE9GZXIgPSBjcmVhdGVYT0ZlcjtcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuLyoqIENoZWNrcyBpZiBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gQmUgY2FyZWZ1bDogbm9kZWpzIEJ1ZmZlciB3aWxsIHJldHVybiB0cnVlLiAqL1xuZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpO1xufVxuLyoqIEFzc2VydHMgc29tZXRoaW5nIGlzIHBvc2l0aXZlIGludGVnZXIuICovXG5mdW5jdGlvbiBhbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIGdvdCAnICsgbik7XG59XG4vKiogQXNzZXJ0cyBzb21ldGhpbmcgaXMgVWludDhBcnJheS4gKi9cbmZ1bmN0aW9uIGFieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAnICsgbGVuZ3RocyArICcsIGdvdCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbn1cbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBoYXNoICovXG5mdW5jdGlvbiBhaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLmNyZWF0ZUhhc2hlcicpO1xuICAgIGFudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIGFudW1iZXIoaC5ibG9ja0xlbik7XG59XG4vKiogQXNzZXJ0cyBhIGhhc2ggaW5zdGFuY2UgaGFzIG5vdCBiZWVuIGRlc3Ryb3llZCAvIGZpbmlzaGVkICovXG5mdW5jdGlvbiBhZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG4vKiogQXNzZXJ0cyBvdXRwdXQgaXMgcHJvcGVybHktc2l6ZWQgYnl0ZSBhcnJheSAqL1xuZnVuY3Rpb24gYW91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYWJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJyArIG1pbik7XG4gICAgfVxufVxuLyoqIENhc3QgdTggLyB1MTYgLyB1MzIgdG8gdTguICovXG5mdW5jdGlvbiB1OChhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbn1cbi8qKiBDYXN0IHU4IC8gdTE2IC8gdTMyIHRvIHUzMi4gKi9cbmZ1bmN0aW9uIHUzMihhcnIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xufVxuLyoqIFplcm9pemUgYSBieXRlIGFycmF5LiBXYXJuaW5nOiBKUyBwcm92aWRlcyBubyBndWFyYW50ZWVzLiAqL1xuZnVuY3Rpb24gY2xlYW4oLi4uYXJyYXlzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlzW2ldLmZpbGwoMCk7XG4gICAgfVxufVxuLyoqIENyZWF0ZSBEYXRhVmlldyBvZiBhbiBhcnJheSBmb3IgZWFzeSBieXRlLWxldmVsIG1hbmlwdWxhdGlvbi4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZpZXcoYXJyKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xufVxuLyoqIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMiAqL1xuZnVuY3Rpb24gcm90cih3b3JkLCBzaGlmdCkge1xuICAgIHJldHVybiAod29yZCA8PCAoMzIgLSBzaGlmdCkpIHwgKHdvcmQgPj4+IHNoaWZ0KTtcbn1cbi8qKiBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiByb3RsKHdvcmQsIHNoaWZ0KSB7XG4gICAgcmV0dXJuICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG59XG4vKiogSXMgY3VycmVudCBwbGF0Zm9ybSBsaXR0bGUtZW5kaWFuPyBNb3N0IGFyZS4gQmlnLUVuZGlhbiBwbGF0Zm9ybTogSUJNICovXG5leHBvcnRzLmlzTEUgPSAoKCkgPT4gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NCkoKTtcbi8qKiBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyICovXG5mdW5jdGlvbiBieXRlU3dhcCh3b3JkKSB7XG4gICAgcmV0dXJuICgoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAoKHdvcmQgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICgod29yZCA+Pj4gMjQpICYgMHhmZikpO1xufVxuLyoqIENvbmRpdGlvbmFsbHkgYnl0ZSBzd2FwIGlmIG9uIGEgYmlnLWVuZGlhbiBwbGF0Zm9ybSAqL1xuZXhwb3J0cy5zd2FwOElmQkUgPSBleHBvcnRzLmlzTEVcbiAgICA/IChuKSA9PiBuXG4gICAgOiAobikgPT4gYnl0ZVN3YXAobik7XG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydHMuYnl0ZVN3YXBJZkJFID0gZXhwb3J0cy5zd2FwOElmQkU7XG4vKiogSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheSAqL1xuZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZXhwb3J0cy5zd2FwMzJJZkJFID0gZXhwb3J0cy5pc0xFXG4gICAgPyAodSkgPT4gdVxuICAgIDogYnl0ZVN3YXAzMjtcbi8vIEJ1aWx0LWluIGhleCBjb252ZXJzaW9uIGh0dHBzOi8vY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfdWludDhhcnJheV9mcm9taGV4XG5jb25zdCBoYXNIZXhCdWlsdGluID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBcbi8vIEB0cy1pZ25vcmVcbnR5cGVvZiBVaW50OEFycmF5LmZyb20oW10pLnRvSGV4ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBVaW50OEFycmF5LmZyb21IZXggPT09ICdmdW5jdGlvbicpKCk7XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQ29udmVydCBieXRlIGFycmF5IHRvIGhleCBzdHJpbmcuIFVzZXMgYnVpbHQtaW4gZnVuY3Rpb24sIHdoZW4gYXZhaWxhYmxlLlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5mdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGhhc0hleEJ1aWx0aW4pXG4gICAgICAgIHJldHVybiBieXRlcy50b0hleCgpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoKSB7XG4gICAgaWYgKGNoID49IGFzY2lpcy5fMCAmJiBjaCA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaCAtIGFzY2lpcy5fMDsgLy8gJzInID0+IDUwLTQ4XG4gICAgaWYgKGNoID49IGFzY2lpcy5BICYmIGNoIDw9IGFzY2lpcy5GKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLkEgLSAxMCk7IC8vICdCJyA9PiA2Ni0oNjUtMTApXG4gICAgaWYgKGNoID49IGFzY2lpcy5hICYmIGNoIDw9IGFzY2lpcy5mKVxuICAgICAgICByZXR1cm4gY2ggLSAoYXNjaWlzLmEgLSAxMCk7IC8vICdiJyA9PiA5OC0oOTctMTApXG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBDb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheS4gVXNlcyBidWlsdC1pbiBmdW5jdGlvbiwgd2hlbiBhdmFpbGFibGUuXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChoYXNIZXhCdWlsdGluKVxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tSGV4KGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjsgLy8gbXVsdGlwbHkgZmlyc3Qgb2N0ZXQsIGUuZy4gJ2EzJyA9PiAxMCoxNiszID0+IDE2MCArIDMgPT4gMTYzXG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKlxuICogVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbiAqIENhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuICogbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuICovXG5jb25zdCBuZXh0VGljayA9IGFzeW5jICgpID0+IHsgfTtcbmV4cG9ydHMubmV4dFRpY2sgPSBuZXh0VGljaztcbi8qKiBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nLiAqL1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQ29udmVydHMgc3RyaW5nIHRvIGJ5dGVzIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gVWludDhBcnJheS5mcm9tKFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyBleHBlY3RlZCcpO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb1V0ZjgoYnl0ZXMpIHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKGJ5dGVzKTtcbn1cbi8qKlxuICogTm9ybWFsaXplcyAobm9uLWhleCkgc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gVWludDhBcnJheS5cbiAqIFdhcm5pbmc6IHdoZW4gVWludDhBcnJheSBpcyBwYXNzZWQsIGl0IHdvdWxkIE5PVCBnZXQgY29waWVkLlxuICogS2VlcCBpbiBtaW5kIGZvciBmdXR1cmUgbXV0YWJsZSBvcGVyYXRpb25zLlxuICovXG5mdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBIZWxwZXIgZm9yIEtERnM6IGNvbnN1bWVzIHVpbnQ4YXJyYXkgb3Igc3RyaW5nLlxuICogV2hlbiBzdHJpbmcgaXMgcGFzc2VkLCBkb2VzIHV0ZjggZGVjb2RpbmcsIHVzaW5nIFRleHREZWNvZGVyLlxuICovXG5mdW5jdGlvbiBrZGZJbnB1dFRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKiogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuICovXG5mdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICBhYnl0ZXMoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzICE9PSB1bmRlZmluZWQgJiYge30udG9TdHJpbmcuY2FsbChvcHRzKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucyBzaG91bGQgYmUgb2JqZWN0IG9yIHVuZGVmaW5lZCcpO1xuICAgIGNvbnN0IG1lcmdlZCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIG9wdHMpO1xuICAgIHJldHVybiBtZXJnZWQ7XG59XG4vKiogRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2UgKi9cbmNsYXNzIEhhc2gge1xufVxuZXhwb3J0cy5IYXNoID0gSGFzaDtcbi8qKiBXcmFwcyBoYXNoIGZ1bmN0aW9uLCBjcmVhdGluZyBhbiBpbnRlcmZhY2Ugb24gdG9wIG9mIGl0ICovXG5mdW5jdGlvbiBjcmVhdGVIYXNoZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZnVuY3Rpb24gY3JlYXRlT3B0SGFzaGVyKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZnVuY3Rpb24gY3JlYXRlWE9GZXIoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IGNyZWF0ZUhhc2hlcjtcbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSBjcmVhdGVPcHRIYXNoZXI7XG5leHBvcnRzLndyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzID0gY3JlYXRlWE9GZXI7XG4vKiogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIFBSTkcuIFVzZXMgaW50ZXJuYWwgT1MtbGV2ZWwgYGNyeXB0by5nZXRSYW5kb21WYWx1ZXNgLiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgLy8gTGVnYWN5IE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyhieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/ox/node_modules/@noble/hashes/utils.js\n");

/***/ })

};
;